{
    "sourceFile": "scripts/port-manager.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1752407728036,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1752407728036,
            "name": "Commit-0",
            "content": "#!/usr/bin/env node\n\n/**\n * AIMagic 项目端口管理工具\n * 统一管理项目端口，防止端口冲突，强制使用指定端口\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst { spawn, exec } = require('child_process');\nconst os = require('os');\n\nclass PortManager {\n  constructor() {\n    this.configPath = path.join(__dirname, '../port-config.json');\n    this.config = this.loadConfig();\n    this.platform = os.platform();\n  }\n\n  /**\n   * 加载端口配置\n   */\n  loadConfig() {\n    try {\n      const configData = fs.readFileSync(this.configPath, 'utf8');\n      return JSON.parse(configData);\n    } catch (error) {\n      console.error('❌ 无法加载端口配置文件:', error.message);\n      process.exit(1);\n    }\n  }\n\n  /**\n   * 检查端口是否被占用\n   */\n  async checkPortInUse(port) {\n    return new Promise((resolve) => {\n      const command = this.platform === 'win32'\n        ? `netstat -ano | findstr :${port}`\n        : `lsof -i :${port}`;\n\n      exec(command, (error, stdout) => {\n        if (error) {\n          resolve(false); // 端口未被占用\n        } else {\n          resolve(stdout.trim().length > 0); // 有输出说明端口被占用\n        }\n      });\n    });\n  }\n\n  /**\n   * 获取占用端口的进程ID\n   */\n  async getPortProcessId(port) {\n    return new Promise((resolve) => {\n      const command = this.platform === 'win32'\n        ? `netstat -ano | findstr :${port}`\n        : `lsof -ti :${port}`;\n\n      exec(command, (error, stdout) => {\n        if (error || !stdout.trim()) {\n          resolve(null);\n          return;\n        }\n\n        if (this.platform === 'win32') {\n          // Windows: 解析netstat输出获取PID\n          const lines = stdout.trim().split('\\n');\n          for (const line of lines) {\n            const parts = line.trim().split(/\\s+/);\n            if (parts.length >= 5) {\n              const pid = parts[parts.length - 1];\n              if (pid && !isNaN(pid)) {\n                resolve(parseInt(pid));\n                return;\n              }\n            }\n          }\n          resolve(null);\n        } else {\n          // Unix/Linux/Mac: lsof直接返回PID\n          const pid = parseInt(stdout.trim().split('\\n')[0]);\n          resolve(isNaN(pid) ? null : pid);\n        }\n      });\n    });\n  }\n\n  /**\n   * 终止占用端口的进程\n   */\n  async killProcess(pid) {\n    return new Promise((resolve) => {\n      const command = this.platform === 'win32'\n        ? `taskkill /PID ${pid} /F`\n        : `kill -9 ${pid}`;\n\n      exec(command, (error) => {\n        resolve(!error);\n      });\n    });\n  }\n\n  /**\n   * 检查并处理端口冲突\n   */\n  async handlePortConflict(serviceName, port) {\n    const isInUse = await this.checkPortInUse(port);\n\n    if (!isInUse) {\n      console.log(`✅ 端口 ${port} (${serviceName}) 可用`);\n      return true;\n    }\n\n    console.log(`⚠️ 端口 ${port} (${serviceName}) 被占用`);\n\n    if (!this.config.rules.killConflictingProcesses) {\n      console.log(`❌ 端口冲突处理已禁用，请手动处理端口 ${port} 的冲突`);\n      return false;\n    }\n\n    const pid = await this.getPortProcessId(port);\n    if (!pid) {\n      console.log(`❌ 无法获取占用端口 ${port} 的进程ID`);\n      return false;\n    }\n\n    console.log(`🔄 正在终止进程 ${pid} (占用端口 ${port})...`);\n    const killed = await this.killProcess(pid);\n\n    if (killed) {\n      console.log(`✅ 成功终止进程 ${pid}，端口 ${port} 现在可用`);\n      // 等待一秒确保端口释放\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      return true;\n    } else {\n      console.log(`❌ 无法终止进程 ${pid}`);\n      return false;\n    }\n  }\n\n  /**\n   * 验证所有端口\n   */\n  async validateAllPorts() {\n    console.log('🔍 检查端口配置...\\n');\n\n    const results = {};\n\n    for (const [serviceName, serviceConfig] of Object.entries(this.config.services)) {\n      const port = serviceConfig.port;\n      console.log(`📍 检查 ${serviceConfig.name} (端口 ${port})...`);\n\n      const available = await this.handlePortConflict(serviceName, port);\n      results[serviceName] = {\n        port,\n        available,\n        config: serviceConfig\n      };\n\n      console.log('');\n    }\n\n    return results;\n  }\n\n  /**\n   * 启动服务\n   */\n  async startService(serviceName) {\n    const serviceConfig = this.config.services[serviceName];\n    if (!serviceConfig) {\n      console.error(`❌ 未找到服务配置: ${serviceName}`);\n      return false;\n    }\n\n    console.log(`🚀 启动 ${serviceConfig.name}...`);\n\n    // 检查端口\n    const available = await this.handlePortConflict(serviceName, serviceConfig.port);\n    if (!available) {\n      console.error(`❌ 端口 ${serviceConfig.port} 不可用，无法启动 ${serviceConfig.name}`);\n      return false;\n    }\n\n    // 启动服务\n    const cwd = path.join(__dirname, '..', serviceConfig.directory);\n    const [command, ...args] = serviceConfig.startCommand.split(' ');\n\n    console.log(`📂 工作目录: ${cwd}`);\n    console.log(`⚡ 执行命令: ${serviceConfig.startCommand}`);\n    console.log(`🌐 访问地址: ${serviceConfig.url}\\n`);\n\n    const child = spawn(command, args, {\n      cwd,\n      stdio: 'inherit',\n      shell: true\n    });\n\n    child.on('error', (error) => {\n      console.error(`❌ 启动 ${serviceConfig.name} 失败:`, error.message);\n    });\n\n    return child;\n  }\n\n  /**\n   * 显示端口状态报告\n   */\n  async showPortStatus() {\n    console.log('📊 AIMagic 项目端口状态报告');\n    console.log('='.repeat(50));\n    console.log('');\n\n    for (const [serviceName, serviceConfig] of Object.entries(this.config.services)) {\n      const port = serviceConfig.port;\n      const isInUse = await this.checkPortInUse(port);\n      const status = isInUse ? '🔴 占用' : '🟢 可用';\n\n      console.log(`${serviceConfig.name}:`);\n      console.log(`  端口: ${port}`);\n      console.log(`  状态: ${status}`);\n      console.log(`  访问: ${serviceConfig.url}`);\n      console.log('');\n    }\n  }\n\n  /**\n   * 显示帮助信息\n   */\n  showHelp() {\n    console.log('🛠️ AIMagic 端口管理工具');\n    console.log('');\n    console.log('用法:');\n    console.log('  node scripts/port-manager.js <命令> [选项]');\n    console.log('');\n    console.log('命令:');\n    console.log('  check          检查所有端口状态');\n    console.log('  validate       验证并处理端口冲突');\n    console.log('  start <服务>   启动指定服务 (client|admin|server)');\n    console.log('  status         显示端口状态报告');\n    console.log('  help           显示帮助信息');\n    console.log('');\n    console.log('示例:');\n    console.log('  node scripts/port-manager.js validate');\n    console.log('  node scripts/port-manager.js start server');\n    console.log('  node scripts/port-manager.js status');\n  }\n}\n\n// 主函数\nasync function main() {\n  const manager = new PortManager();\n  const command = process.argv[2];\n  const service = process.argv[3];\n\n  switch (command) {\n    case 'check':\n    case 'validate':\n      await manager.validateAllPorts();\n      break;\n\n    case 'start':\n      if (!service) {\n        console.error('❌ 请指定要启动的服务: client, admin, 或 server');\n        process.exit(1);\n      }\n      await manager.startService(service);\n      break;\n\n    case 'status':\n      await manager.showPortStatus();\n      break;\n\n    case 'help':\n    default:\n      manager.showHelp();\n      break;\n  }\n}\n\n// 如果直接运行此脚本\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nmodule.exports = PortManager;\n"
        }
    ]
}