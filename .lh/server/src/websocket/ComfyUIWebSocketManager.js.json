{
    "sourceFile": "server/src/websocket/ComfyUIWebSocketManager.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1752941898191,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752941972562,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -528,4 +528,195 @@\n         }\n       }\n     }\n   }\n+\n+  /**\n+   * 提交任务到ComfyUI - 参考官方post_prompt\n+   */\n+  async submitTask(prompt, clientId, extraData = {}) {\n+    const promptId = uuidv4();\n+\n+    try {\n+      // 注册任务到客户端\n+      const metadata = this.clientMetadata.get(clientId);\n+      if (metadata) {\n+        metadata.taskIds.add(promptId);\n+      }\n+\n+      // 设置任务状态\n+      this.taskStatus.set(promptId, 'queued');\n+\n+      console.log(`📤 提交任务到ComfyUI: ${promptId}`);\n+\n+      // 构建请求体 - 参考官方标准格式\n+      const requestBody = {\n+        prompt_id: promptId,\n+        prompt: prompt,\n+        client_id: clientId,\n+        extra_data: extraData\n+      };\n+\n+      const response = await fetch(`${this.comfyUIServerUrl}/prompt`, {\n+        method: 'POST',\n+        headers: {\n+          'Content-Type': 'application/json'\n+        },\n+        body: JSON.stringify(requestBody)\n+      });\n+\n+      if (!response.ok) {\n+        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n+      }\n+\n+      const result = await response.json();\n+      console.log(`✅ 任务提交成功: ${promptId}`);\n+\n+      return {\n+        promptId,\n+        status: 'submitted',\n+        result\n+      };\n+\n+    } catch (error) {\n+      console.error(`❌ 提交任务失败: ${promptId}`, error);\n+      this.taskStatus.set(promptId, 'error');\n+\n+      // 清理任务注册\n+      const metadata = this.clientMetadata.get(clientId);\n+      if (metadata) {\n+        metadata.taskIds.delete(promptId);\n+      }\n+\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 获取任务结果\n+   */\n+  getTaskResult(promptId) {\n+    return {\n+      status: this.taskStatus.get(promptId) || 'unknown',\n+      result: this.taskResults.get(promptId) || null,\n+      history: this.taskHistory.get(promptId) || null\n+    };\n+  }\n+\n+  /**\n+   * 获取队列信息 - 参考官方get_queue_info\n+   */\n+  getQueueInfo() {\n+    const queueRemaining = Array.from(this.taskStatus.values())\n+      .filter(status => status === 'queued' || status === 'executing').length;\n+\n+    const activeTasks = Array.from(this.taskStatus.values())\n+      .filter(status => status === 'executing').length;\n+\n+    return {\n+      exec_info: {\n+        queue_remaining: queueRemaining\n+      },\n+      active_tasks: activeTasks,\n+      total_clients: this.clientSockets.size\n+    };\n+  }\n+\n+  /**\n+   * 重连调度\n+   */\n+  scheduleReconnect() {\n+    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n+      console.error(`❌ 达到最大重连次数 (${this.maxReconnectAttempts})，停止重连`);\n+      this.emit('max_reconnect_attempts_reached');\n+      return;\n+    }\n+\n+    this.reconnectAttempts++;\n+    const delay = this.reconnectInterval * this.reconnectAttempts;\n+\n+    console.log(`🔄 计划重连 ComfyUI (${this.reconnectAttempts}/${this.maxReconnectAttempts}) 延迟: ${delay}ms`);\n+\n+    setTimeout(() => {\n+      if (this.comfyUIServerUrl) {\n+        this.initComfyUIConnection(this.comfyUIServerUrl).catch(error => {\n+          console.error('❌ 重连失败:', error);\n+        });\n+      }\n+    }, delay);\n+  }\n+\n+  /**\n+   * 清理过期任务\n+   */\n+  cleanupExpiredTasks(maxAge = 3600000) { // 1小时\n+    const now = Date.now();\n+    const expiredTasks = [];\n+\n+    for (const [promptId, status] of this.taskStatus) {\n+      // 检查任务是否过期（简单实现，可以根据需要改进）\n+      if (status === 'completed' || status === 'error') {\n+        // 这里可以添加更复杂的过期逻辑\n+        // 暂时保留所有已完成的任务结果\n+      }\n+    }\n+\n+    // 清理过期的客户端连接\n+    for (const [clientId, metadata] of this.clientMetadata) {\n+      if (now - metadata.lastActivity > maxAge) {\n+        console.log(`🧹 清理过期客户端: ${clientId}`);\n+        this.removeClient(clientId);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * 获取统计信息\n+   */\n+  getStats() {\n+    const taskStatusCounts = {};\n+    for (const status of this.taskStatus.values()) {\n+      taskStatusCounts[status] = (taskStatusCounts[status] || 0) + 1;\n+    }\n+\n+    return {\n+      comfyui_connected: this.comfyUIConnection && this.comfyUIConnection.readyState === WebSocket.OPEN,\n+      clients_connected: this.clientSockets.size,\n+      tasks_total: this.taskStatus.size,\n+      tasks_by_status: taskStatusCounts,\n+      reconnect_attempts: this.reconnectAttempts,\n+      current_executing: this.currentExecutingPromptId,\n+      last_node: this.lastNodeId\n+    };\n+  }\n+\n+  /**\n+   * 关闭管理器\n+   */\n+  async close() {\n+    console.log('🛑 关闭ComfyUI WebSocket管理器...');\n+\n+    // 关闭ComfyUI连接\n+    if (this.comfyUIConnection) {\n+      this.comfyUIConnection.close();\n+      this.comfyUIConnection = null;\n+    }\n+\n+    // 关闭所有客户端连接\n+    for (const [clientId, ws] of this.clientSockets) {\n+      if (ws.readyState === WebSocket.OPEN) {\n+        ws.close(1000, '服务器关闭');\n+      }\n+    }\n+\n+    // 清理数据\n+    this.clientSockets.clear();\n+    this.clientMetadata.clear();\n+    this.taskResults.clear();\n+    this.taskStatus.clear();\n+    this.taskHistory.clear();\n+\n+    console.log('✅ ComfyUI WebSocket管理器已关闭');\n+  }\n+}\n+\n+module.exports = ComfyUIWebSocketManager;\n"
                }
            ],
            "date": 1752941898191,
            "name": "Commit-0",
            "content": "const WebSocket = require('ws');\nconst EventEmitter = require('events');\nconst { v4: uuidv4 } = require('uuid');\nconst fetch = require('node-fetch');\n\n/**\n * ComfyUI WebSocket管理器 - 基于官方server.py的PromptServer类\n * 参考: server/server.py 第147-976行\n */\nclass ComfyUIWebSocketManager extends EventEmitter {\n  constructor() {\n    super();\n\n    // 核心连接管理 - 参考官方PromptServer.__init__\n    this.comfyUIConnection = null;\n    this.comfyUIServerUrl = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectInterval = 5000;\n\n    // 客户端连接管理 - 参考官方sockets和sockets_metadata\n    this.clientSockets = new Map(); // 存储客户端WebSocket连接\n    this.clientMetadata = new Map(); // 存储客户端元数据\n\n    // 任务状态管理 - 参考官方消息处理机制\n    this.taskResults = new Map(); // 缓存任务结果\n    this.taskStatus = new Map(); // 任务状态跟踪\n    this.taskHistory = new Map(); // 任务历史记录缓存\n\n    // 执行状态跟踪 - 参考官方client_id和last_node_id\n    this.currentExecutingClient = null;\n    this.currentExecutingPromptId = null;\n    this.lastNodeId = null;\n\n    // 消息队列 - 参考官方messages队列\n    this.messageQueue = [];\n    this.isProcessingMessages = false;\n\n    console.log('🚀 ComfyUI WebSocket管理器初始化完成');\n  }\n\n  /**\n   * 初始化到ComfyUI的连接\n   * 参考: server.py websocket_handler方法\n   */\n  async initComfyUIConnection(comfyUIUrl) {\n    this.comfyUIServerUrl = comfyUIUrl;\n\n    try {\n      // 构建WebSocket URL\n      const wsUrl = comfyUIUrl.replace('http://', 'ws://').replace('https://', 'wss://') + '/ws';\n      console.log(`🔌 连接到ComfyUI服务器: ${wsUrl}`);\n\n      this.comfyUIConnection = new WebSocket(wsUrl);\n\n      this.comfyUIConnection.on('open', () => {\n        console.log('✅ 已连接到ComfyUI服务器');\n        this.reconnectAttempts = 0;\n        this.emit('comfyui_connected');\n      });\n\n      this.comfyUIConnection.on('message', (data) => {\n        this.handleComfyUIMessage(data);\n      });\n\n      this.comfyUIConnection.on('error', (error) => {\n        console.error('❌ ComfyUI连接错误:', error);\n        this.emit('comfyui_error', error);\n        this.scheduleReconnect();\n      });\n\n      this.comfyUIConnection.on('close', (code, reason) => {\n        console.log(`⚠️ ComfyUI连接断开 (${code}): ${reason}`);\n        this.emit('comfyui_disconnected', { code, reason });\n        this.scheduleReconnect();\n      });\n\n      return new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('ComfyUI连接超时'));\n        }, 10000);\n\n        this.comfyUIConnection.once('open', () => {\n          clearTimeout(timeout);\n          resolve();\n        });\n\n        this.comfyUIConnection.once('error', (error) => {\n          clearTimeout(timeout);\n          reject(error);\n        });\n      });\n\n    } catch (error) {\n      console.error('❌ 初始化ComfyUI连接失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 处理ComfyUI消息 - 参考官方消息处理逻辑\n   * 参考: server.py handleExecutingMessage等方法\n   */\n  handleComfyUIMessage(data) {\n    try {\n      // 处理二进制消息（预览图像）- 参考官方二进制消息处理\n      if (data instanceof Buffer) {\n        this.handleBinaryMessage(data);\n        return;\n      }\n\n      // 处理JSON消息\n      const message = JSON.parse(data);\n      console.log(`📨 收到ComfyUI消息: ${message.type}`);\n\n      switch (message.type) {\n        case 'status':\n          this.handleStatusMessage(message.data);\n          break;\n        case 'progress':\n          this.handleProgressMessage(message.data);\n          break;\n        case 'executing':\n          this.handleExecutingMessage(message.data);\n          break;\n        case 'executed':\n          this.handleExecutedMessage(message.data);\n          break;\n        case 'execution_start':\n          this.handleExecutionStartMessage(message.data);\n          break;\n        case 'execution_error':\n          this.handleExecutionErrorMessage(message.data);\n          break;\n        default:\n          // 转发其他消息给所有客户端\n          this.broadcastToClients(message);\n      }\n    } catch (error) {\n      console.error('❌ 处理ComfyUI消息失败:', error);\n    }\n  }\n\n  /**\n   * 处理执行状态消息 - 核心任务完成检测\n   * 参考: websockets_api_example.py 第37-40行的标准实现\n   */\n  handleExecutingMessage(data) {\n    if (!data || !data.prompt_id) {\n      return;\n    }\n\n    const { node, prompt_id } = data;\n    console.log(`🎯 执行状态更新: prompt_id=${prompt_id}, node=${node}`);\n\n    // 更新执行状态\n    this.lastNodeId = node;\n    this.currentExecutingPromptId = prompt_id;\n\n    // 官方标准任务完成检测: if data['node'] is None and data['prompt_id'] == prompt_id:\n    if (node === null) {\n      console.log(`🎉 任务执行完成: ${prompt_id}`);\n      this.handleTaskCompletion(prompt_id);\n    } else {\n      // 任务仍在执行中，更新进度\n      this.updateTaskProgress(prompt_id, node);\n    }\n\n    // 转发执行状态给对应的客户端\n    this.sendToTaskClient(prompt_id, {\n      type: 'executing',\n      data: { node, prompt_id }\n    });\n  }\n\n  /**\n   * 处理任务完成 - 参考官方标准流程\n   * 参考: websockets_api_example.py 第47-56行\n   */\n  async handleTaskCompletion(promptId) {\n    try {\n      console.log(`🔍 开始处理任务完成: ${promptId}`);\n\n      // 更新任务状态\n      this.taskStatus.set(promptId, 'completed');\n\n      // 官方标准：立即获取任务历史记录\n      const history = await this.getTaskHistory(promptId);\n\n      if (history && history[promptId]) {\n        // 官方标准：提取结果数据\n        const results = await this.extractTaskResults(history[promptId], promptId);\n\n        // 缓存结果\n        this.taskResults.set(promptId, results);\n        this.taskHistory.set(promptId, history[promptId]);\n\n        console.log(`✅ 任务完成处理成功: ${promptId}`);\n\n        // 通知客户端任务完成\n        this.sendToTaskClient(promptId, {\n          type: 'task_completed',\n          data: {\n            prompt_id: promptId,\n            results,\n            status: 'completed'\n          }\n        });\n      } else {\n        console.error(`❌ 获取任务历史失败: ${promptId}`);\n        this.taskStatus.set(promptId, 'error');\n\n        this.sendToTaskClient(promptId, {\n          type: 'task_error',\n          data: {\n            prompt_id: promptId,\n            error: '获取任务历史失败',\n            status: 'error'\n          }\n        });\n      }\n\n      // 清理执行状态\n      if (this.currentExecutingPromptId === promptId) {\n        this.currentExecutingPromptId = null;\n        this.lastNodeId = null;\n      }\n\n    } catch (error) {\n      console.error(`❌ 处理任务完成失败: ${promptId}`, error);\n      this.taskStatus.set(promptId, 'error');\n\n      this.sendToTaskClient(promptId, {\n        type: 'task_error',\n        data: {\n          prompt_id: promptId,\n          error: error.message,\n          status: 'error'\n        }\n      });\n    }\n  }\n\n  /**\n   * 获取任务历史记录 - 官方标准API调用\n   * 参考: websockets_api_example.py get_history函数\n   */\n  async getTaskHistory(promptId) {\n    try {\n      const historyUrl = `${this.comfyUIServerUrl}/history/${promptId}`;\n      console.log(`📡 获取任务历史: ${historyUrl}`);\n\n      const response = await fetch(historyUrl);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const history = await response.json();\n      console.log(`📊 历史记录获取成功: ${promptId}`);\n      return history;\n\n    } catch (error) {\n      console.error(`❌ 获取任务历史失败: ${promptId}`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * 提取任务结果 - 官方标准结果提取\n   * 参考: websockets_api_example.py 第48-56行\n   */\n  async extractTaskResults(history, promptId) {\n    try {\n      const outputImages = {};\n\n      // 官方标准：for node_id in history['outputs']:\n      if (history.outputs) {\n        for (const nodeId in history.outputs) {\n          const nodeOutput = history.outputs[nodeId];\n          const imagesOutput = [];\n\n          // 官方标准：if 'images' in node_output:\n          if (nodeOutput.images) {\n            for (const image of nodeOutput.images) {\n              // 构建图片URL而不是下载数据\n              const imageUrl = `${this.comfyUIServerUrl}/view?filename=${image.filename}&subfolder=${image.subfolder}&type=${image.type}`;\n              imagesOutput.push({\n                filename: image.filename,\n                subfolder: image.subfolder,\n                type: image.type,\n                url: imageUrl\n              });\n            }\n          }\n\n          outputImages[nodeId] = imagesOutput;\n        }\n      }\n\n      console.log(`🎨 结果提取完成: ${promptId}, 节点数: ${Object.keys(outputImages).length}`);\n      return outputImages;\n\n    } catch (error) {\n      console.error(`❌ 提取任务结果失败: ${promptId}`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * 处理进度消息\n   */\n  handleProgressMessage(data) {\n    if (!data || !data.prompt_id) {\n      return;\n    }\n\n    const { prompt_id, value, max } = data;\n    const progress = max > 0 ? Math.round((value / max) * 100) : 0;\n\n    console.log(`📊 任务进度更新: ${prompt_id} - ${progress}%`);\n\n    // 转发进度给对应的客户端\n    this.sendToTaskClient(prompt_id, {\n      type: 'progress',\n      data: { prompt_id, progress, value, max }\n    });\n  }\n\n  /**\n   * 处理状态消息\n   */\n  handleStatusMessage(data) {\n    console.log('📋 状态更新:', data);\n\n    // 广播状态给所有客户端\n    this.broadcastToClients({\n      type: 'status',\n      data\n    });\n  }\n\n  /**\n   * 处理执行开始消息\n   */\n  handleExecutionStartMessage(data) {\n    if (!data || !data.prompt_id) {\n      return;\n    }\n\n    const { prompt_id } = data;\n    console.log(`🚀 任务开始执行: ${prompt_id}`);\n\n    this.taskStatus.set(prompt_id, 'executing');\n\n    // 通知对应的客户端\n    this.sendToTaskClient(prompt_id, {\n      type: 'execution_start',\n      data\n    });\n  }\n\n  /**\n   * 处理执行错误消息\n   */\n  handleExecutionErrorMessage(data) {\n    if (!data || !data.prompt_id) {\n      return;\n    }\n\n    const { prompt_id } = data;\n    console.error(`❌ 任务执行错误: ${prompt_id}`, data);\n\n    this.taskStatus.set(prompt_id, 'error');\n\n    // 通知对应的客户端\n    this.sendToTaskClient(prompt_id, {\n      type: 'execution_error',\n      data\n    });\n  }\n\n  /**\n   * 处理二进制消息（预览图像）\n   */\n  handleBinaryMessage(data) {\n    // 转发二进制消息给所有客户端\n    this.broadcastBinaryToClients(data);\n  }\n\n  /**\n   * 更新任务进度\n   */\n  updateTaskProgress(promptId, currentNode) {\n    // 可以根据节点信息计算进度\n    const progress = currentNode ? 85 : 50; // 简单的进度估算\n\n    this.sendToTaskClient(promptId, {\n      type: 'progress',\n      data: {\n        prompt_id: promptId,\n        progress,\n        current_node: currentNode,\n        status: 'executing'\n      }\n    });\n  }\n\n  /**\n   * 添加客户端连接 - 参考官方websocket_handler\n   */\n  addClient(ws, clientId = null) {\n    const sid = clientId || uuidv4();\n\n    // 如果是重用会话，移除旧连接\n    if (clientId && this.clientSockets.has(clientId)) {\n      const oldWs = this.clientSockets.get(clientId);\n      if (oldWs.readyState === WebSocket.OPEN) {\n        oldWs.close();\n      }\n    }\n\n    this.clientSockets.set(sid, ws);\n    this.clientMetadata.set(sid, {\n      connectedAt: Date.now(),\n      lastActivity: Date.now(),\n      taskIds: new Set() // 跟踪客户端的任务\n    });\n\n    console.log(`🔗 客户端连接: ${sid}`);\n\n    // 发送初始状态 - 参考官方send initial state\n    this.sendToClient(sid, {\n      type: 'status',\n      data: {\n        status: this.getQueueInfo(),\n        sid: sid\n      }\n    });\n\n    // 如果有正在执行的任务且是该客户端的任务，发送当前状态\n    if (this.currentExecutingPromptId && this.lastNodeId) {\n      const metadata = this.clientMetadata.get(sid);\n      if (metadata && metadata.taskIds.has(this.currentExecutingPromptId)) {\n        this.sendToClient(sid, {\n          type: 'executing',\n          data: {\n            node: this.lastNodeId,\n            prompt_id: this.currentExecutingPromptId\n          }\n        });\n      }\n    }\n\n    return sid;\n  }\n\n  /**\n   * 移除客户端连接\n   */\n  removeClient(clientId) {\n    console.log(`🔌 客户端断开: ${clientId}`);\n\n    this.clientSockets.delete(clientId);\n    this.clientMetadata.delete(clientId);\n  }\n\n  /**\n   * 发送消息给特定客户端 - 参考官方send_json\n   */\n  sendToClient(clientId, message) {\n    const ws = this.clientSockets.get(clientId);\n    if (ws && ws.readyState === WebSocket.OPEN) {\n      try {\n        ws.send(JSON.stringify(message));\n\n        // 更新最后活动时间\n        const metadata = this.clientMetadata.get(clientId);\n        if (metadata) {\n          metadata.lastActivity = Date.now();\n        }\n      } catch (error) {\n        console.error(`❌ 发送消息给客户端 ${clientId} 失败:`, error);\n        this.removeClient(clientId);\n      }\n    }\n  }\n\n  /**\n   * 发送消息给任务对应的客户端\n   */\n  sendToTaskClient(promptId, message) {\n    // 查找拥有该任务的客户端\n    for (const [clientId, metadata] of this.clientMetadata) {\n      if (metadata.taskIds && metadata.taskIds.has(promptId)) {\n        this.sendToClient(clientId, message);\n        break;\n      }\n    }\n  }\n\n  /**\n   * 广播消息给所有客户端 - 参考官方广播机制\n   */\n  broadcastToClients(message) {\n    for (const [clientId, ws] of this.clientSockets) {\n      if (ws.readyState === WebSocket.OPEN) {\n        try {\n          ws.send(JSON.stringify(message));\n        } catch (error) {\n          console.error(`❌ 广播消息给客户端 ${clientId} 失败:`, error);\n          this.removeClient(clientId);\n        }\n      }\n    }\n  }\n\n  /**\n   * 广播二进制消息给所有客户端\n   */\n  broadcastBinaryToClients(data) {\n    for (const [clientId, ws] of this.clientSockets) {\n      if (ws.readyState === WebSocket.OPEN) {\n        try {\n          ws.send(data);\n        } catch (error) {\n          console.error(`❌ 广播二进制消息给客户端 ${clientId} 失败:`, error);\n          this.removeClient(clientId);\n        }\n      }\n    }\n  }\n"
        }
    ]
}