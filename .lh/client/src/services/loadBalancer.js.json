{
    "sourceFile": "client/src/services/loadBalancer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 10,
            "patches": [
                {
                    "date": 1752333548051,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752333570869,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -317,18 +317,36 @@\n       console.log(`🆘 备用服务器: ${fallbackServer}`)\n       return fallbackServer\n     }\n \n-    // 如果没有配置的服务器，使用配置服务的默认值\n-    const config = await configService.getConfig()\n-    const defaultServer = config['comfyui.server_url']\n+    // 如果没有配置的服务器，尝试多种方式获取默认值\n+    try {\n+      const config = await configService.getConfig()\n+      const defaultServer = config['comfyui.server_url']\n \n-    if (defaultServer) {\n-      console.log(`🆘 默认服务器: ${defaultServer}`)\n-      return defaultServer\n+      if (defaultServer && defaultServer !== 'https://your-comfyui-server.com') {\n+        console.log(`🆘 配置服务默认服务器: ${defaultServer}`)\n+        return defaultServer\n+      }\n+    } catch (error) {\n+      console.warn('⚠️ 无法从配置服务获取默认服务器:', error)\n     }\n \n-    throw new Error('没有可用的 ComfyUI 服务器')\n+    // 从本地存储获取\n+    try {\n+      const localConfig = JSON.parse(localStorage.getItem('comfyui_config') || '{}')\n+      if (localConfig.COMFYUI_SERVER_URL) {\n+        console.log(`🆘 本地配置服务器: ${localConfig.COMFYUI_SERVER_URL}`)\n+        return localConfig.COMFYUI_SERVER_URL\n+      }\n+    } catch (error) {\n+      console.warn('⚠️ 无法从本地存储获取服务器配置:', error)\n+    }\n+\n+    // 最后的备用方案\n+    const fallbackUrl = 'https://your-comfyui-server.com'\n+    console.log(`🆘 使用最后备用服务器: ${fallbackUrl}`)\n+    return fallbackUrl\n   }\n \n   /**\n    * 锁定服务器\n"
                },
                {
                    "date": 1752411161286,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,12 +11,13 @@\n     this.serverLoads = new Map()\n     this.lockedServer = null\n     this.lastLockTime = 0\n     this.lockDuration = 30000 // 30秒锁定时间\n-    this.healthCheckTimeout = 10000 // 10秒健康检查超时\n-    this.queueCheckTimeout = 5000 // 5秒队列检查超时\n+    this.healthCheckTimeout = 15000 // 15秒健康检查超时\n+    this.queueCheckTimeout = 8000 // 8秒队列检查超时\n     this.lastUpdateTime = 0\n-    this.updateInterval = 15000 // 15秒更新间隔\n+    this.updateInterval = 10000 // 10秒更新间隔（更频繁的更新）\n+    this.forceUpdateThreshold = 30000 // 30秒强制更新阈值\n   }\n \n   /**\n    * 初始化负载均衡器\n"
                },
                {
                    "date": 1752411179957,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,17 +90,23 @@\n \n   /**\n    * 更新所有服务器的负载信息\n    */\n-  async updateServerLoads() {\n+  async updateServerLoads(forceUpdate = false) {\n     const now = Date.now()\n \n-    // 如果距离上次更新时间不足间隔，跳过更新\n-    if (now - this.lastUpdateTime < this.updateInterval) {\n+    // 如果距离上次更新时间不足间隔，跳过更新（除非强制更新或超过强制更新阈值）\n+    if (!forceUpdate && now - this.lastUpdateTime < this.updateInterval && now - this.lastUpdateTime < this.forceUpdateThreshold) {\n       console.log('⏭️ 跳过负载更新，距离上次更新时间不足')\n       return\n     }\n \n+    // 如果超过强制更新阈值，强制更新\n+    if (now - this.lastUpdateTime > this.forceUpdateThreshold) {\n+      console.log('🔄 强制更新服务器负载信息（超过强制更新阈值）')\n+      forceUpdate = true\n+    }\n+\n     console.log('🔄 更新服务器负载信息...')\n \n     const updatePromises = this.servers.map(async (server) => {\n       try {\n"
                },
                {
                    "date": 1752411196288,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,14 +118,18 @@\n \n         const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n         const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n \n+        // 更智能的健康状态判断\n+        const isHealthy = this.determineServerHealth(health, queue, server)\n+\n         this.serverLoads.set(server.url, {\n           ...server,\n-          healthy: health.healthy && queue.healthy,\n+          healthy: isHealthy,\n           queue: queue,\n           lastCheck: now,\n-          responseTime: health.responseTime || 0\n+          responseTime: health.responseTime || 0,\n+          healthDetails: { health, queue }\n         })\n \n         console.log(`📊 ${server.url}: 健康=${health.healthy}, 队列=${queue.total || 0}`)\n \n"
                },
                {
                    "date": 1752411215875,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -151,8 +151,33 @@\n     console.log('✅ 服务器负载信息更新完成')\n   }\n \n   /**\n+   * 更智能的服务器健康状态判断\n+   */\n+  determineServerHealth(health, queue, server) {\n+    // 如果健康检查完全失败，标记为不健康\n+    if (!health.healthy) {\n+      return false\n+    }\n+\n+    // 如果队列检查失败但健康检查通过，仍然认为服务器可用\n+    // 这样可以避免因为队列API不可用而错误地标记服务器为不健康\n+    if (!queue.healthy) {\n+      console.log(`⚠️ 服务器 ${server.url} 队列检查失败，但健康检查通过，仍标记为可用`)\n+      return true\n+    }\n+\n+    // 如果队列过长（超过10个任务），降低优先级但不标记为不健康\n+    if (queue.total > 10) {\n+      console.log(`⚠️ 服务器 ${server.url} 队列较长 (${queue.total})，但仍可用`)\n+      return true\n+    }\n+\n+    return true\n+  }\n+\n+  /**\n    * 检查服务器健康状态\n    */\n   async checkServerHealth(serverUrl) {\n     try {\n"
                },
                {
                    "date": 1752411238444,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -306,13 +306,13 @@\n           return lockedServer\n         }\n       }\n \n-      // 更新服务器负载信息\n+      // 更新服务器负载信息（如果没有健康服务器，强制更新）\n       await this.updateServerLoads()\n \n       // 获取所有健康的服务器\n-      const healthyServers = Array.from(this.serverLoads.values())\n+      let healthyServers = Array.from(this.serverLoads.values())\n         .filter(server => server.healthy)\n         .sort((a, b) => {\n           // 首先按队列数量排序\n           const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n@@ -321,10 +321,24 @@\n           // 队列相同时按优先级排序\n           return a.priority - b.priority\n         })\n \n+      // 如果没有健康服务器，强制更新一次再试\n       if (healthyServers.length === 0) {\n-        console.warn('⚠️ 没有健康的服务器可用')\n+        console.warn('⚠️ 没有健康的服务器可用，强制更新后重试...')\n+        await this.updateServerLoads(true) // 强制更新\n+\n+        healthyServers = Array.from(this.serverLoads.values())\n+          .filter(server => server.healthy)\n+          .sort((a, b) => {\n+            const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n+            if (queueDiff !== 0) return queueDiff\n+            return a.priority - b.priority\n+          })\n+      }\n+\n+      if (healthyServers.length === 0) {\n+        console.warn('⚠️ 强制更新后仍没有健康的服务器可用')\n         return await this.fallbackToAnyServer()\n       }\n \n       const selectedServer = healthyServers[0]\n"
                },
                {
                    "date": 1752411258535,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -360,9 +360,23 @@\n    */\n   async fallbackToAnyServer() {\n     console.log('🔄 使用备用服务器选择策略...')\n \n-    // 按优先级返回第一个服务器\n+    // 尝试选择响应时间最快的服务器（即使队列较长）\n+    const serversWithResponse = Array.from(this.serverLoads.values())\n+      .filter(server => server.responseTime > 0) // 至少有响应\n+      .sort((a, b) => {\n+        // 按响应时间排序\n+        return a.responseTime - b.responseTime\n+      })\n+\n+    if (serversWithResponse.length > 0) {\n+      const fastestServer = serversWithResponse[0]\n+      console.log(`🆘 选择响应最快的服务器: ${fastestServer.url} (响应时间: ${fastestServer.responseTime}ms, 队列: ${fastestServer.queue.total || 0})`)\n+      return fastestServer.url\n+    }\n+\n+    // 如果没有响应数据，按优先级返回第一个服务器\n     if (this.servers.length > 0) {\n       const fallbackServer = this.servers[0].url\n       console.log(`🆘 备用服务器: ${fallbackServer}`)\n       return fallbackServer\n"
                },
                {
                    "date": 1752411277869,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -130,9 +130,10 @@\n           responseTime: health.responseTime || 0,\n           healthDetails: { health, queue }\n         })\n \n-        console.log(`📊 ${server.url}: 健康=${health.healthy}, 队列=${queue.total || 0}`)\n+        const queueInfo = queue.healthy ? `队列=${queue.total || 0}(运行:${queue.running || 0},等待:${queue.pending || 0})` : `队列检查失败`\n+        console.log(`📊 ${server.url}: 健康=${health.healthy}, ${queueInfo}, 响应时间=${health.responseTime || 0}ms`)\n \n       } catch (error) {\n         console.error(`❌ 更新服务器负载失败 ${server.url}:`, error)\n         this.serverLoads.set(server.url, {\n"
                },
                {
                    "date": 1752411297072,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -491,12 +491,16 @@\n   logServerStatus() {\n     console.log('📊 当前所有服务器状态:')\n     for (const [url, info] of this.serverLoads.entries()) {\n       const status = info.healthy ? '✅' : '❌'\n-      const queue = info.healthy ? `队列:${info.queue.total || 0}` : '不健康'\n+      const queueInfo = info.queue ?\n+        `队列:${info.queue.total || 0}(运行:${info.queue.running || 0},等待:${info.queue.pending || 0})` :\n+        '队列:未知'\n       const locked = url === this.lockedServer ? '🔒' : ''\n       const priority = `优先级:${info.priority}`\n-      console.log(`   ${status} ${url} ${queue} ${priority} ${locked}`)\n+      const responseTime = info.responseTime ? `响应:${info.responseTime}ms` : '响应:未知'\n+      const lastCheck = info.lastCheck ? `检查:${Math.round((Date.now() - info.lastCheck) / 1000)}s前` : '检查:从未'\n+      console.log(`   ${status} ${url} ${queueInfo} ${priority} ${responseTime} ${lastCheck} ${locked}`)\n     }\n   }\n \n   /**\n"
                },
                {
                    "date": 1752411316946,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -485,8 +485,27 @@\n     return await this.selectServerByMinQueue()\n   }\n \n   /**\n+   * 强制重新评估所有服务器\n+   */\n+  async forceReassessment() {\n+    console.log('🔄 强制重新评估所有服务器...')\n+\n+    // 清除锁定状态\n+    this.lockedServer = null\n+    this.lastLockTime = 0\n+\n+    // 强制更新负载信息\n+    await this.updateServerLoads(true)\n+\n+    // 显示当前状态\n+    this.logServerStatus()\n+\n+    console.log('✅ 服务器重新评估完成')\n+  }\n+\n+  /**\n    * 显示服务器状态\n    */\n   logServerStatus() {\n     console.log('📊 当前所有服务器状态:')\n"
                }
            ],
            "date": 1752333548051,
            "name": "Commit-0",
            "content": "// ComfyUI 负载均衡器 - 基于任务队列的智能选择\nimport configService from './configService.js'\n\n/**\n * ComfyUI 负载均衡器\n * 根据服务器任务队列情况选择最优服务器\n */\nclass ComfyUILoadBalancer {\n  constructor() {\n    this.servers = []\n    this.serverLoads = new Map()\n    this.lockedServer = null\n    this.lastLockTime = 0\n    this.lockDuration = 30000 // 30秒锁定时间\n    this.healthCheckTimeout = 10000 // 10秒健康检查超时\n    this.queueCheckTimeout = 5000 // 5秒队列检查超时\n    this.lastUpdateTime = 0\n    this.updateInterval = 15000 // 15秒更新间隔\n  }\n\n  /**\n   * 初始化负载均衡器\n   */\n  async initialize() {\n    try {\n      console.log('🚀 初始化 ComfyUI 负载均衡器...')\n\n      // 获取服务器配置\n      const config = await configService.getConfig()\n\n      // 构建服务器列表\n      this.servers = []\n\n      // 主服务器\n      if (config['comfyui.server_url']) {\n        this.servers.push({\n          url: config['comfyui.server_url'],\n          type: 'primary',\n          priority: 1\n        })\n      }\n\n      // 备用服务器\n      if (config['comfyui.backup_servers']) {\n        const backupServers = config['comfyui.backup_servers']\n          .split('\\n')\n          .map(url => url.trim())\n          .filter(url => url && url.startsWith('http'))\n\n        backupServers.forEach((url, index) => {\n          this.servers.push({\n            url,\n            type: 'backup',\n            priority: index + 2\n          })\n        })\n      }\n\n      // 如果没有配置服务器，使用默认配置\n      if (this.servers.length === 0) {\n        console.warn('⚠️ 未找到配置的服务器，使用默认配置')\n        // 从本地配置获取默认服务器\n        const localConfig = JSON.parse(localStorage.getItem('comfyui_config') || '{}')\n        const defaultUrl = localConfig.COMFYUI_SERVER_URL || 'https://your-comfyui-server.com'\n\n        this.servers.push({\n          url: defaultUrl,\n          type: 'primary',\n          priority: 1\n        })\n      }\n\n      console.log(`✅ 发现 ${this.servers.length} 个 ComfyUI 服务器:`)\n      this.servers.forEach((server, index) => {\n        console.log(`   ${index + 1}. ${server.url} (${server.type})`)\n      })\n\n      // 初始化服务器负载信息\n      await this.updateServerLoads()\n\n      console.log('✅ ComfyUI 负载均衡器初始化完成')\n\n    } catch (error) {\n      console.error('❌ 负载均衡器初始化失败:', error)\n      // 不抛出错误，允许应用继续运行\n      console.log('🔄 使用降级模式，将使用单服务器配置')\n    }\n  }\n\n  /**\n   * 更新所有服务器的负载信息\n   */\n  async updateServerLoads() {\n    const now = Date.now()\n\n    // 如果距离上次更新时间不足间隔，跳过更新\n    if (now - this.lastUpdateTime < this.updateInterval) {\n      console.log('⏭️ 跳过负载更新，距离上次更新时间不足')\n      return\n    }\n\n    console.log('🔄 更新服务器负载信息...')\n\n    const updatePromises = this.servers.map(async (server) => {\n      try {\n        // 并行检查健康状态和队列信息\n        const [healthResult, queueResult] = await Promise.allSettled([\n          this.checkServerHealth(server.url),\n          this.getServerQueueInfo(server.url)\n        ])\n\n        const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n        const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n\n        this.serverLoads.set(server.url, {\n          ...server,\n          healthy: health.healthy && queue.healthy,\n          queue: queue,\n          lastCheck: now,\n          responseTime: health.responseTime || 0\n        })\n\n        console.log(`📊 ${server.url}: 健康=${health.healthy}, 队列=${queue.total || 0}`)\n\n      } catch (error) {\n        console.error(`❌ 更新服务器负载失败 ${server.url}:`, error)\n        this.serverLoads.set(server.url, {\n          ...server,\n          healthy: false,\n          queue: { total: 999, healthy: false },\n          lastCheck: now,\n          error: error.message\n        })\n      }\n    })\n\n    await Promise.allSettled(updatePromises)\n    this.lastUpdateTime = now\n\n    console.log('✅ 服务器负载信息更新完成')\n  }\n\n  /**\n   * 检查服务器健康状态\n   */\n  async checkServerHealth(serverUrl) {\n    try {\n      const startTime = Date.now()\n\n      const controller = new AbortController()\n      const timeoutId = setTimeout(() => controller.abort(), this.healthCheckTimeout)\n\n      const response = await fetch(`${serverUrl}/system_stats`, {\n        method: 'GET',\n        signal: controller.signal,\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      })\n\n      clearTimeout(timeoutId)\n      const responseTime = Date.now() - startTime\n\n      if (response.ok) {\n        return { healthy: true, responseTime, status: response.status }\n      } else {\n        return { healthy: false, responseTime, status: response.status }\n      }\n\n    } catch (error) {\n      console.warn(`⚠️ 健康检查失败 ${serverUrl}:`, error.message)\n      return { healthy: false, error: error.message }\n    }\n  }\n\n  /**\n   * 获取服务器队列信息\n   */\n  async getServerQueueInfo(serverUrl) {\n    try {\n      const controller = new AbortController()\n      const timeoutId = setTimeout(() => controller.abort(), this.queueCheckTimeout)\n\n      const response = await fetch(`${serverUrl}/queue`, {\n        method: 'GET',\n        signal: controller.signal,\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      })\n\n      clearTimeout(timeoutId)\n\n      if (response.ok) {\n        const queueData = await response.json()\n\n        // ComfyUI 队列 API 返回格式: { queue_running: [...], queue_pending: [...] }\n        const running = queueData.queue_running ? queueData.queue_running.length : 0\n        const pending = queueData.queue_pending ? queueData.queue_pending.length : 0\n        const total = running + pending\n\n        return {\n          running,\n          pending,\n          total,\n          healthy: true,\n          supportsQueueAPI: true\n        }\n      } else {\n        // 如果队列 API 不可用，尝试使用系统状态作为备用\n        return await this.getServerQueueInfoFallback(serverUrl)\n      }\n\n    } catch (error) {\n      console.warn(`⚠️ 队列信息获取失败 ${serverUrl}:`, error.message)\n      return await this.getServerQueueInfoFallback(serverUrl)\n    }\n  }\n\n  /**\n   * 备用队列信息获取方法\n   */\n  async getServerQueueInfoFallback(serverUrl) {\n    try {\n      const controller = new AbortController()\n      const timeoutId = setTimeout(() => controller.abort(), this.queueCheckTimeout)\n\n      const response = await fetch(`${serverUrl}/system_stats`, {\n        method: 'GET',\n        signal: controller.signal\n      })\n\n      clearTimeout(timeoutId)\n\n      if (response.ok) {\n        // 如果无法获取精确队列信息，假设服务器可用但队列未知\n        return {\n          running: 0,\n          pending: 0,\n          total: 0,\n          healthy: true,\n          supportsQueueAPI: false\n        }\n      }\n    } catch (error) {\n      // 忽略错误\n    }\n\n    return {\n      running: 0,\n      pending: 0,\n      total: 999, // 高值表示不可用\n      healthy: false,\n      supportsQueueAPI: false\n    }\n  }\n\n  /**\n   * 根据最小队列选择服务器\n   */\n  async selectServerByMinQueue() {\n    try {\n      console.log('🎯 开始选择最优服务器...')\n\n      // 检查是否有锁定的服务器\n      if (this.isServerLocked()) {\n        const lockedServer = this.getLockedServer()\n        if (lockedServer) {\n          console.log(`🔒 使用锁定的服务器: ${lockedServer}`)\n          return lockedServer\n        }\n      }\n\n      // 更新服务器负载信息\n      await this.updateServerLoads()\n\n      // 获取所有健康的服务器\n      const healthyServers = Array.from(this.serverLoads.values())\n        .filter(server => server.healthy)\n        .sort((a, b) => {\n          // 首先按队列数量排序\n          const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n          if (queueDiff !== 0) return queueDiff\n\n          // 队列相同时按优先级排序\n          return a.priority - b.priority\n        })\n\n      if (healthyServers.length === 0) {\n        console.warn('⚠️ 没有健康的服务器可用')\n        return await this.fallbackToAnyServer()\n      }\n\n      const selectedServer = healthyServers[0]\n      console.log(`✅ 选择服务器: ${selectedServer.url} (队列: ${selectedServer.queue.total || 0})`)\n\n      // 锁定选中的服务器\n      this.lockServer(selectedServer.url)\n\n      return selectedServer.url\n\n    } catch (error) {\n      console.error('❌ 服务器选择失败:', error)\n      return await this.fallbackToAnyServer()\n    }\n  }\n\n  /**\n   * 备用服务器选择\n   */\n  async fallbackToAnyServer() {\n    console.log('🔄 使用备用服务器选择策略...')\n\n    // 按优先级返回第一个服务器\n    if (this.servers.length > 0) {\n      const fallbackServer = this.servers[0].url\n      console.log(`🆘 备用服务器: ${fallbackServer}`)\n      return fallbackServer\n    }\n\n    // 如果没有配置的服务器，使用配置服务的默认值\n    const config = await configService.getConfig()\n    const defaultServer = config['comfyui.server_url']\n\n    if (defaultServer) {\n      console.log(`🆘 默认服务器: ${defaultServer}`)\n      return defaultServer\n    }\n\n    throw new Error('没有可用的 ComfyUI 服务器')\n  }\n\n  /**\n   * 锁定服务器\n   */\n  lockServer(serverUrl) {\n    this.lockedServer = serverUrl\n    this.lastLockTime = Date.now()\n    console.log(`🔒 锁定服务器: ${serverUrl}, 持续 ${this.lockDuration / 1000} 秒`)\n\n    // 显示当前所有服务器状态\n    this.logServerStatus()\n  }\n\n  /**\n   * 检查服务器是否被锁定\n   */\n  isServerLocked() {\n    if (!this.lockedServer) return false\n\n    const now = Date.now()\n    const isLocked = (now - this.lastLockTime) < this.lockDuration\n\n    if (!isLocked) {\n      console.log('🔓 服务器锁定已过期')\n      this.lockedServer = null\n      this.lastLockTime = 0\n    }\n\n    return isLocked\n  }\n\n  /**\n   * 获取锁定的服务器\n   */\n  getLockedServer() {\n    if (this.isServerLocked()) {\n      return this.lockedServer\n    }\n    return null\n  }\n\n  /**\n   * 记录服务器失败\n   */\n  async recordFailure(serverUrl) {\n    console.log(`📝 记录服务器失败: ${serverUrl}`)\n\n    // 如果失败的是当前锁定的服务器，解除锁定\n    if (this.lockedServer === serverUrl) {\n      console.log('🔓 解除失败服务器的锁定')\n      this.lockedServer = null\n      this.lastLockTime = 0\n    }\n\n    // 标记服务器为不健康\n    if (this.serverLoads.has(serverUrl)) {\n      const serverInfo = this.serverLoads.get(serverUrl)\n      serverInfo.healthy = false\n      serverInfo.lastFailure = Date.now()\n      this.serverLoads.set(serverUrl, serverInfo)\n    }\n\n    // 强制更新服务器负载信息\n    this.lastUpdateTime = 0\n  }\n\n  /**\n   * 获取最优服务器（主要接口）\n   */\n  async getOptimalServer() {\n    return await this.selectServerByMinQueue()\n  }\n\n  /**\n   * 显示服务器状态\n   */\n  logServerStatus() {\n    console.log('📊 当前所有服务器状态:')\n    for (const [url, info] of this.serverLoads.entries()) {\n      const status = info.healthy ? '✅' : '❌'\n      const queue = info.healthy ? `队列:${info.queue.total || 0}` : '不健康'\n      const locked = url === this.lockedServer ? '🔒' : ''\n      const priority = `优先级:${info.priority}`\n      console.log(`   ${status} ${url} ${queue} ${priority} ${locked}`)\n    }\n  }\n\n  /**\n   * 获取服务器统计信息\n   */\n  getServerStats() {\n    const stats = {\n      total: this.servers.length,\n      healthy: 0,\n      locked: this.lockedServer,\n      servers: []\n    }\n\n    for (const [url, info] of this.serverLoads.entries()) {\n      if (info.healthy) stats.healthy++\n\n      stats.servers.push({\n        url,\n        healthy: info.healthy,\n        queue: info.queue.total || 0,\n        priority: info.priority,\n        type: info.type,\n        locked: url === this.lockedServer\n      })\n    }\n\n    return stats\n  }\n}\n\n// 创建单例实例\nconst loadBalancer = new ComfyUILoadBalancer()\n\nexport default loadBalancer\n"
        }
    ]
}