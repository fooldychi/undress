{
    "sourceFile": "client/src/services/loadBalancer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 134,
            "patches": [
                {
                    "date": 1752333548051,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752333570869,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -317,18 +317,36 @@\n       console.log(`🆘 备用服务器: ${fallbackServer}`)\n       return fallbackServer\n     }\n \n-    // 如果没有配置的服务器，使用配置服务的默认值\n-    const config = await configService.getConfig()\n-    const defaultServer = config['comfyui.server_url']\n+    // 如果没有配置的服务器，尝试多种方式获取默认值\n+    try {\n+      const config = await configService.getConfig()\n+      const defaultServer = config['comfyui.server_url']\n \n-    if (defaultServer) {\n-      console.log(`🆘 默认服务器: ${defaultServer}`)\n-      return defaultServer\n+      if (defaultServer && defaultServer !== 'https://your-comfyui-server.com') {\n+        console.log(`🆘 配置服务默认服务器: ${defaultServer}`)\n+        return defaultServer\n+      }\n+    } catch (error) {\n+      console.warn('⚠️ 无法从配置服务获取默认服务器:', error)\n     }\n \n-    throw new Error('没有可用的 ComfyUI 服务器')\n+    // 从本地存储获取\n+    try {\n+      const localConfig = JSON.parse(localStorage.getItem('comfyui_config') || '{}')\n+      if (localConfig.COMFYUI_SERVER_URL) {\n+        console.log(`🆘 本地配置服务器: ${localConfig.COMFYUI_SERVER_URL}`)\n+        return localConfig.COMFYUI_SERVER_URL\n+      }\n+    } catch (error) {\n+      console.warn('⚠️ 无法从本地存储获取服务器配置:', error)\n+    }\n+\n+    // 最后的备用方案\n+    const fallbackUrl = 'https://your-comfyui-server.com'\n+    console.log(`🆘 使用最后备用服务器: ${fallbackUrl}`)\n+    return fallbackUrl\n   }\n \n   /**\n    * 锁定服务器\n"
                },
                {
                    "date": 1752411161286,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,12 +11,13 @@\n     this.serverLoads = new Map()\n     this.lockedServer = null\n     this.lastLockTime = 0\n     this.lockDuration = 30000 // 30秒锁定时间\n-    this.healthCheckTimeout = 10000 // 10秒健康检查超时\n-    this.queueCheckTimeout = 5000 // 5秒队列检查超时\n+    this.healthCheckTimeout = 15000 // 15秒健康检查超时\n+    this.queueCheckTimeout = 8000 // 8秒队列检查超时\n     this.lastUpdateTime = 0\n-    this.updateInterval = 15000 // 15秒更新间隔\n+    this.updateInterval = 10000 // 10秒更新间隔（更频繁的更新）\n+    this.forceUpdateThreshold = 30000 // 30秒强制更新阈值\n   }\n \n   /**\n    * 初始化负载均衡器\n"
                },
                {
                    "date": 1752411179957,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,17 +90,23 @@\n \n   /**\n    * 更新所有服务器的负载信息\n    */\n-  async updateServerLoads() {\n+  async updateServerLoads(forceUpdate = false) {\n     const now = Date.now()\n \n-    // 如果距离上次更新时间不足间隔，跳过更新\n-    if (now - this.lastUpdateTime < this.updateInterval) {\n+    // 如果距离上次更新时间不足间隔，跳过更新（除非强制更新或超过强制更新阈值）\n+    if (!forceUpdate && now - this.lastUpdateTime < this.updateInterval && now - this.lastUpdateTime < this.forceUpdateThreshold) {\n       console.log('⏭️ 跳过负载更新，距离上次更新时间不足')\n       return\n     }\n \n+    // 如果超过强制更新阈值，强制更新\n+    if (now - this.lastUpdateTime > this.forceUpdateThreshold) {\n+      console.log('🔄 强制更新服务器负载信息（超过强制更新阈值）')\n+      forceUpdate = true\n+    }\n+\n     console.log('🔄 更新服务器负载信息...')\n \n     const updatePromises = this.servers.map(async (server) => {\n       try {\n"
                },
                {
                    "date": 1752411196288,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,14 +118,18 @@\n \n         const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n         const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n \n+        // 更智能的健康状态判断\n+        const isHealthy = this.determineServerHealth(health, queue, server)\n+\n         this.serverLoads.set(server.url, {\n           ...server,\n-          healthy: health.healthy && queue.healthy,\n+          healthy: isHealthy,\n           queue: queue,\n           lastCheck: now,\n-          responseTime: health.responseTime || 0\n+          responseTime: health.responseTime || 0,\n+          healthDetails: { health, queue }\n         })\n \n         console.log(`📊 ${server.url}: 健康=${health.healthy}, 队列=${queue.total || 0}`)\n \n"
                },
                {
                    "date": 1752411215875,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -151,8 +151,33 @@\n     console.log('✅ 服务器负载信息更新完成')\n   }\n \n   /**\n+   * 更智能的服务器健康状态判断\n+   */\n+  determineServerHealth(health, queue, server) {\n+    // 如果健康检查完全失败，标记为不健康\n+    if (!health.healthy) {\n+      return false\n+    }\n+\n+    // 如果队列检查失败但健康检查通过，仍然认为服务器可用\n+    // 这样可以避免因为队列API不可用而错误地标记服务器为不健康\n+    if (!queue.healthy) {\n+      console.log(`⚠️ 服务器 ${server.url} 队列检查失败，但健康检查通过，仍标记为可用`)\n+      return true\n+    }\n+\n+    // 如果队列过长（超过10个任务），降低优先级但不标记为不健康\n+    if (queue.total > 10) {\n+      console.log(`⚠️ 服务器 ${server.url} 队列较长 (${queue.total})，但仍可用`)\n+      return true\n+    }\n+\n+    return true\n+  }\n+\n+  /**\n    * 检查服务器健康状态\n    */\n   async checkServerHealth(serverUrl) {\n     try {\n"
                },
                {
                    "date": 1752411238444,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -306,13 +306,13 @@\n           return lockedServer\n         }\n       }\n \n-      // 更新服务器负载信息\n+      // 更新服务器负载信息（如果没有健康服务器，强制更新）\n       await this.updateServerLoads()\n \n       // 获取所有健康的服务器\n-      const healthyServers = Array.from(this.serverLoads.values())\n+      let healthyServers = Array.from(this.serverLoads.values())\n         .filter(server => server.healthy)\n         .sort((a, b) => {\n           // 首先按队列数量排序\n           const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n@@ -321,10 +321,24 @@\n           // 队列相同时按优先级排序\n           return a.priority - b.priority\n         })\n \n+      // 如果没有健康服务器，强制更新一次再试\n       if (healthyServers.length === 0) {\n-        console.warn('⚠️ 没有健康的服务器可用')\n+        console.warn('⚠️ 没有健康的服务器可用，强制更新后重试...')\n+        await this.updateServerLoads(true) // 强制更新\n+\n+        healthyServers = Array.from(this.serverLoads.values())\n+          .filter(server => server.healthy)\n+          .sort((a, b) => {\n+            const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n+            if (queueDiff !== 0) return queueDiff\n+            return a.priority - b.priority\n+          })\n+      }\n+\n+      if (healthyServers.length === 0) {\n+        console.warn('⚠️ 强制更新后仍没有健康的服务器可用')\n         return await this.fallbackToAnyServer()\n       }\n \n       const selectedServer = healthyServers[0]\n"
                },
                {
                    "date": 1752411258535,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -360,9 +360,23 @@\n    */\n   async fallbackToAnyServer() {\n     console.log('🔄 使用备用服务器选择策略...')\n \n-    // 按优先级返回第一个服务器\n+    // 尝试选择响应时间最快的服务器（即使队列较长）\n+    const serversWithResponse = Array.from(this.serverLoads.values())\n+      .filter(server => server.responseTime > 0) // 至少有响应\n+      .sort((a, b) => {\n+        // 按响应时间排序\n+        return a.responseTime - b.responseTime\n+      })\n+\n+    if (serversWithResponse.length > 0) {\n+      const fastestServer = serversWithResponse[0]\n+      console.log(`🆘 选择响应最快的服务器: ${fastestServer.url} (响应时间: ${fastestServer.responseTime}ms, 队列: ${fastestServer.queue.total || 0})`)\n+      return fastestServer.url\n+    }\n+\n+    // 如果没有响应数据，按优先级返回第一个服务器\n     if (this.servers.length > 0) {\n       const fallbackServer = this.servers[0].url\n       console.log(`🆘 备用服务器: ${fallbackServer}`)\n       return fallbackServer\n"
                },
                {
                    "date": 1752411277869,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -130,9 +130,10 @@\n           responseTime: health.responseTime || 0,\n           healthDetails: { health, queue }\n         })\n \n-        console.log(`📊 ${server.url}: 健康=${health.healthy}, 队列=${queue.total || 0}`)\n+        const queueInfo = queue.healthy ? `队列=${queue.total || 0}(运行:${queue.running || 0},等待:${queue.pending || 0})` : `队列检查失败`\n+        console.log(`📊 ${server.url}: 健康=${health.healthy}, ${queueInfo}, 响应时间=${health.responseTime || 0}ms`)\n \n       } catch (error) {\n         console.error(`❌ 更新服务器负载失败 ${server.url}:`, error)\n         this.serverLoads.set(server.url, {\n"
                },
                {
                    "date": 1752411297072,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -491,12 +491,16 @@\n   logServerStatus() {\n     console.log('📊 当前所有服务器状态:')\n     for (const [url, info] of this.serverLoads.entries()) {\n       const status = info.healthy ? '✅' : '❌'\n-      const queue = info.healthy ? `队列:${info.queue.total || 0}` : '不健康'\n+      const queueInfo = info.queue ?\n+        `队列:${info.queue.total || 0}(运行:${info.queue.running || 0},等待:${info.queue.pending || 0})` :\n+        '队列:未知'\n       const locked = url === this.lockedServer ? '🔒' : ''\n       const priority = `优先级:${info.priority}`\n-      console.log(`   ${status} ${url} ${queue} ${priority} ${locked}`)\n+      const responseTime = info.responseTime ? `响应:${info.responseTime}ms` : '响应:未知'\n+      const lastCheck = info.lastCheck ? `检查:${Math.round((Date.now() - info.lastCheck) / 1000)}s前` : '检查:从未'\n+      console.log(`   ${status} ${url} ${queueInfo} ${priority} ${responseTime} ${lastCheck} ${locked}`)\n     }\n   }\n \n   /**\n"
                },
                {
                    "date": 1752411316946,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -485,8 +485,27 @@\n     return await this.selectServerByMinQueue()\n   }\n \n   /**\n+   * 强制重新评估所有服务器\n+   */\n+  async forceReassessment() {\n+    console.log('🔄 强制重新评估所有服务器...')\n+\n+    // 清除锁定状态\n+    this.lockedServer = null\n+    this.lastLockTime = 0\n+\n+    // 强制更新负载信息\n+    await this.updateServerLoads(true)\n+\n+    // 显示当前状态\n+    this.logServerStatus()\n+\n+    console.log('✅ 服务器重新评估完成')\n+  }\n+\n+  /**\n    * 显示服务器状态\n    */\n   logServerStatus() {\n     console.log('📊 当前所有服务器状态:')\n"
                },
                {
                    "date": 1752432824586,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,13 +42,19 @@\n       }\n \n       // 备用服务器\n       if (config['comfyui.backup_servers']) {\n-        const backupServers = config['comfyui.backup_servers']\n-          .split('\\n')\n+        let backupServersText = config['comfyui.backup_servers']\n+\n+        // 支持多种分隔符：换行符、逗号、分号\n+        const backupServers = backupServersText\n+          .split(/[\\n,;]/)\n           .map(url => url.trim())\n           .filter(url => url && url.startsWith('http'))\n \n+        console.log(`🔍 解析备用服务器配置: \"${backupServersText}\"`)\n+        console.log(`📋 解析出的备用服务器:`, backupServers)\n+\n         backupServers.forEach((url, index) => {\n           this.servers.push({\n             url,\n             type: 'backup',\n"
                },
                {
                    "date": 1752432849289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -163,8 +163,9 @@\n    */\n   determineServerHealth(health, queue, server) {\n     // 如果健康检查完全失败，标记为不健康\n     if (!health.healthy) {\n+      console.log(`❌ 服务器 ${server.url} 健康检查失败`)\n       return false\n     }\n \n     // 如果队列检查失败但健康检查通过，仍然认为服务器可用\n@@ -179,8 +180,9 @@\n       console.log(`⚠️ 服务器 ${server.url} 队列较长 (${queue.total})，但仍可用`)\n       return true\n     }\n \n+    console.log(`✅ 服务器 ${server.url} 健康状态良好`)\n     return true\n   }\n \n   /**\n"
                },
                {
                    "date": 1752432865080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -345,9 +345,9 @@\n           })\n       }\n \n       if (healthyServers.length === 0) {\n-        console.warn('⚠️ 强制更新后仍没有健康的服务器可用')\n+        console.warn('⚠️ 强制更新后仍没有健康的服务器可用，尝试备用服务器选择策略')\n         return await this.fallbackToAnyServer()\n       }\n \n       const selectedServer = healthyServers[0]\n"
                },
                {
                    "date": 1752432889563,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -369,9 +369,9 @@\n    */\n   async fallbackToAnyServer() {\n     console.log('🔄 使用备用服务器选择策略...')\n \n-    // 尝试选择响应时间最快的服务器（即使队列较长）\n+    // 首先尝试选择有响应的服务器（按响应时间排序）\n     const serversWithResponse = Array.from(this.serverLoads.values())\n       .filter(server => server.responseTime > 0) // 至少有响应\n       .sort((a, b) => {\n         // 按响应时间排序\n@@ -383,12 +383,27 @@\n       console.log(`🆘 选择响应最快的服务器: ${fastestServer.url} (响应时间: ${fastestServer.responseTime}ms, 队列: ${fastestServer.queue.total || 0})`)\n       return fastestServer.url\n     }\n \n-    // 如果没有响应数据，按优先级返回第一个服务器\n+    // 如果没有响应数据，尝试按优先级顺序测试所有服务器\n+    console.log('🔍 没有响应数据，按优先级测试所有服务器...')\n+    for (const server of this.servers.sort((a, b) => a.priority - b.priority)) {\n+      console.log(`🧪 测试服务器: ${server.url}`)\n+      try {\n+        const health = await this.checkServerHealth(server.url)\n+        if (health.healthy) {\n+          console.log(`✅ 找到可用服务器: ${server.url}`)\n+          return server.url\n+        }\n+      } catch (error) {\n+        console.log(`❌ 服务器 ${server.url} 测试失败: ${error.message}`)\n+      }\n+    }\n+\n+    // 如果所有测试都失败，返回第一个配置的服务器\n     if (this.servers.length > 0) {\n       const fallbackServer = this.servers[0].url\n-      console.log(`🆘 备用服务器: ${fallbackServer}`)\n+      console.log(`🆘 所有服务器测试失败，使用第一个配置的服务器: ${fallbackServer}`)\n       return fallbackServer\n     }\n \n     // 如果没有配置的服务器，尝试多种方式获取默认值\n"
                },
                {
                    "date": 1752432968790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,19 +42,13 @@\n       }\n \n       // 备用服务器\n       if (config['comfyui.backup_servers']) {\n-        let backupServersText = config['comfyui.backup_servers']\n-\n-        // 支持多种分隔符：换行符、逗号、分号\n-        const backupServers = backupServersText\n-          .split(/[\\n,;]/)\n+        const backupServers = config['comfyui.backup_servers']\n+          .split('\\n')\n           .map(url => url.trim())\n           .filter(url => url && url.startsWith('http'))\n \n-        console.log(`🔍 解析备用服务器配置: \"${backupServersText}\"`)\n-        console.log(`📋 解析出的备用服务器:`, backupServers)\n-\n         backupServers.forEach((url, index) => {\n           this.servers.push({\n             url,\n             type: 'backup',\n@@ -163,9 +157,8 @@\n    */\n   determineServerHealth(health, queue, server) {\n     // 如果健康检查完全失败，标记为不健康\n     if (!health.healthy) {\n-      console.log(`❌ 服务器 ${server.url} 健康检查失败`)\n       return false\n     }\n \n     // 如果队列检查失败但健康检查通过，仍然认为服务器可用\n@@ -180,9 +173,8 @@\n       console.log(`⚠️ 服务器 ${server.url} 队列较长 (${queue.total})，但仍可用`)\n       return true\n     }\n \n-    console.log(`✅ 服务器 ${server.url} 健康状态良好`)\n     return true\n   }\n \n   /**\n@@ -345,9 +337,9 @@\n           })\n       }\n \n       if (healthyServers.length === 0) {\n-        console.warn('⚠️ 强制更新后仍没有健康的服务器可用，尝试备用服务器选择策略')\n+        console.warn('⚠️ 强制更新后仍没有健康的服务器可用')\n         return await this.fallbackToAnyServer()\n       }\n \n       const selectedServer = healthyServers[0]\n@@ -369,9 +361,9 @@\n    */\n   async fallbackToAnyServer() {\n     console.log('🔄 使用备用服务器选择策略...')\n \n-    // 首先尝试选择有响应的服务器（按响应时间排序）\n+    // 尝试选择响应时间最快的服务器（即使队列较长）\n     const serversWithResponse = Array.from(this.serverLoads.values())\n       .filter(server => server.responseTime > 0) // 至少有响应\n       .sort((a, b) => {\n         // 按响应时间排序\n@@ -383,27 +375,12 @@\n       console.log(`🆘 选择响应最快的服务器: ${fastestServer.url} (响应时间: ${fastestServer.responseTime}ms, 队列: ${fastestServer.queue.total || 0})`)\n       return fastestServer.url\n     }\n \n-    // 如果没有响应数据，尝试按优先级顺序测试所有服务器\n-    console.log('🔍 没有响应数据，按优先级测试所有服务器...')\n-    for (const server of this.servers.sort((a, b) => a.priority - b.priority)) {\n-      console.log(`🧪 测试服务器: ${server.url}`)\n-      try {\n-        const health = await this.checkServerHealth(server.url)\n-        if (health.healthy) {\n-          console.log(`✅ 找到可用服务器: ${server.url}`)\n-          return server.url\n-        }\n-      } catch (error) {\n-        console.log(`❌ 服务器 ${server.url} 测试失败: ${error.message}`)\n-      }\n-    }\n-\n-    // 如果所有测试都失败，返回第一个配置的服务器\n+    // 如果没有响应数据，按优先级返回第一个服务器\n     if (this.servers.length > 0) {\n       const fallbackServer = this.servers[0].url\n-      console.log(`🆘 所有服务器测试失败，使用第一个配置的服务器: ${fallbackServer}`)\n+      console.log(`🆘 备用服务器: ${fallbackServer}`)\n       return fallbackServer\n     }\n \n     // 如果没有配置的服务器，尝试多种方式获取默认值\n"
                },
                {
                    "date": 1752433073845,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,14 +10,19 @@\n     this.servers = []\n     this.serverLoads = new Map()\n     this.lockedServer = null\n     this.lastLockTime = 0\n-    this.lockDuration = 30000 // 30秒锁定时间\n-    this.healthCheckTimeout = 15000 // 15秒健康检查超时\n-    this.queueCheckTimeout = 8000 // 8秒队列检查超时\n+    this.lockDuration = 15000 // 缩短锁定时间到15秒\n+    this.healthCheckTimeout = 10000 // 10秒健康检查超时\n+    this.queueCheckTimeout = 6000 // 6秒队列检查超时\n     this.lastUpdateTime = 0\n-    this.updateInterval = 10000 // 10秒更新间隔（更频繁的更新）\n-    this.forceUpdateThreshold = 30000 // 30秒强制更新阈值\n+    this.updateInterval = 8000 // 8秒更新间隔（更频繁的更新）\n+    this.forceUpdateThreshold = 20000 // 20秒强制更新阈值\n+    this.failureThreshold = 2 // 连续失败2次后标记为不健康\n+    this.serverFailures = new Map() // 记录服务器失败次数\n+    this.autoFailoverEnabled = true // 启用自动故障转移\n+    this.lastFailoverTime = 0\n+    this.failoverCooldown = 5000 // 故障转移冷却时间5秒\n   }\n \n   /**\n    * 初始化负载均衡器\n"
                },
                {
                    "date": 1752433101974,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -460,14 +460,21 @@\n \n   /**\n    * 记录服务器失败\n    */\n-  async recordFailure(serverUrl) {\n-    console.log(`📝 记录服务器失败: ${serverUrl}`)\n+  async recordFailure(serverUrl, errorType = 'unknown') {\n+    console.log(`📝 记录服务器失败: ${serverUrl}, 错误类型: ${errorType}`)\n \n-    // 如果失败的是当前锁定的服务器，解除锁定\n+    // 增加失败计数\n+    const currentFailures = this.serverFailures.get(serverUrl) || 0\n+    const newFailures = currentFailures + 1\n+    this.serverFailures.set(serverUrl, newFailures)\n+\n+    console.log(`⚠️ 服务器 ${serverUrl} 失败次数: ${newFailures}/${this.failureThreshold}`)\n+\n+    // 如果失败的是当前锁定的服务器，立即解除锁定\n     if (this.lockedServer === serverUrl) {\n-      console.log('🔓 解除失败服务器的锁定')\n+      console.log('🔓 立即解除失败服务器的锁定')\n       this.lockedServer = null\n       this.lastLockTime = 0\n     }\n \n@@ -475,16 +482,73 @@\n     if (this.serverLoads.has(serverUrl)) {\n       const serverInfo = this.serverLoads.get(serverUrl)\n       serverInfo.healthy = false\n       serverInfo.lastFailure = Date.now()\n+      serverInfo.failureCount = newFailures\n+      serverInfo.lastErrorType = errorType\n       this.serverLoads.set(serverUrl, serverInfo)\n     }\n \n+    // 如果达到失败阈值且启用自动故障转移，触发故障转移\n+    if (newFailures >= this.failureThreshold && this.autoFailoverEnabled) {\n+      await this.triggerFailover(serverUrl)\n+    }\n+\n     // 强制更新服务器负载信息\n     this.lastUpdateTime = 0\n   }\n \n   /**\n+   * 触发故障转移\n+   */\n+  async triggerFailover(failedServerUrl) {\n+    const now = Date.now()\n+\n+    // 检查故障转移冷却时间\n+    if (now - this.lastFailoverTime < this.failoverCooldown) {\n+      console.log('⏳ 故障转移冷却中，跳过此次转移')\n+      return\n+    }\n+\n+    console.log(`🔄 触发故障转移，失败服务器: ${failedServerUrl}`)\n+    this.lastFailoverTime = now\n+\n+    // 强制重新评估所有服务器\n+    await this.forceReassessment()\n+\n+    // 尝试选择新的服务器\n+    try {\n+      const newServer = await this.selectServerByMinQueue()\n+      if (newServer && newServer !== failedServerUrl) {\n+        console.log(`✅ 故障转移成功，新服务器: ${newServer}`)\n+        return newServer\n+      } else {\n+        console.warn('⚠️ 故障转移失败，没有可用的替代服务器')\n+      }\n+    } catch (error) {\n+      console.error('❌ 故障转移过程中出错:', error)\n+    }\n+  }\n+\n+  /**\n+   * 重置服务器失败计数\n+   */\n+  resetFailureCount(serverUrl) {\n+    if (this.serverFailures.has(serverUrl)) {\n+      console.log(`🔄 重置服务器失败计数: ${serverUrl}`)\n+      this.serverFailures.delete(serverUrl)\n+\n+      // 同时更新服务器负载信息\n+      if (this.serverLoads.has(serverUrl)) {\n+        const serverInfo = this.serverLoads.get(serverUrl)\n+        serverInfo.failureCount = 0\n+        delete serverInfo.lastErrorType\n+        this.serverLoads.set(serverUrl, serverInfo)\n+      }\n+    }\n+  }\n+\n+  /**\n    * 获取最优服务器（主要接口）\n    */\n   async getOptimalServer() {\n     return await this.selectServerByMinQueue()\n"
                },
                {
                    "date": 1752433121431,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,15 +126,22 @@\n \n         // 更智能的健康状态判断\n         const isHealthy = this.determineServerHealth(health, queue, server)\n \n+        // 如果服务器恢复健康，重置失败计数\n+        if (isHealthy && this.serverFailures.has(server.url)) {\n+          console.log(`✅ 服务器 ${server.url} 已恢复健康，重置失败计数`)\n+          this.resetFailureCount(server.url)\n+        }\n+\n         this.serverLoads.set(server.url, {\n           ...server,\n           healthy: isHealthy,\n           queue: queue,\n           lastCheck: now,\n           responseTime: health.responseTime || 0,\n-          healthDetails: { health, queue }\n+          healthDetails: { health, queue },\n+          failureCount: this.serverFailures.get(server.url) || 0\n         })\n \n         const queueInfo = queue.healthy ? `队列=${queue.total || 0}(运行:${queue.running || 0},等待:${queue.pending || 0})` : `队列检查失败`\n         console.log(`📊 ${server.url}: 健康=${health.healthy}, ${queueInfo}, 响应时间=${health.responseTime || 0}ms`)\n"
                },
                {
                    "date": 1752433140936,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -324,15 +324,32 @@\n       await this.updateServerLoads()\n \n       // 获取所有健康的服务器\n       let healthyServers = Array.from(this.serverLoads.values())\n-        .filter(server => server.healthy)\n+        .filter(server => {\n+          // 过滤掉健康状态为false的服务器\n+          if (!server.healthy) return false\n+\n+          // 过滤掉失败次数过多的服务器\n+          const failures = this.serverFailures.get(server.url) || 0\n+          if (failures >= this.failureThreshold) {\n+            console.log(`⚠️ 跳过失败次数过多的服务器: ${server.url} (${failures}次)`)\n+            return false\n+          }\n+\n+          return true\n+        })\n         .sort((a, b) => {\n-          // 首先按队列数量排序\n+          // 首先按失败次数排序（失败次数少的优先）\n+          const failureA = this.serverFailures.get(a.url) || 0\n+          const failureB = this.serverFailures.get(b.url) || 0\n+          if (failureA !== failureB) return failureA - failureB\n+\n+          // 然后按队列数量排序\n           const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n           if (queueDiff !== 0) return queueDiff\n \n-          // 队列相同时按优先级排序\n+          // 最后按优先级排序\n           return a.priority - b.priority\n         })\n \n       // 如果没有健康服务器，强制更新一次再试\n"
                },
                {
                    "date": 1752433159045,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -587,8 +587,12 @@\n     // 清除锁定状态\n     this.lockedServer = null\n     this.lastLockTime = 0\n \n+    // 重置所有服务器的失败计数（给它们一个重新开始的机会）\n+    console.log('🔄 重置所有服务器失败计数')\n+    this.serverFailures.clear()\n+\n     // 强制更新负载信息\n     await this.updateServerLoads(true)\n \n     // 显示当前状态\n"
                },
                {
                    "date": 1752433183172,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -614,9 +614,12 @@\n       const locked = url === this.lockedServer ? '🔒' : ''\n       const priority = `优先级:${info.priority}`\n       const responseTime = info.responseTime ? `响应:${info.responseTime}ms` : '响应:未知'\n       const lastCheck = info.lastCheck ? `检查:${Math.round((Date.now() - info.lastCheck) / 1000)}s前` : '检查:从未'\n-      console.log(`   ${status} ${url} ${queueInfo} ${priority} ${responseTime} ${lastCheck} ${locked}`)\n+      const failures = this.serverFailures.get(url) || 0\n+      const failureInfo = failures > 0 ? `失败:${failures}次` : ''\n+      const errorType = info.lastErrorType ? `错误:${info.lastErrorType}` : ''\n+      console.log(`   ${status} ${url} ${queueInfo} ${priority} ${responseTime} ${lastCheck} ${failureInfo} ${errorType} ${locked}`)\n     }\n   }\n \n   /**\n"
                },
                {
                    "date": 1752433248550,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,8 +21,10 @@\n     this.serverFailures = new Map() // 记录服务器失败次数\n     this.autoFailoverEnabled = true // 启用自动故障转移\n     this.lastFailoverTime = 0\n     this.failoverCooldown = 5000 // 故障转移冷却时间5秒\n+    this.healthMonitorInterval = null // 健康监控定时器\n+    this.healthMonitorFrequency = 30000 // 30秒检查一次健康状态\n   }\n \n   /**\n    * 初始化负载均衡器\n"
                },
                {
                    "date": 1752433264068,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,8 +85,11 @@\n \n       // 初始化服务器负载信息\n       await this.updateServerLoads()\n \n+      // 启动健康监控\n+      this.startHealthMonitoring()\n+\n       console.log('✅ ComfyUI 负载均衡器初始化完成')\n \n     } catch (error) {\n       console.error('❌ 负载均衡器初始化失败:', error)\n"
                },
                {
                    "date": 1752433286725,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -652,8 +652,80 @@\n     }\n \n     return stats\n   }\n+\n+  /**\n+   * 启动健康监控\n+   */\n+  startHealthMonitoring() {\n+    if (this.healthMonitorInterval) {\n+      clearInterval(this.healthMonitorInterval)\n+    }\n+\n+    console.log(`🏥 启动健康监控，检查频率: ${this.healthMonitorFrequency / 1000}秒`)\n+\n+    this.healthMonitorInterval = setInterval(async () => {\n+      try {\n+        await this.performHealthMonitoring()\n+      } catch (error) {\n+        console.error('❌ 健康监控出错:', error)\n+      }\n+    }, this.healthMonitorFrequency)\n+  }\n+\n+  /**\n+   * 停止健康监控\n+   */\n+  stopHealthMonitoring() {\n+    if (this.healthMonitorInterval) {\n+      console.log('🛑 停止健康监控')\n+      clearInterval(this.healthMonitorInterval)\n+      this.healthMonitorInterval = null\n+    }\n+  }\n+\n+  /**\n+   * 执行健康监控\n+   */\n+  async performHealthMonitoring() {\n+    console.log('🏥 执行定期健康检查...')\n+\n+    // 更新服务器负载信息\n+    await this.updateServerLoads()\n+\n+    // 检查当前锁定的服务器是否仍然健康\n+    if (this.lockedServer) {\n+      const lockedServerInfo = this.serverLoads.get(this.lockedServer)\n+      if (lockedServerInfo && !lockedServerInfo.healthy) {\n+        console.warn(`⚠️ 锁定的服务器 ${this.lockedServer} 不健康，解除锁定`)\n+        this.lockedServer = null\n+        this.lastLockTime = 0\n+      }\n+    }\n+\n+    // 检查是否有服务器从故障中恢复\n+    const healthyServers = Array.from(this.serverLoads.values())\n+      .filter(server => server.healthy)\n+\n+    if (healthyServers.length > 0) {\n+      console.log(`✅ 健康监控完成，发现 ${healthyServers.length} 个健康服务器`)\n+    } else {\n+      console.warn('⚠️ 健康监控警告：没有发现健康的服务器')\n+    }\n+  }\n+\n+  /**\n+   * 销毁负载均衡器\n+   */\n+  destroy() {\n+    this.stopHealthMonitoring()\n+    this.servers = []\n+    this.serverLoads.clear()\n+    this.serverFailures.clear()\n+    this.lockedServer = null\n+    console.log('🗑️ 负载均衡器已销毁')\n+  }\n }\n \n // 创建单例实例\n const loadBalancer = new ComfyUILoadBalancer()\n"
                },
                {
                    "date": 1752433308913,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -583,8 +583,56 @@\n     return await this.selectServerByMinQueue()\n   }\n \n   /**\n+   * 手动触发服务器切换\n+   */\n+  async switchToNextServer() {\n+    console.log('🔄 手动触发服务器切换...')\n+\n+    // 如果当前有锁定的服务器，将其标记为失败\n+    if (this.lockedServer) {\n+      console.log(`📝 标记当前服务器为失败: ${this.lockedServer}`)\n+      await this.recordFailure(this.lockedServer, 'manual_switch')\n+    }\n+\n+    // 强制重新评估并选择新服务器\n+    await this.forceReassessment()\n+    const newServer = await this.selectServerByMinQueue()\n+\n+    console.log(`✅ 手动切换完成，新服务器: ${newServer}`)\n+    return newServer\n+  }\n+\n+  /**\n+   * 获取下一个可用服务器（不锁定）\n+   */\n+  async getNextAvailableServer(excludeUrls = []) {\n+    await this.updateServerLoads()\n+\n+    const availableServers = Array.from(this.serverLoads.values())\n+      .filter(server => {\n+        if (!server.healthy) return false\n+        if (excludeUrls.includes(server.url)) return false\n+\n+        const failures = this.serverFailures.get(server.url) || 0\n+        return failures < this.failureThreshold\n+      })\n+      .sort((a, b) => {\n+        const failureA = this.serverFailures.get(a.url) || 0\n+        const failureB = this.serverFailures.get(b.url) || 0\n+        if (failureA !== failureB) return failureA - failureB\n+\n+        const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n+        if (queueDiff !== 0) return queueDiff\n+\n+        return a.priority - b.priority\n+      })\n+\n+    return availableServers.length > 0 ? availableServers[0].url : null\n+  }\n+\n+  /**\n    * 强制重新评估所有服务器\n    */\n   async forceReassessment() {\n     console.log('🔄 强制重新评估所有服务器...')\n"
                },
                {
                    "date": 1752459661531,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,11 +18,8 @@\n     this.updateInterval = 8000 // 8秒更新间隔（更频繁的更新）\n     this.forceUpdateThreshold = 20000 // 20秒强制更新阈值\n     this.failureThreshold = 2 // 连续失败2次后标记为不健康\n     this.serverFailures = new Map() // 记录服务器失败次数\n-    this.autoFailoverEnabled = true // 启用自动故障转移\n-    this.lastFailoverTime = 0\n-    this.failoverCooldown = 5000 // 故障转移冷却时间5秒\n     this.healthMonitorInterval = null // 健康监控定时器\n     this.healthMonitorFrequency = 30000 // 30秒检查一次健康状态\n   }\n \n"
                },
                {
                    "date": 1752459681684,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -513,12 +513,9 @@\n       serverInfo.lastErrorType = errorType\n       this.serverLoads.set(serverUrl, serverInfo)\n     }\n \n-    // 如果达到失败阈值且启用自动故障转移，触发故障转移\n-    if (newFailures >= this.failureThreshold && this.autoFailoverEnabled) {\n-      await this.triggerFailover(serverUrl)\n-    }\n+    // 记录失败但不自动切换，由用户手动决定\n \n     // 强制更新服务器负载信息\n     this.lastUpdateTime = 0\n   }\n"
                },
                {
                    "date": 1752459701776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -519,40 +519,10 @@\n     // 强制更新服务器负载信息\n     this.lastUpdateTime = 0\n   }\n \n-  /**\n-   * 触发故障转移\n-   */\n-  async triggerFailover(failedServerUrl) {\n-    const now = Date.now()\n \n-    // 检查故障转移冷却时间\n-    if (now - this.lastFailoverTime < this.failoverCooldown) {\n-      console.log('⏳ 故障转移冷却中，跳过此次转移')\n-      return\n-    }\n \n-    console.log(`🔄 触发故障转移，失败服务器: ${failedServerUrl}`)\n-    this.lastFailoverTime = now\n-\n-    // 强制重新评估所有服务器\n-    await this.forceReassessment()\n-\n-    // 尝试选择新的服务器\n-    try {\n-      const newServer = await this.selectServerByMinQueue()\n-      if (newServer && newServer !== failedServerUrl) {\n-        console.log(`✅ 故障转移成功，新服务器: ${newServer}`)\n-        return newServer\n-      } else {\n-        console.warn('⚠️ 故障转移失败，没有可用的替代服务器')\n-      }\n-    } catch (error) {\n-      console.error('❌ 故障转移过程中出错:', error)\n-    }\n-  }\n-\n   /**\n    * 重置服务器失败计数\n    */\n   resetFailureCount(serverUrl) {\n"
                },
                {
                    "date": 1752469902720,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,8 +20,13 @@\n     this.failureThreshold = 2 // 连续失败2次后标记为不健康\n     this.serverFailures = new Map() // 记录服务器失败次数\n     this.healthMonitorInterval = null // 健康监控定时器\n     this.healthMonitorFrequency = 30000 // 30秒检查一次健康状态\n+\n+    // WebSocket专用锁定机制\n+    this.webSocketLockedServer = null\n+    this.webSocketLockTime = 0\n+    this.webSocketLockDuration = 300000 // WebSocket锁定5分钟，因为是长连接\n   }\n \n   /**\n    * 初始化负载均衡器\n"
                },
                {
                    "date": 1752469927232,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -449,9 +449,9 @@\n     return fallbackUrl\n   }\n \n   /**\n-   * 锁定服务器\n+   * 锁定服务器（普通HTTP请求）\n    */\n   lockServer(serverUrl) {\n     this.lockedServer = serverUrl\n     this.lastLockTime = Date.now()\n@@ -461,8 +461,59 @@\n     this.logServerStatus()\n   }\n \n   /**\n+   * 锁定服务器用于WebSocket连接\n+   */\n+  lockServerForWebSocket(serverUrl) {\n+    this.webSocketLockedServer = serverUrl\n+    this.webSocketLockTime = Date.now()\n+    console.log(`🔒🌐 锁定服务器用于WebSocket: ${serverUrl}, 持续 ${this.webSocketLockDuration / 1000} 秒`)\n+\n+    // 同时设置普通锁定，确保一致性\n+    this.lockServer(serverUrl)\n+  }\n+\n+  /**\n+   * 释放WebSocket服务器锁定\n+   */\n+  unlockWebSocketServer() {\n+    if (this.webSocketLockedServer) {\n+      console.log(`🔓🌐 释放WebSocket服务器锁定: ${this.webSocketLockedServer}`)\n+      this.webSocketLockedServer = null\n+      this.webSocketLockTime = 0\n+    }\n+  }\n+\n+  /**\n+   * 检查WebSocket服务器是否被锁定\n+   */\n+  isWebSocketServerLocked() {\n+    if (!this.webSocketLockedServer) return false\n+\n+    const now = Date.now()\n+    const isLocked = (now - this.webSocketLockTime) < this.webSocketLockDuration\n+\n+    if (!isLocked) {\n+      console.log('🔓🌐 WebSocket服务器锁定已过期')\n+      this.webSocketLockedServer = null\n+      this.webSocketLockTime = 0\n+    }\n+\n+    return isLocked\n+  }\n+\n+  /**\n+   * 获取WebSocket锁定的服务器\n+   */\n+  getWebSocketLockedServer() {\n+    if (this.isWebSocketServerLocked()) {\n+      return this.webSocketLockedServer\n+    }\n+    return null\n+  }\n+\n+  /**\n    * 检查服务器是否被锁定\n    */\n   isServerLocked() {\n     if (!this.lockedServer) return false\n"
                },
                {
                    "date": 1752469945266,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -317,9 +317,18 @@\n   async selectServerByMinQueue() {\n     try {\n       console.log('🎯 开始选择最优服务器...')\n \n-      // 检查是否有锁定的服务器\n+      // 优先检查WebSocket锁定的服务器\n+      if (this.isWebSocketServerLocked()) {\n+        const webSocketServer = this.getWebSocketLockedServer()\n+        if (webSocketServer) {\n+          console.log(`🔒🌐 使用WebSocket锁定的服务器: ${webSocketServer}`)\n+          return webSocketServer\n+        }\n+      }\n+\n+      // 检查是否有普通锁定的服务器\n       if (this.isServerLocked()) {\n         const lockedServer = this.getLockedServer()\n         if (lockedServer) {\n           console.log(`🔒 使用锁定的服务器: ${lockedServer}`)\n"
                },
                {
                    "date": 1752508063038,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,10 +32,8 @@\n    * 初始化负载均衡器\n    */\n   async initialize() {\n     try {\n-      console.log('🚀 初始化 ComfyUI 负载均衡器...')\n-\n       // 获取服务器配置\n       const config = await configService.getConfig()\n \n       // 构建服务器列表\n@@ -67,9 +65,8 @@\n       }\n \n       // 如果没有配置服务器，使用默认配置\n       if (this.servers.length === 0) {\n-        console.warn('⚠️ 未找到配置的服务器，使用默认配置')\n         // 从本地配置获取默认服务器\n         const localConfig = JSON.parse(localStorage.getItem('comfyui_config') || '{}')\n         const defaultUrl = localConfig.COMFYUI_SERVER_URL || 'https://your-comfyui-server.com'\n \n@@ -79,25 +76,17 @@\n           priority: 1\n         })\n       }\n \n-      console.log(`✅ 发现 ${this.servers.length} 个 ComfyUI 服务器:`)\n-      this.servers.forEach((server, index) => {\n-        console.log(`   ${index + 1}. ${server.url} (${server.type})`)\n-      })\n-\n       // 初始化服务器负载信息\n       await this.updateServerLoads()\n \n       // 启动健康监控\n       this.startHealthMonitoring()\n \n-      console.log('✅ ComfyUI 负载均衡器初始化完成')\n-\n     } catch (error) {\n-      console.error('❌ 负载均衡器初始化失败:', error)\n+      console.error('负载均衡器初始化失败:', error)\n       // 不抛出错误，允许应用继续运行\n-      console.log('🔄 使用降级模式，将使用单服务器配置')\n     }\n   }\n \n   /**\n"
                },
                {
                    "date": 1752508506549,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,20 +96,16 @@\n     const now = Date.now()\n \n     // 如果距离上次更新时间不足间隔，跳过更新（除非强制更新或超过强制更新阈值）\n     if (!forceUpdate && now - this.lastUpdateTime < this.updateInterval && now - this.lastUpdateTime < this.forceUpdateThreshold) {\n-      console.log('⏭️ 跳过负载更新，距离上次更新时间不足')\n       return\n     }\n \n     // 如果超过强制更新阈值，强制更新\n     if (now - this.lastUpdateTime > this.forceUpdateThreshold) {\n-      console.log('🔄 强制更新服务器负载信息（超过强制更新阈值）')\n       forceUpdate = true\n     }\n \n-    console.log('🔄 更新服务器负载信息...')\n-\n     const updatePromises = this.servers.map(async (server) => {\n       try {\n         // 并行检查健康状态和队列信息\n         const [healthResult, queueResult] = await Promise.allSettled([\n"
                },
                {
                    "date": 1752508528269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,9 +120,8 @@\n         const isHealthy = this.determineServerHealth(health, queue, server)\n \n         // 如果服务器恢复健康，重置失败计数\n         if (isHealthy && this.serverFailures.has(server.url)) {\n-          console.log(`✅ 服务器 ${server.url} 已恢复健康，重置失败计数`)\n           this.resetFailureCount(server.url)\n         }\n \n         this.serverLoads.set(server.url, {\n@@ -134,11 +133,8 @@\n           healthDetails: { health, queue },\n           failureCount: this.serverFailures.get(server.url) || 0\n         })\n \n-        const queueInfo = queue.healthy ? `队列=${queue.total || 0}(运行:${queue.running || 0},等待:${queue.pending || 0})` : `队列检查失败`\n-        console.log(`📊 ${server.url}: 健康=${health.healthy}, ${queueInfo}, 响应时间=${health.responseTime || 0}ms`)\n-\n       } catch (error) {\n         console.error(`❌ 更新服务器负载失败 ${server.url}:`, error)\n         this.serverLoads.set(server.url, {\n           ...server,\n"
                },
                {
                    "date": 1752510457366,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,9 +134,8 @@\n           failureCount: this.serverFailures.get(server.url) || 0\n         })\n \n       } catch (error) {\n-        console.error(`❌ 更新服务器负载失败 ${server.url}:`, error)\n         this.serverLoads.set(server.url, {\n           ...server,\n           healthy: false,\n           queue: { total: 999, healthy: false },\n"
                },
                {
                    "date": 1752510740858,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,9 +203,8 @@\n         return { healthy: false, responseTime, status: response.status }\n       }\n \n     } catch (error) {\n-      console.warn(`⚠️ 健康检查失败 ${serverUrl}:`, error.message)\n       return { healthy: false, error: error.message }\n     }\n   }\n \n"
                },
                {
                    "date": 1752510756620,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -246,9 +246,8 @@\n         return await this.getServerQueueInfoFallback(serverUrl)\n       }\n \n     } catch (error) {\n-      console.warn(`⚠️ 队列信息获取失败 ${serverUrl}:`, error.message)\n       return await this.getServerQueueInfoFallback(serverUrl)\n     }\n   }\n \n"
                },
                {
                    "date": 1752510769668,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -325,9 +325,8 @@\n \n           // 过滤掉失败次数过多的服务器\n           const failures = this.serverFailures.get(server.url) || 0\n           if (failures >= this.failureThreshold) {\n-            console.log(`⚠️ 跳过失败次数过多的服务器: ${server.url} (${failures}次)`)\n             return false\n           }\n \n           return true\n"
                },
                {
                    "date": 1752510840077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -410,29 +410,26 @@\n       const config = await configService.getConfig()\n       const defaultServer = config['comfyui.server_url']\n \n       if (defaultServer && defaultServer !== 'https://your-comfyui-server.com') {\n-        console.log(`🆘 配置服务默认服务器: ${defaultServer}`)\n         return defaultServer\n       }\n     } catch (error) {\n-      console.warn('⚠️ 无法从配置服务获取默认服务器:', error)\n+      // 忽略配置服务错误\n     }\n \n     // 从本地存储获取\n     try {\n       const localConfig = JSON.parse(localStorage.getItem('comfyui_config') || '{}')\n       if (localConfig.COMFYUI_SERVER_URL) {\n-        console.log(`🆘 本地配置服务器: ${localConfig.COMFYUI_SERVER_URL}`)\n         return localConfig.COMFYUI_SERVER_URL\n       }\n     } catch (error) {\n-      console.warn('⚠️ 无法从本地存储获取服务器配置:', error)\n+      // 忽略本地存储错误\n     }\n \n     // 最后的备用方案\n     const fallbackUrl = 'https://your-comfyui-server.com'\n-    console.log(`🆘 使用最后备用服务器: ${fallbackUrl}`)\n     return fallbackUrl\n   }\n \n   /**\n"
                },
                {
                    "date": 1752511013565,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -437,12 +437,8 @@\n    */\n   lockServer(serverUrl) {\n     this.lockedServer = serverUrl\n     this.lastLockTime = Date.now()\n-    console.log(`🔒 锁定服务器: ${serverUrl}, 持续 ${this.lockDuration / 1000} 秒`)\n-\n-    // 显示当前所有服务器状态\n-    this.logServerStatus()\n   }\n \n   /**\n    * 锁定服务器用于WebSocket连接\n"
                },
                {
                    "date": 1752511030024,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,20 +522,15 @@\n   /**\n    * 记录服务器失败\n    */\n   async recordFailure(serverUrl, errorType = 'unknown') {\n-    console.log(`📝 记录服务器失败: ${serverUrl}, 错误类型: ${errorType}`)\n-\n     // 增加失败计数\n     const currentFailures = this.serverFailures.get(serverUrl) || 0\n     const newFailures = currentFailures + 1\n     this.serverFailures.set(serverUrl, newFailures)\n \n-    console.log(`⚠️ 服务器 ${serverUrl} 失败次数: ${newFailures}/${this.failureThreshold}`)\n-\n     // 如果失败的是当前锁定的服务器，立即解除锁定\n     if (this.lockedServer === serverUrl) {\n-      console.log('🔓 立即解除失败服务器的锁定')\n       this.lockedServer = null\n       this.lastLockTime = 0\n     }\n \n"
                },
                {
                    "date": 1752511051247,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -729,18 +729,15 @@\n   /**\n    * 执行健康监控\n    */\n   async performHealthMonitoring() {\n-    console.log('🏥 执行定期健康检查...')\n-\n     // 更新服务器负载信息\n     await this.updateServerLoads()\n \n     // 检查当前锁定的服务器是否仍然健康\n     if (this.lockedServer) {\n       const lockedServerInfo = this.serverLoads.get(this.lockedServer)\n       if (lockedServerInfo && !lockedServerInfo.healthy) {\n-        console.warn(`⚠️ 锁定的服务器 ${this.lockedServer} 不健康，解除锁定`)\n         this.lockedServer = null\n         this.lastLockTime = 0\n       }\n     }\n@@ -748,12 +745,11 @@\n     // 检查是否有服务器从故障中恢复\n     const healthyServers = Array.from(this.serverLoads.values())\n       .filter(server => server.healthy)\n \n-    if (healthyServers.length > 0) {\n-      console.log(`✅ 健康监控完成，发现 ${healthyServers.length} 个健康服务器`)\n-    } else {\n-      console.warn('⚠️ 健康监控警告：没有发现健康的服务器')\n+    // 只在没有健康服务器时输出警告\n+    if (healthyServers.length === 0) {\n+      console.warn('警告：没有发现健康的ComfyUI服务器')\n     }\n   }\n \n   /**\n"
                },
                {
                    "date": 1752511069436,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -760,9 +760,8 @@\n     this.servers = []\n     this.serverLoads.clear()\n     this.serverFailures.clear()\n     this.lockedServer = null\n-    console.log('🗑️ 负载均衡器已销毁')\n   }\n }\n \n // 创建单例实例\n"
                },
                {
                    "date": 1752512395604,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,32 +1,16 @@\n-// ComfyUI 负载均衡器 - 基于任务队列的智能选择\n+// ComfyUI 极简负载均衡器\n import configService from './configService.js'\n \n /**\n- * ComfyUI 负载均衡器\n- * 根据服务器任务队列情况选择最优服务器\n+ * ComfyUI 极简负载均衡器\n+ * 只在用户发起请求时选择队列最少的可用服务器\n  */\n class ComfyUILoadBalancer {\n   constructor() {\n-    this.servers = []\n-    this.serverLoads = new Map()\n-    this.lockedServer = null\n-    this.lastLockTime = 0\n-    this.lockDuration = 15000 // 缩短锁定时间到15秒\n-    this.healthCheckTimeout = 10000 // 10秒健康检查超时\n-    this.queueCheckTimeout = 6000 // 6秒队列检查超时\n-    this.lastUpdateTime = 0\n-    this.updateInterval = 8000 // 8秒更新间隔（更频繁的更新）\n-    this.forceUpdateThreshold = 20000 // 20秒强制更新阈值\n-    this.failureThreshold = 2 // 连续失败2次后标记为不健康\n-    this.serverFailures = new Map() // 记录服务器失败次数\n-    this.healthMonitorInterval = null // 健康监控定时器\n-    this.healthMonitorFrequency = 30000 // 30秒检查一次健康状态\n-\n-    // WebSocket专用锁定机制\n-    this.webSocketLockedServer = null\n-    this.webSocketLockTime = 0\n-    this.webSocketLockDuration = 300000 // WebSocket锁定5分钟，因为是长连接\n+    this.queueCheckTimeout = 5000 // 5秒队列检查超时\n+    this.healthCheckTimeout = 5000 // 5秒健康检查超时\n+    this.initialized = false\n   }\n \n   /**\n    * 初始化负载均衡器\n"
                },
                {
                    "date": 1752513381012,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,184 +12,113 @@\n     this.initialized = false\n   }\n \n   /**\n-   * 初始化负载均衡器\n+   * 初始化负载均衡器（仅在页面加载时执行一次）\n    */\n   async initialize() {\n+    if (this.initialized) {\n+      return\n+    }\n+\n     try {\n-      // 获取服务器配置\n+      console.log('🔄 初始化负载均衡器...')\n+      this.initialized = true\n+      console.log('✅ 负载均衡器初始化完成')\n+    } catch (error) {\n+      console.error('❌ 负载均衡器初始化失败:', error)\n+      this.initialized = false\n+    }\n+  }\n+\n+  /**\n+   * 获取最新的服务器列表（从数据库/配置中获取）\n+   */\n+  async getLatestServerList() {\n+    try {\n+      console.log('🔄 获取最新服务器列表...')\n+\n+      // 从配置服务获取最新配置\n       const config = await configService.getConfig()\n+      const servers = []\n \n-      // 构建服务器列表\n-      this.servers = []\n-\n       // 主服务器\n       if (config['comfyui.server_url']) {\n-        this.servers.push({\n+        servers.push({\n           url: config['comfyui.server_url'],\n           type: 'primary',\n           priority: 1\n         })\n       }\n \n-      // 备用服务器\n+      // 备用服务器 - 支持换行符和逗号两种分隔方式\n       if (config['comfyui.backup_servers']) {\n         const backupServers = config['comfyui.backup_servers']\n+          .replace(/\\s*,\\s*/g, '\\n') // 将逗号替换为换行符\n           .split('\\n')\n           .map(url => url.trim())\n           .filter(url => url && url.startsWith('http'))\n \n         backupServers.forEach((url, index) => {\n-          this.servers.push({\n+          servers.push({\n             url,\n             type: 'backup',\n             priority: index + 2\n           })\n         })\n       }\n \n       // 如果没有配置服务器，使用默认配置\n-      if (this.servers.length === 0) {\n-        // 从本地配置获取默认服务器\n+      if (servers.length === 0) {\n         const localConfig = JSON.parse(localStorage.getItem('comfyui_config') || '{}')\n         const defaultUrl = localConfig.COMFYUI_SERVER_URL || 'https://your-comfyui-server.com'\n \n-        this.servers.push({\n+        servers.push({\n           url: defaultUrl,\n           type: 'primary',\n           priority: 1\n         })\n       }\n \n-      // 初始化服务器负载信息\n-      await this.updateServerLoads()\n+      console.log(`✅ 获取到 ${servers.length} 个服务器:`, servers.map(s => s.url))\n+      return servers\n \n-      // 启动健康监控\n-      this.startHealthMonitoring()\n-\n     } catch (error) {\n-      console.error('负载均衡器初始化失败:', error)\n-      // 不抛出错误，允许应用继续运行\n+      console.error('❌ 获取服务器列表失败:', error)\n+      return []\n     }\n   }\n \n   /**\n-   * 更新所有服务器的负载信息\n-   */\n-  async updateServerLoads(forceUpdate = false) {\n-    const now = Date.now()\n-\n-    // 如果距离上次更新时间不足间隔，跳过更新（除非强制更新或超过强制更新阈值）\n-    if (!forceUpdate && now - this.lastUpdateTime < this.updateInterval && now - this.lastUpdateTime < this.forceUpdateThreshold) {\n-      return\n-    }\n-\n-    // 如果超过强制更新阈值，强制更新\n-    if (now - this.lastUpdateTime > this.forceUpdateThreshold) {\n-      forceUpdate = true\n-    }\n-\n-    const updatePromises = this.servers.map(async (server) => {\n-      try {\n-        // 并行检查健康状态和队列信息\n-        const [healthResult, queueResult] = await Promise.allSettled([\n-          this.checkServerHealth(server.url),\n-          this.getServerQueueInfo(server.url)\n-        ])\n-\n-        const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n-        const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n-\n-        // 更智能的健康状态判断\n-        const isHealthy = this.determineServerHealth(health, queue, server)\n-\n-        // 如果服务器恢复健康，重置失败计数\n-        if (isHealthy && this.serverFailures.has(server.url)) {\n-          this.resetFailureCount(server.url)\n-        }\n-\n-        this.serverLoads.set(server.url, {\n-          ...server,\n-          healthy: isHealthy,\n-          queue: queue,\n-          lastCheck: now,\n-          responseTime: health.responseTime || 0,\n-          healthDetails: { health, queue },\n-          failureCount: this.serverFailures.get(server.url) || 0\n-        })\n-\n-      } catch (error) {\n-        this.serverLoads.set(server.url, {\n-          ...server,\n-          healthy: false,\n-          queue: { total: 999, healthy: false },\n-          lastCheck: now,\n-          error: error.message\n-        })\n-      }\n-    })\n-\n-    await Promise.allSettled(updatePromises)\n-    this.lastUpdateTime = now\n-\n-    console.log('✅ 服务器负载信息更新完成')\n-  }\n-\n-  /**\n-   * 更智能的服务器健康状态判断\n-   */\n-  determineServerHealth(health, queue, server) {\n-    // 如果健康检查完全失败，标记为不健康\n-    if (!health.healthy) {\n-      return false\n-    }\n-\n-    // 如果队列检查失败但健康检查通过，仍然认为服务器可用\n-    // 这样可以避免因为队列API不可用而错误地标记服务器为不健康\n-    if (!queue.healthy) {\n-      console.log(`⚠️ 服务器 ${server.url} 队列检查失败，但健康检查通过，仍标记为可用`)\n-      return true\n-    }\n-\n-    // 如果队列过长（超过10个任务），降低优先级但不标记为不健康\n-    if (queue.total > 10) {\n-      console.log(`⚠️ 服务器 ${server.url} 队列较长 (${queue.total})，但仍可用`)\n-      return true\n-    }\n-\n-    return true\n-  }\n-\n-  /**\n    * 检查服务器健康状态\n    */\n   async checkServerHealth(serverUrl) {\n     try {\n-      const startTime = Date.now()\n-\n       const controller = new AbortController()\n       const timeoutId = setTimeout(() => controller.abort(), this.healthCheckTimeout)\n \n+      const startTime = Date.now()\n       const response = await fetch(`${serverUrl}/system_stats`, {\n         method: 'GET',\n         signal: controller.signal,\n         headers: {\n-          'Content-Type': 'application/json'\n+          'Cache-Control': 'no-cache'\n         }\n       })\n+      const endTime = Date.now()\n \n       clearTimeout(timeoutId)\n-      const responseTime = Date.now() - startTime\n \n-      if (response.ok) {\n-        return { healthy: true, responseTime, status: response.status }\n-      } else {\n-        return { healthy: false, responseTime, status: response.status }\n+      return {\n+        healthy: response.ok,\n+        responseTime: endTime - startTime,\n+        status: response.status\n       }\n-\n     } catch (error) {\n-      return { healthy: false, error: error.message }\n+      return {\n+        healthy: false,\n+        error: error.message\n+      }\n     }\n   }\n \n   /**\n@@ -203,16 +132,18 @@\n       const response = await fetch(`${serverUrl}/queue`, {\n         method: 'GET',\n         signal: controller.signal,\n         headers: {\n-          'Content-Type': 'application/json'\n+          'Content-Type': 'application/json',\n+          'Cache-Control': 'no-cache'\n         }\n       })\n \n       clearTimeout(timeoutId)\n \n       if (response.ok) {\n         const queueData = await response.json()\n+        console.log(`📊 服务器 ${serverUrl} 队列数据:`, queueData)\n \n         // ComfyUI 队列 API 返回格式: { queue_running: [...], queue_pending: [...] }\n         const running = queueData.queue_running ? queueData.queue_running.length : 0\n         const pending = queueData.queue_pending ? queueData.queue_pending.length : 0\n@@ -221,532 +152,150 @@\n         return {\n           running,\n           pending,\n           total,\n-          healthy: true,\n-          supportsQueueAPI: true\n+          healthy: true\n         }\n       } else {\n-        // 如果队列 API 不可用，尝试使用系统状态作为备用\n-        return await this.getServerQueueInfoFallback(serverUrl)\n-      }\n-\n-    } catch (error) {\n-      return await this.getServerQueueInfoFallback(serverUrl)\n-    }\n-  }\n-\n-  /**\n-   * 备用队列信息获取方法\n-   */\n-  async getServerQueueInfoFallback(serverUrl) {\n-    try {\n-      const controller = new AbortController()\n-      const timeoutId = setTimeout(() => controller.abort(), this.queueCheckTimeout)\n-\n-      const response = await fetch(`${serverUrl}/system_stats`, {\n-        method: 'GET',\n-        signal: controller.signal\n-      })\n-\n-      clearTimeout(timeoutId)\n-\n-      if (response.ok) {\n-        // 如果无法获取精确队列信息，假设服务器可用但队列未知\n+        console.warn(`⚠️ 服务器 ${serverUrl} 队列API返回状态码: ${response.status}`)\n         return {\n           running: 0,\n           pending: 0,\n-          total: 0,\n+          total: 1, // 使用1而不是0，避免所有用户都选择这个服务器\n           healthy: true,\n-          supportsQueueAPI: false\n+          isEstimate: true\n         }\n       }\n+\n     } catch (error) {\n-      // 忽略错误\n+      console.warn(`⚠️ 获取服务器 ${serverUrl} 队列信息失败:`, error.message)\n+      return {\n+        running: 0,\n+        pending: 0,\n+        total: 999, // 高值表示不可用\n+        healthy: false\n+      }\n     }\n-\n-    return {\n-      running: 0,\n-      pending: 0,\n-      total: 999, // 高值表示不可用\n-      healthy: false,\n-      supportsQueueAPI: false\n-    }\n   }\n \n   /**\n-   * 根据最小队列选择服务器\n+   * 选择最优服务器（主要接口）\n+   * 只在用户发起生图请求时调用\n    */\n-  async selectServerByMinQueue() {\n+  async getOptimalServer() {\n     try {\n       console.log('🎯 开始选择最优服务器...')\n \n-      // 优先检查WebSocket锁定的服务器\n-      if (this.isWebSocketServerLocked()) {\n-        const webSocketServer = this.getWebSocketLockedServer()\n-        if (webSocketServer) {\n-          console.log(`🔒🌐 使用WebSocket锁定的服务器: ${webSocketServer}`)\n-          return webSocketServer\n-        }\n-      }\n+      // 1. 获取最新的服务器列表\n+      const servers = await this.getLatestServerList()\n \n-      // 检查是否有普通锁定的服务器\n-      if (this.isServerLocked()) {\n-        const lockedServer = this.getLockedServer()\n-        if (lockedServer) {\n-          console.log(`🔒 使用锁定的服务器: ${lockedServer}`)\n-          return lockedServer\n-        }\n+      if (servers.length === 0) {\n+        throw new Error('没有可用的服务器配置')\n       }\n \n-      // 更新服务器负载信息（如果没有健康服务器，强制更新）\n-      await this.updateServerLoads()\n+      // 2. 并行检查所有服务器的健康状态和队列信息\n+      console.log('🔍 检查所有服务器状态...')\n+      const serverChecks = servers.map(async (server) => {\n+        try {\n+          const [healthResult, queueResult] = await Promise.allSettled([\n+            this.checkServerHealth(server.url),\n+            this.getServerQueueInfo(server.url)\n+          ])\n \n-      // 获取所有健康的服务器\n-      let healthyServers = Array.from(this.serverLoads.values())\n-        .filter(server => {\n-          // 过滤掉健康状态为false的服务器\n-          if (!server.healthy) return false\n+          const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n+          const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n \n-          // 过滤掉失败次数过多的服务器\n-          const failures = this.serverFailures.get(server.url) || 0\n-          if (failures >= this.failureThreshold) {\n-            return false\n+          return {\n+            ...server,\n+            healthy: health.healthy,\n+            queue: queue,\n+            responseTime: health.responseTime || 0\n           }\n+        } catch (error) {\n+          console.error(`❌ 检查服务器 ${server.url} 失败:`, error)\n+          return {\n+            ...server,\n+            healthy: false,\n+            queue: { total: 999, healthy: false },\n+            responseTime: 0\n+          }\n+        }\n+      })\n \n-          return true\n-        })\n+      const serverResults = await Promise.all(serverChecks)\n+\n+      // 3. 过滤健康的服务器并按队列长度排序\n+      const healthyServers = serverResults\n+        .filter(server => server.healthy)\n         .sort((a, b) => {\n-          // 首先按失败次数排序（失败次数少的优先）\n-          const failureA = this.serverFailures.get(a.url) || 0\n-          const failureB = this.serverFailures.get(b.url) || 0\n-          if (failureA !== failureB) return failureA - failureB\n-\n-          // 然后按队列数量排序\n+          // 按队列数量排序\n           const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n           if (queueDiff !== 0) return queueDiff\n \n-          // 最后按优先级排序\n+          // 如果队列相同，按优先级排序\n           return a.priority - b.priority\n         })\n \n-      // 如果没有健康服务器，强制更新一次再试\n+      // 4. 选择最优服务器\n       if (healthyServers.length === 0) {\n-        console.warn('⚠️ 没有健康的服务器可用，强制更新后重试...')\n-        await this.updateServerLoads(true) // 强制更新\n+        console.warn('⚠️ 没有健康的服务器可用，尝试使用响应最快的服务器')\n \n-        healthyServers = Array.from(this.serverLoads.values())\n-          .filter(server => server.healthy)\n-          .sort((a, b) => {\n-            const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n-            if (queueDiff !== 0) return queueDiff\n-            return a.priority - b.priority\n-          })\n-      }\n+        // 如果没有健康服务器，选择响应时间最快的\n+        const fastestServer = serverResults\n+          .filter(server => server.responseTime > 0)\n+          .sort((a, b) => a.responseTime - b.responseTime)[0]\n \n-      if (healthyServers.length === 0) {\n-        console.warn('⚠️ 强制更新后仍没有健康的服务器可用')\n-        return await this.fallbackToAnyServer()\n+        if (fastestServer) {\n+          console.log(`🆘 选择响应最快的服务器: ${fastestServer.url} (响应时间: ${fastestServer.responseTime}ms)`)\n+          return fastestServer.url\n+        }\n+\n+        // 最后的备用方案：返回第一个配置的服务器\n+        console.log(`🆘 使用第一个配置的服务器: ${servers[0].url}`)\n+        return servers[0].url\n       }\n \n       const selectedServer = healthyServers[0]\n-      console.log(`✅ 选择服务器: ${selectedServer.url} (队列: ${selectedServer.queue.total || 0})`)\n+      console.log(`✅ 选择服务器: ${selectedServer.url} (队列: ${selectedServer.queue.total || 0}, 优先级: ${selectedServer.priority})`)\n \n-      // 锁定选中的服务器\n-      this.lockServer(selectedServer.url)\n+      // 5. 记录所有服务器状态（用于调试）\n+      this.logServerStatus(serverResults)\n \n       return selectedServer.url\n \n     } catch (error) {\n       console.error('❌ 服务器选择失败:', error)\n-      return await this.fallbackToAnyServer()\n-    }\n-  }\n \n-  /**\n-   * 备用服务器选择\n-   */\n-  async fallbackToAnyServer() {\n-    console.log('🔄 使用备用服务器选择策略...')\n-\n-    // 尝试选择响应时间最快的服务器（即使队列较长）\n-    const serversWithResponse = Array.from(this.serverLoads.values())\n-      .filter(server => server.responseTime > 0) // 至少有响应\n-      .sort((a, b) => {\n-        // 按响应时间排序\n-        return a.responseTime - b.responseTime\n-      })\n-\n-    if (serversWithResponse.length > 0) {\n-      const fastestServer = serversWithResponse[0]\n-      console.log(`🆘 选择响应最快的服务器: ${fastestServer.url} (响应时间: ${fastestServer.responseTime}ms, 队列: ${fastestServer.queue.total || 0})`)\n-      return fastestServer.url\n-    }\n-\n-    // 如果没有响应数据，按优先级返回第一个服务器\n-    if (this.servers.length > 0) {\n-      const fallbackServer = this.servers[0].url\n-      console.log(`🆘 备用服务器: ${fallbackServer}`)\n-      return fallbackServer\n-    }\n-\n-    // 如果没有配置的服务器，尝试多种方式获取默认值\n-    try {\n-      const config = await configService.getConfig()\n-      const defaultServer = config['comfyui.server_url']\n-\n-      if (defaultServer && defaultServer !== 'https://your-comfyui-server.com') {\n-        return defaultServer\n-      }\n-    } catch (error) {\n-      // 忽略配置服务错误\n-    }\n-\n-    // 从本地存储获取\n-    try {\n-      const localConfig = JSON.parse(localStorage.getItem('comfyui_config') || '{}')\n-      if (localConfig.COMFYUI_SERVER_URL) {\n-        return localConfig.COMFYUI_SERVER_URL\n-      }\n-    } catch (error) {\n-      // 忽略本地存储错误\n-    }\n-\n-    // 最后的备用方案\n-    const fallbackUrl = 'https://your-comfyui-server.com'\n-    return fallbackUrl\n-  }\n-\n-  /**\n-   * 锁定服务器（普通HTTP请求）\n-   */\n-  lockServer(serverUrl) {\n-    this.lockedServer = serverUrl\n-    this.lastLockTime = Date.now()\n-  }\n-\n-  /**\n-   * 锁定服务器用于WebSocket连接\n-   */\n-  lockServerForWebSocket(serverUrl) {\n-    this.webSocketLockedServer = serverUrl\n-    this.webSocketLockTime = Date.now()\n-    console.log(`🔒🌐 锁定服务器用于WebSocket: ${serverUrl}, 持续 ${this.webSocketLockDuration / 1000} 秒`)\n-\n-    // 同时设置普通锁定，确保一致性\n-    this.lockServer(serverUrl)\n-  }\n-\n-  /**\n-   * 释放WebSocket服务器锁定\n-   */\n-  unlockWebSocketServer() {\n-    if (this.webSocketLockedServer) {\n-      console.log(`🔓🌐 释放WebSocket服务器锁定: ${this.webSocketLockedServer}`)\n-      this.webSocketLockedServer = null\n-      this.webSocketLockTime = 0\n-    }\n-  }\n-\n-  /**\n-   * 检查WebSocket服务器是否被锁定\n-   */\n-  isWebSocketServerLocked() {\n-    if (!this.webSocketLockedServer) return false\n-\n-    const now = Date.now()\n-    const isLocked = (now - this.webSocketLockTime) < this.webSocketLockDuration\n-\n-    if (!isLocked) {\n-      console.log('🔓🌐 WebSocket服务器锁定已过期')\n-      this.webSocketLockedServer = null\n-      this.webSocketLockTime = 0\n-    }\n-\n-    return isLocked\n-  }\n-\n-  /**\n-   * 获取WebSocket锁定的服务器\n-   */\n-  getWebSocketLockedServer() {\n-    if (this.isWebSocketServerLocked()) {\n-      return this.webSocketLockedServer\n-    }\n-    return null\n-  }\n-\n-  /**\n-   * 检查服务器是否被锁定\n-   */\n-  isServerLocked() {\n-    if (!this.lockedServer) return false\n-\n-    const now = Date.now()\n-    const isLocked = (now - this.lastLockTime) < this.lockDuration\n-\n-    if (!isLocked) {\n-      console.log('🔓 服务器锁定已过期')\n-      this.lockedServer = null\n-      this.lastLockTime = 0\n-    }\n-\n-    return isLocked\n-  }\n-\n-  /**\n-   * 获取锁定的服务器\n-   */\n-  getLockedServer() {\n-    if (this.isServerLocked()) {\n-      return this.lockedServer\n-    }\n-    return null\n-  }\n-\n-  /**\n-   * 记录服务器失败\n-   */\n-  async recordFailure(serverUrl, errorType = 'unknown') {\n-    // 增加失败计数\n-    const currentFailures = this.serverFailures.get(serverUrl) || 0\n-    const newFailures = currentFailures + 1\n-    this.serverFailures.set(serverUrl, newFailures)\n-\n-    // 如果失败的是当前锁定的服务器，立即解除锁定\n-    if (this.lockedServer === serverUrl) {\n-      this.lockedServer = null\n-      this.lastLockTime = 0\n-    }\n-\n-    // 标记服务器为不健康\n-    if (this.serverLoads.has(serverUrl)) {\n-      const serverInfo = this.serverLoads.get(serverUrl)\n-      serverInfo.healthy = false\n-      serverInfo.lastFailure = Date.now()\n-      serverInfo.failureCount = newFailures\n-      serverInfo.lastErrorType = errorType\n-      this.serverLoads.set(serverUrl, serverInfo)\n-    }\n-\n-    // 记录失败但不自动切换，由用户手动决定\n-\n-    // 强制更新服务器负载信息\n-    this.lastUpdateTime = 0\n-  }\n-\n-\n-\n-  /**\n-   * 重置服务器失败计数\n-   */\n-  resetFailureCount(serverUrl) {\n-    if (this.serverFailures.has(serverUrl)) {\n-      console.log(`🔄 重置服务器失败计数: ${serverUrl}`)\n-      this.serverFailures.delete(serverUrl)\n-\n-      // 同时更新服务器负载信息\n-      if (this.serverLoads.has(serverUrl)) {\n-        const serverInfo = this.serverLoads.get(serverUrl)\n-        serverInfo.failureCount = 0\n-        delete serverInfo.lastErrorType\n-        this.serverLoads.set(serverUrl, serverInfo)\n-      }\n-    }\n-  }\n-\n-  /**\n-   * 获取最优服务器（主要接口）\n-   */\n-  async getOptimalServer() {\n-    return await this.selectServerByMinQueue()\n-  }\n-\n-  /**\n-   * 手动触发服务器切换\n-   */\n-  async switchToNextServer() {\n-    console.log('🔄 手动触发服务器切换...')\n-\n-    // 如果当前有锁定的服务器，将其标记为失败\n-    if (this.lockedServer) {\n-      console.log(`📝 标记当前服务器为失败: ${this.lockedServer}`)\n-      await this.recordFailure(this.lockedServer, 'manual_switch')\n-    }\n-\n-    // 强制重新评估并选择新服务器\n-    await this.forceReassessment()\n-    const newServer = await this.selectServerByMinQueue()\n-\n-    console.log(`✅ 手动切换完成，新服务器: ${newServer}`)\n-    return newServer\n-  }\n-\n-  /**\n-   * 获取下一个可用服务器（不锁定）\n-   */\n-  async getNextAvailableServer(excludeUrls = []) {\n-    await this.updateServerLoads()\n-\n-    const availableServers = Array.from(this.serverLoads.values())\n-      .filter(server => {\n-        if (!server.healthy) return false\n-        if (excludeUrls.includes(server.url)) return false\n-\n-        const failures = this.serverFailures.get(server.url) || 0\n-        return failures < this.failureThreshold\n-      })\n-      .sort((a, b) => {\n-        const failureA = this.serverFailures.get(a.url) || 0\n-        const failureB = this.serverFailures.get(b.url) || 0\n-        if (failureA !== failureB) return failureA - failureB\n-\n-        const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n-        if (queueDiff !== 0) return queueDiff\n-\n-        return a.priority - b.priority\n-      })\n-\n-    return availableServers.length > 0 ? availableServers[0].url : null\n-  }\n-\n-  /**\n-   * 强制重新评估所有服务器\n-   */\n-  async forceReassessment() {\n-    console.log('🔄 强制重新评估所有服务器...')\n-\n-    // 清除锁定状态\n-    this.lockedServer = null\n-    this.lastLockTime = 0\n-\n-    // 重置所有服务器的失败计数（给它们一个重新开始的机会）\n-    console.log('🔄 重置所有服务器失败计数')\n-    this.serverFailures.clear()\n-\n-    // 强制更新负载信息\n-    await this.updateServerLoads(true)\n-\n-    // 显示当前状态\n-    this.logServerStatus()\n-\n-    console.log('✅ 服务器重新评估完成')\n-  }\n-\n-  /**\n-   * 显示服务器状态\n-   */\n-  logServerStatus() {\n-    console.log('📊 当前所有服务器状态:')\n-    for (const [url, info] of this.serverLoads.entries()) {\n-      const status = info.healthy ? '✅' : '❌'\n-      const queueInfo = info.queue ?\n-        `队列:${info.queue.total || 0}(运行:${info.queue.running || 0},等待:${info.queue.pending || 0})` :\n-        '队列:未知'\n-      const locked = url === this.lockedServer ? '🔒' : ''\n-      const priority = `优先级:${info.priority}`\n-      const responseTime = info.responseTime ? `响应:${info.responseTime}ms` : '响应:未知'\n-      const lastCheck = info.lastCheck ? `检查:${Math.round((Date.now() - info.lastCheck) / 1000)}s前` : '检查:从未'\n-      const failures = this.serverFailures.get(url) || 0\n-      const failureInfo = failures > 0 ? `失败:${failures}次` : ''\n-      const errorType = info.lastErrorType ? `错误:${info.lastErrorType}` : ''\n-      console.log(`   ${status} ${url} ${queueInfo} ${priority} ${responseTime} ${lastCheck} ${failureInfo} ${errorType} ${locked}`)\n-    }\n-  }\n-\n-  /**\n-   * 获取服务器统计信息\n-   */\n-  getServerStats() {\n-    const stats = {\n-      total: this.servers.length,\n-      healthy: 0,\n-      locked: this.lockedServer,\n-      servers: []\n-    }\n-\n-    for (const [url, info] of this.serverLoads.entries()) {\n-      if (info.healthy) stats.healthy++\n-\n-      stats.servers.push({\n-        url,\n-        healthy: info.healthy,\n-        queue: info.queue.total || 0,\n-        priority: info.priority,\n-        type: info.type,\n-        locked: url === this.lockedServer\n-      })\n-    }\n-\n-    return stats\n-  }\n-\n-  /**\n-   * 启动健康监控\n-   */\n-  startHealthMonitoring() {\n-    if (this.healthMonitorInterval) {\n-      clearInterval(this.healthMonitorInterval)\n-    }\n-\n-    console.log(`🏥 启动健康监控，检查频率: ${this.healthMonitorFrequency / 1000}秒`)\n-\n-    this.healthMonitorInterval = setInterval(async () => {\n+      // 错误时的备用方案\n       try {\n-        await this.performHealthMonitoring()\n-      } catch (error) {\n-        console.error('❌ 健康监控出错:', error)\n+        const config = await configService.getConfig()\n+        const fallbackUrl = config['comfyui.server_url'] || 'https://your-comfyui-server.com'\n+        console.log(`🆘 使用备用服务器: ${fallbackUrl}`)\n+        return fallbackUrl\n+      } catch (configError) {\n+        console.error('❌ 获取备用服务器配置失败:', configError)\n+        return 'https://your-comfyui-server.com'\n       }\n-    }, this.healthMonitorFrequency)\n-  }\n-\n-  /**\n-   * 停止健康监控\n-   */\n-  stopHealthMonitoring() {\n-    if (this.healthMonitorInterval) {\n-      console.log('🛑 停止健康监控')\n-      clearInterval(this.healthMonitorInterval)\n-      this.healthMonitorInterval = null\n     }\n   }\n \n   /**\n-   * 执行健康监控\n+   * 记录服务器状态（用于调试）\n    */\n-  async performHealthMonitoring() {\n-    // 更新服务器负载信息\n-    await this.updateServerLoads()\n+  logServerStatus(servers) {\n+    console.log('📊 服务器状态详情:')\n+    console.log('   状态 | 服务器URL | 队列 | 优先级 | 响应时间')\n+    console.log('   -----|-----------|------|--------|----------')\n \n-    // 检查当前锁定的服务器是否仍然健康\n-    if (this.lockedServer) {\n-      const lockedServerInfo = this.serverLoads.get(this.lockedServer)\n-      if (lockedServerInfo && !lockedServerInfo.healthy) {\n-        this.lockedServer = null\n-        this.lastLockTime = 0\n-      }\n-    }\n+    servers.forEach(server => {\n+      const status = server.healthy ? '✅' : '❌'\n+      const queueInfo = server.queue ? `${server.queue.total || 0}` : 'N/A'\n+      const priority = server.priority || 'N/A'\n+      const responseTime = server.responseTime ? `${server.responseTime}ms` : 'N/A'\n \n-    // 检查是否有服务器从故障中恢复\n-    const healthyServers = Array.from(this.serverLoads.values())\n-      .filter(server => server.healthy)\n-\n-    // 只在没有健康服务器时输出警告\n-    if (healthyServers.length === 0) {\n-      console.warn('警告：没有发现健康的ComfyUI服务器')\n-    }\n+      console.log(`   ${status} | ${server.url} | ${queueInfo} | ${priority} | ${responseTime}`)\n+    })\n   }\n-\n-  /**\n-   * 销毁负载均衡器\n-   */\n-  destroy() {\n-    this.stopHealthMonitoring()\n-    this.servers = []\n-    this.serverLoads.clear()\n-    this.serverFailures.clear()\n-    this.lockedServer = null\n-  }\n }\n \n // 创建单例实例\n const loadBalancer = new ComfyUILoadBalancer()\n"
                },
                {
                    "date": 1752513434979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -191,10 +191,15 @@\n       if (servers.length === 0) {\n         throw new Error('没有可用的服务器配置')\n       }\n \n+      console.log(`📋 发现 ${servers.length} 个配置的服务器:`)\n+      servers.forEach((server, index) => {\n+        console.log(`   ${index + 1}. ${server.url} (${server.type}, 优先级: ${server.priority})`)\n+      })\n+\n       // 2. 并行检查所有服务器的健康状态和队列信息\n-      console.log('🔍 检查所有服务器状态...')\n+      console.log('🔍 正在测试所有服务器的健康状态和队列信息...')\n       const serverChecks = servers.map(async (server) => {\n         try {\n           const [healthResult, queueResult] = await Promise.allSettled([\n             this.checkServerHealth(server.url),\n@@ -203,21 +208,30 @@\n \n           const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n           const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n \n+          // 输出每个服务器的测试结果\n+          if (health.healthy) {\n+            console.log(`✅ ${server.url} - 健康 (响应时间: ${health.responseTime}ms, 队列: ${queue.total || 0})`)\n+          } else {\n+            console.log(`❌ ${server.url} - 不可用 (${health.error || '连接失败'})`)\n+          }\n+\n           return {\n             ...server,\n             healthy: health.healthy,\n             queue: queue,\n-            responseTime: health.responseTime || 0\n+            responseTime: health.responseTime || 0,\n+            error: health.error\n           }\n         } catch (error) {\n           console.error(`❌ 检查服务器 ${server.url} 失败:`, error)\n           return {\n             ...server,\n             healthy: false,\n             queue: { total: 999, healthy: false },\n-            responseTime: 0\n+            responseTime: 0,\n+            error: error.message\n           }\n         }\n       })\n \n"
                },
                {
                    "date": 1752513464083,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -236,9 +236,15 @@\n       })\n \n       const serverResults = await Promise.all(serverChecks)\n \n-      // 3. 过滤健康的服务器并按队列长度排序\n+      // 3. 显示测试结果汇总\n+      const healthyCount = serverResults.filter(s => s.healthy).length\n+      const unhealthyCount = serverResults.length - healthyCount\n+\n+      console.log(`📊 服务器测试结果汇总: ${healthyCount} 个健康, ${unhealthyCount} 个不可用`)\n+\n+      // 4. 过滤健康的服务器并按队列长度排序\n       const healthyServers = serverResults\n         .filter(server => server.healthy)\n         .sort((a, b) => {\n           // 按队列数量排序\n@@ -248,9 +254,9 @@\n           // 如果队列相同，按优先级排序\n           return a.priority - b.priority\n         })\n \n-      // 4. 选择最优服务器\n+      // 5. 选择最优服务器\n       if (healthyServers.length === 0) {\n         console.warn('⚠️ 没有健康的服务器可用，尝试使用响应最快的服务器')\n \n         // 如果没有健康服务器，选择响应时间最快的\n@@ -258,21 +264,29 @@\n           .filter(server => server.responseTime > 0)\n           .sort((a, b) => a.responseTime - b.responseTime)[0]\n \n         if (fastestServer) {\n-          console.log(`🆘 选择响应最快的服务器: ${fastestServer.url} (响应时间: ${fastestServer.responseTime}ms)`)\n+          console.log(`🆘 最终选择: ${fastestServer.url}`)\n+          console.log(`   原因: 响应最快的服务器 (${fastestServer.responseTime}ms)`)\n+          console.log(`   状态: 可能不稳定，建议检查服务器配置`)\n           return fastestServer.url\n         }\n \n         // 最后的备用方案：返回第一个配置的服务器\n-        console.log(`🆘 使用第一个配置的服务器: ${servers[0].url}`)\n+        console.log(`🆘 最终选择: ${servers[0].url}`)\n+        console.log(`   原因: 备用方案 - 使用第一个配置的服务器`)\n+        console.log(`   状态: 未知，可能无法正常工作`)\n         return servers[0].url\n       }\n \n       const selectedServer = healthyServers[0]\n-      console.log(`✅ 选择服务器: ${selectedServer.url} (队列: ${selectedServer.queue.total || 0}, 优先级: ${selectedServer.priority})`)\n+      console.log(`🎯 最终选择: ${selectedServer.url}`)\n+      console.log(`   类型: ${selectedServer.type === 'primary' ? '主服务器' : '备用服务器'}`)\n+      console.log(`   队列数: ${selectedServer.queue.total || 0} (运行中: ${selectedServer.queue.running || 0}, 等待中: ${selectedServer.queue.pending || 0})`)\n+      console.log(`   响应时间: ${selectedServer.responseTime}ms`)\n+      console.log(`   优先级: ${selectedServer.priority}`)\n \n-      // 5. 记录所有服务器状态（用于调试）\n+      // 6. 记录所有服务器状态（用于调试）\n       this.logServerStatus(serverResults)\n \n       return selectedServer.url\n \n"
                },
                {
                    "date": 1752513482671,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -309,20 +309,26 @@\n   /**\n    * 记录服务器状态（用于调试）\n    */\n   logServerStatus(servers) {\n-    console.log('📊 服务器状态详情:')\n-    console.log('   状态 | 服务器URL | 队列 | 优先级 | 响应时间')\n-    console.log('   -----|-----------|------|--------|----------')\n+    console.log('📊 详细服务器状态报告:')\n+    console.log('   状态 | 类型 | 服务器URL | 队列(运行/等待/总计) | 优先级 | 响应时间 | 错误信息')\n+    console.log('   -----|------|-----------|-------------------|--------|----------|----------')\n \n     servers.forEach(server => {\n       const status = server.healthy ? '✅' : '❌'\n-      const queueInfo = server.queue ? `${server.queue.total || 0}` : 'N/A'\n+      const type = server.type === 'primary' ? '主服务器' : '备用'\n+      const queueInfo = server.queue ?\n+        `${server.queue.running || 0}/${server.queue.pending || 0}/${server.queue.total || 0}` :\n+        'N/A'\n       const priority = server.priority || 'N/A'\n       const responseTime = server.responseTime ? `${server.responseTime}ms` : 'N/A'\n+      const error = server.error ? server.error.substring(0, 20) + '...' : ''\n \n-      console.log(`   ${status} | ${server.url} | ${queueInfo} | ${priority} | ${responseTime}`)\n+      console.log(`   ${status} | ${type} | ${server.url} | ${queueInfo} | ${priority} | ${responseTime} | ${error}`)\n     })\n+\n+    console.log('') // 空行分隔\n   }\n }\n \n // 创建单例实例\n"
                },
                {
                    "date": 1752513513334,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -306,8 +306,87 @@\n     }\n   }\n \n   /**\n+   * 页面加载时初始化服务器连接测试\n+   * 提供详细的服务器状态反馈\n+   */\n+  async initializeServerConnection() {\n+    try {\n+      console.log('🚀 正在初始化 ComfyUI 服务器连接...')\n+\n+      // 获取服务器列表\n+      const servers = await this.getLatestServerList()\n+\n+      if (servers.length === 0) {\n+        console.warn('⚠️ 未找到任何配置的服务器')\n+        return null\n+      }\n+\n+      console.log(`📋 发现 ${servers.length} 个配置的服务器，开始连接测试...`)\n+\n+      // 测试所有服务器\n+      const serverChecks = servers.map(async (server) => {\n+        console.log(`🔍 测试服务器: ${server.url}`)\n+\n+        try {\n+          const [healthResult, queueResult] = await Promise.allSettled([\n+            this.checkServerHealth(server.url),\n+            this.getServerQueueInfo(server.url)\n+          ])\n+\n+          const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n+          const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n+\n+          return {\n+            ...server,\n+            healthy: health.healthy,\n+            queue: queue,\n+            responseTime: health.responseTime || 0,\n+            error: health.error\n+          }\n+        } catch (error) {\n+          return {\n+            ...server,\n+            healthy: false,\n+            queue: { total: 999, healthy: false },\n+            responseTime: 0,\n+            error: error.message\n+          }\n+        }\n+      })\n+\n+      const serverResults = await Promise.all(serverChecks)\n+\n+      // 输出测试结果\n+      const healthyServers = serverResults.filter(s => s.healthy)\n+      console.log(`✅ 服务器连接测试完成: ${healthyServers.length}/${serverResults.length} 个服务器可用`)\n+\n+      // 选择最优服务器\n+      if (healthyServers.length > 0) {\n+        const bestServer = healthyServers.sort((a, b) => {\n+          const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n+          if (queueDiff !== 0) return queueDiff\n+          return a.priority - b.priority\n+        })[0]\n+\n+        console.log(`🎯 推荐服务器: ${bestServer.url}`)\n+        console.log(`   队列状态: ${bestServer.queue.total || 0} 个任务 (运行中: ${bestServer.queue.running || 0}, 等待中: ${bestServer.queue.pending || 0})`)\n+        console.log(`   响应时间: ${bestServer.responseTime}ms`)\n+\n+        return bestServer.url\n+      } else {\n+        console.warn('❌ 所有服务器都不可用，请检查服务器配置')\n+        return null\n+      }\n+\n+    } catch (error) {\n+      console.error('❌ 服务器初始化失败:', error)\n+      return null\n+    }\n+  }\n+\n+  /**\n    * 记录服务器状态（用于调试）\n    */\n   logServerStatus(servers) {\n     console.log('📊 详细服务器状态报告:')\n"
                },
                {
                    "date": 1752514056455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,37 +89,68 @@\n   }\n \n   /**\n    * 检查服务器健康状态\n+   * 尝试多个端点来确保准确检测\n    */\n   async checkServerHealth(serverUrl) {\n-    try {\n-      const controller = new AbortController()\n-      const timeoutId = setTimeout(() => controller.abort(), this.healthCheckTimeout)\n+    // 要测试的端点列表，按优先级排序\n+    const testEndpoints = [\n+      '/queue',        // ComfyUI 队列端点，最常用\n+      '/system_stats', // ComfyUI 系统状态端点\n+      '/history',      // ComfyUI 历史记录端点\n+      '/'              // 根路径，最后尝试\n+    ]\n \n-      const startTime = Date.now()\n-      const response = await fetch(`${serverUrl}/system_stats`, {\n-        method: 'GET',\n-        signal: controller.signal,\n-        headers: {\n-          'Cache-Control': 'no-cache'\n-        }\n-      })\n-      const endTime = Date.now()\n+    let lastError = null\n+    const startTime = Date.now()\n \n-      clearTimeout(timeoutId)\n+    for (const endpoint of testEndpoints) {\n+      try {\n+        const controller = new AbortController()\n+        const timeoutId = setTimeout(() => controller.abort(), this.healthCheckTimeout)\n \n-      return {\n-        healthy: response.ok,\n-        responseTime: endTime - startTime,\n-        status: response.status\n+        console.log(`🔍 测试端点: ${serverUrl}${endpoint}`)\n+\n+        const response = await fetch(`${serverUrl}${endpoint}`, {\n+          method: 'GET',\n+          signal: controller.signal,\n+          headers: {\n+            'Cache-Control': 'no-cache',\n+            'Accept': 'application/json, text/plain, */*'\n+          }\n+        })\n+\n+        clearTimeout(timeoutId)\n+        const endTime = Date.now()\n+\n+        // 如果响应成功，认为服务器健康\n+        if (response.ok) {\n+          console.log(`✅ 端点 ${endpoint} 响应成功 (${response.status})`)\n+          return {\n+            healthy: true,\n+            responseTime: endTime - startTime,\n+            status: response.status,\n+            endpoint: endpoint\n+          }\n+        } else {\n+          console.log(`⚠️ 端点 ${endpoint} 响应失败 (${response.status})`)\n+          lastError = `HTTP ${response.status}`\n+        }\n+      } catch (error) {\n+        console.log(`❌ 端点 ${endpoint} 连接失败: ${error.message}`)\n+        lastError = error.message\n+        continue\n       }\n-    } catch (error) {\n-      return {\n-        healthy: false,\n-        error: error.message\n-      }\n     }\n+\n+    // 所有端点都失败\n+    const endTime = Date.now()\n+    return {\n+      healthy: false,\n+      responseTime: endTime - startTime,\n+      error: lastError || '所有端点都无法访问'\n+    }\n   }\n \n   /**\n    * 获取服务器队列信息\n"
                },
                {
                    "date": 1752514084198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -159,36 +159,53 @@\n     try {\n       const controller = new AbortController()\n       const timeoutId = setTimeout(() => controller.abort(), this.queueCheckTimeout)\n \n+      console.log(`📊 获取服务器队列信息: ${serverUrl}/queue`)\n+\n       const response = await fetch(`${serverUrl}/queue`, {\n         method: 'GET',\n         signal: controller.signal,\n         headers: {\n-          'Content-Type': 'application/json',\n+          'Accept': 'application/json, text/plain, */*',\n           'Cache-Control': 'no-cache'\n         }\n       })\n \n       clearTimeout(timeoutId)\n \n       if (response.ok) {\n-        const queueData = await response.json()\n-        console.log(`📊 服务器 ${serverUrl} 队列数据:`, queueData)\n+        try {\n+          const queueData = await response.json()\n+          console.log(`📊 服务器 ${serverUrl} 队列数据:`, queueData)\n \n-        // ComfyUI 队列 API 返回格式: { queue_running: [...], queue_pending: [...] }\n-        const running = queueData.queue_running ? queueData.queue_running.length : 0\n-        const pending = queueData.queue_pending ? queueData.queue_pending.length : 0\n-        const total = running + pending\n+          // ComfyUI 队列 API 返回格式: { queue_running: [...], queue_pending: [...] }\n+          const running = queueData.queue_running ? queueData.queue_running.length : 0\n+          const pending = queueData.queue_pending ? queueData.queue_pending.length : 0\n+          const total = running + pending\n \n-        return {\n-          running,\n-          pending,\n-          total,\n-          healthy: true\n+          console.log(`📊 队列统计 - 运行中: ${running}, 等待中: ${pending}, 总计: ${total}`)\n+\n+          return {\n+            running,\n+            pending,\n+            total,\n+            healthy: true\n+          }\n+        } catch (parseError) {\n+          console.warn(`⚠️ 解析队列数据失败:`, parseError.message)\n+          // 如果能连接但无法解析JSON，说明服务器可用但可能返回了非标准格式\n+          return {\n+            running: 0,\n+            pending: 0,\n+            total: 1, // 使用1而不是0，避免所有用户都选择这个服务器\n+            healthy: true,\n+            isEstimate: true\n+          }\n         }\n       } else {\n         console.warn(`⚠️ 服务器 ${serverUrl} 队列API返回状态码: ${response.status}`)\n+        // 如果队列API不可用但服务器可达，使用估算值\n         return {\n           running: 0,\n           pending: 0,\n           total: 1, // 使用1而不是0，避免所有用户都选择这个服务器\n@@ -202,9 +219,10 @@\n       return {\n         running: 0,\n         pending: 0,\n         total: 999, // 高值表示不可用\n-        healthy: false\n+        healthy: false,\n+        error: error.message\n       }\n     }\n   }\n \n"
                },
                {
                    "date": 1752514111667,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -385,14 +385,18 @@\n \n           const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n           const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n \n+          // 更智能的健康判断：如果健康检查通过，即使队列信息获取失败也认为服务器可用\n+          const isHealthy = health.healthy || (health.responseTime > 0 && health.responseTime < 30000)\n+\n           return {\n             ...server,\n-            healthy: health.healthy,\n+            healthy: isHealthy,\n             queue: queue,\n             responseTime: health.responseTime || 0,\n-            error: health.error\n+            error: health.error,\n+            healthCheckEndpoint: health.endpoint\n           }\n         } catch (error) {\n           return {\n             ...server,\n"
                },
                {
                    "date": 1752514996447,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,16 +68,25 @@\n       }\n \n       // 如果没有配置服务器，使用默认配置\n       if (servers.length === 0) {\n-        const localConfig = JSON.parse(localStorage.getItem('comfyui_config') || '{}')\n-        const defaultUrl = localConfig.COMFYUI_SERVER_URL || 'https://your-comfyui-server.com'\n+        console.warn('⚠️ 未找到配置的服务器，使用默认服务器列表')\n \n-        servers.push({\n-          url: defaultUrl,\n-          type: 'primary',\n-          priority: 1\n-        })\n+        // 使用更新后的默认服务器列表\n+        const defaultServers = [\n+          {\n+            url: 'https://l9s75ay3rp-8188.cnb.run',\n+            type: 'primary',\n+            priority: 1\n+          },\n+          {\n+            url: 'https://0rv00xh2vg-8188.cnb.run',\n+            type: 'backup',\n+            priority: 2\n+          }\n+        ]\n+\n+        servers.push(...defaultServers)\n       }\n \n       console.log(`✅ 获取到 ${servers.length} 个服务器:`, servers.map(s => s.url))\n       return servers\n"
                },
                {
                    "date": 1752515252979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -224,13 +224,15 @@\n       }\n \n     } catch (error) {\n       console.warn(`⚠️ 获取服务器 ${serverUrl} 队列信息失败:`, error.message)\n+      // 如果队列信息获取失败，但服务器可能仍然健康，使用估算值\n       return {\n         running: 0,\n         pending: 0,\n-        total: 999, // 高值表示不可用\n-        healthy: false,\n+        total: 1, // 使用较低的估算值，避免影响服务器选择\n+        healthy: true, // 队列信息获取失败不代表服务器不健康\n+        isEstimate: true,\n         error: error.message\n       }\n     }\n   }\n"
                },
                {
                    "date": 1752515273206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -394,13 +394,24 @@\n             this.getServerQueueInfo(server.url)\n           ])\n \n           const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n-          const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n+          const queue = queueResult.status === 'fulfilled' ? queueResult.value : {\n+            total: 1,\n+            running: 0,\n+            pending: 0,\n+            healthy: true,\n+            isEstimate: true\n+          }\n \n-          // 更智能的健康判断：如果健康检查通过，即使队列信息获取失败也认为服务器可用\n-          const isHealthy = health.healthy || (health.responseTime > 0 && health.responseTime < 30000)\n+          // 服务器健康状态主要基于健康检查结果\n+          const isHealthy = health.healthy\n \n+          // 如果队列信息获取失败但服务器健康，给出警告但不影响选择\n+          if (isHealthy && queue.isEstimate) {\n+            console.warn(`⚠️ ${server.url} 健康但队列信息不可用，使用估算值`)\n+          }\n+\n           return {\n             ...server,\n             healthy: isHealthy,\n             queue: queue,\n"
                },
                {
                    "date": 1752515450042,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -183,16 +183,52 @@\n       clearTimeout(timeoutId)\n \n       if (response.ok) {\n         try {\n-          const queueData = await response.json()\n-          console.log(`📊 服务器 ${serverUrl} 队列数据:`, queueData)\n+          const responseText = await response.text()\n+          console.log(`📊 队列API原始响应: ${responseText.substring(0, 200)}...`)\n \n-          // ComfyUI 队列 API 返回格式: { queue_running: [...], queue_pending: [...] }\n-          const running = queueData.queue_running ? queueData.queue_running.length : 0\n-          const pending = queueData.queue_pending ? queueData.queue_pending.length : 0\n+          const queueData = JSON.parse(responseText)\n+          console.log(`📊 服务器 ${serverUrl} 队列数据结构:`, Object.keys(queueData))\n+\n+          // 尝试多种可能的数据格式\n+          let running = 0\n+          let pending = 0\n+\n+          // 标准 ComfyUI 格式\n+          if (queueData.queue_running !== undefined && queueData.queue_pending !== undefined) {\n+            running = Array.isArray(queueData.queue_running) ? queueData.queue_running.length :\n+                     (typeof queueData.queue_running === 'number' ? queueData.queue_running : 0)\n+            pending = Array.isArray(queueData.queue_pending) ? queueData.queue_pending.length :\n+                     (typeof queueData.queue_pending === 'number' ? queueData.queue_pending : 0)\n+          }\n+          // 其他可能的格式\n+          else if (queueData.running !== undefined && queueData.pending !== undefined) {\n+            running = typeof queueData.running === 'number' ? queueData.running : 0\n+            pending = typeof queueData.pending === 'number' ? queueData.pending : 0\n+          }\n+          // 如果有 exec_info\n+          else if (queueData.exec_info) {\n+            running = queueData.exec_info.queue_remaining || 0\n+            pending = 0\n+          }\n+          // 简单的数字格式\n+          else if (typeof queueData === 'number') {\n+            running = 0\n+            pending = queueData\n+          }\n+          // 如果有 queue 字段\n+          else if (queueData.queue) {\n+            if (Array.isArray(queueData.queue)) {\n+              pending = queueData.queue.length\n+              running = 0\n+            } else if (typeof queueData.queue === 'number') {\n+              pending = queueData.queue\n+              running = 0\n+            }\n+          }\n+\n           const total = running + pending\n-\n           console.log(`📊 队列统计 - 运行中: ${running}, 等待中: ${pending}, 总计: ${total}`)\n \n           return {\n             running,\n"
                },
                {
                    "date": 1752515705165,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -98,16 +98,17 @@\n   }\n \n   /**\n    * 检查服务器健康状态\n-   * 尝试多个端点来确保准确检测\n+   * 基于 ComfyUI 官方文档的端点进行检测\n    */\n   async checkServerHealth(serverUrl) {\n-    // 要测试的端点列表，按优先级排序\n+    // 基于官方文档的端点列表，按优先级排序\n     const testEndpoints = [\n-      '/queue',        // ComfyUI 队列端点，最常用\n-      '/system_stats', // ComfyUI 系统状态端点\n-      '/history',      // ComfyUI 历史记录端点\n+      '/system_stats', // 官方推荐的系统状态端点\n+      '/queue',        // 队列状态端点\n+      '/object_info',  // 节点信息端点\n+      '/prompt',       // 提示状态端点\n       '/'              // 根路径，最后尝试\n     ]\n \n     let lastError = null\n"
                },
                {
                    "date": 1752515722092,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -124,10 +124,11 @@\n         const response = await fetch(`${serverUrl}${endpoint}`, {\n           method: 'GET',\n           signal: controller.signal,\n           headers: {\n+            'Accept': 'application/json, text/html, text/plain, */*',\n             'Cache-Control': 'no-cache',\n-            'Accept': 'application/json, text/plain, */*'\n+            'User-Agent': 'ComfyUI-LoadBalancer/1.0'\n           }\n         })\n \n         clearTimeout(timeoutId)\n"
                },
                {
                    "date": 1752515737613,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -176,10 +176,11 @@\n       const response = await fetch(`${serverUrl}/queue`, {\n         method: 'GET',\n         signal: controller.signal,\n         headers: {\n-          'Accept': 'application/json, text/plain, */*',\n-          'Cache-Control': 'no-cache'\n+          'Accept': 'application/json, text/html, text/plain, */*',\n+          'Cache-Control': 'no-cache',\n+          'User-Agent': 'ComfyUI-LoadBalancer/1.0'\n         }\n       })\n \n       clearTimeout(timeoutId)\n"
                },
                {
                    "date": 1752516060851,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -101,15 +101,17 @@\n    * 检查服务器健康状态\n    * 基于 ComfyUI 官方文档的端点进行检测\n    */\n   async checkServerHealth(serverUrl) {\n-    // 基于官方文档的端点列表，按优先级排序\n+    // 基于实际服务器的端点列表，按优先级排序\n     const testEndpoints = [\n-      '/system_stats', // 官方推荐的系统状态端点\n-      '/queue',        // 队列状态端点\n-      '/object_info',  // 节点信息端点\n-      '/prompt',       // 提示状态端点\n-      '/'              // 根路径，最后尝试\n+      '/api/queue',        // 实际的队列端点路径\n+      '/api/system_stats', // 系统状态端点\n+      '/api/object_info',  // 节点信息端点\n+      '/api/prompt',       // 提示状态端点\n+      '/queue',            // 备用标准路径\n+      '/system_stats',     // 备用标准路径\n+      '/'                  // 根路径，最后尝试\n     ]\n \n     let lastError = null\n     const startTime = Date.now()\n"
                },
                {
                    "date": 1752516082605,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,11 +126,12 @@\n         const response = await fetch(`${serverUrl}${endpoint}`, {\n           method: 'GET',\n           signal: controller.signal,\n           headers: {\n-            'Accept': 'application/json, text/html, text/plain, */*',\n-            'Cache-Control': 'no-cache',\n-            'User-Agent': 'ComfyUI-LoadBalancer/1.0'\n+            'Accept': '*/*',\n+            'Cache-Control': 'max-age=0',\n+            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36',\n+            'comfy-user': 'loadbalancer-client'\n           }\n         })\n \n         clearTimeout(timeoutId)\n"
                },
                {
                    "date": 1752516100266,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -175,15 +175,16 @@\n       const timeoutId = setTimeout(() => controller.abort(), this.queueCheckTimeout)\n \n       console.log(`📊 获取服务器队列信息: ${serverUrl}/queue`)\n \n-      const response = await fetch(`${serverUrl}/queue`, {\n+      const response = await fetch(`${serverUrl}/api/queue`, {\n         method: 'GET',\n         signal: controller.signal,\n         headers: {\n-          'Accept': 'application/json, text/html, text/plain, */*',\n-          'Cache-Control': 'no-cache',\n-          'User-Agent': 'ComfyUI-LoadBalancer/1.0'\n+          'Accept': '*/*',\n+          'Cache-Control': 'max-age=0',\n+          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36',\n+          'comfy-user': 'loadbalancer-client'\n         }\n       })\n \n       clearTimeout(timeoutId)\n"
                },
                {
                    "date": 1752517076730,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -280,8 +280,157 @@\n     }\n   }\n \n   /**\n+   * 页面加载时初始化服务器连接测试\n+   * 提供详细的服务器状态反馈\n+   */\n+  async initializeServerConnection() {\n+    try {\n+      console.log('🚀 正在初始化 ComfyUI 服务器连接...')\n+      console.log('=' .repeat(60))\n+\n+      // 获取服务器列表\n+      const servers = await this.getLatestServerList()\n+\n+      if (servers.length === 0) {\n+        console.warn('⚠️ 未找到任何配置的服务器')\n+        return null\n+      }\n+\n+      console.log(`📋 发现 ${servers.length} 个配置的服务器:`)\n+      servers.forEach((server, index) => {\n+        console.log(`   ${index + 1}. ${server.url} (${server.type === 'primary' ? '主服务器' : '备用服务器'}, 优先级: ${server.priority})`)\n+      })\n+      console.log('')\n+\n+      console.log('🔍 开始服务器连接和队列测试...')\n+      console.log('-' .repeat(60))\n+\n+      // 测试所有服务器\n+      const serverChecks = servers.map(async (server) => {\n+        console.log(`\\n🖥️  测试服务器: ${server.url}`)\n+        console.log(`   类型: ${server.type === 'primary' ? '主服务器' : '备用服务器'} | 优先级: ${server.priority}`)\n+\n+        try {\n+          const [healthResult, queueResult] = await Promise.allSettled([\n+            this.checkServerHealth(server.url),\n+            this.getServerQueueInfo(server.url)\n+          ])\n+\n+          const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n+          const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n+\n+          // 更智能的健康判断\n+          const isHealthy = health.healthy || (health.responseTime > 0 && health.responseTime < 30000)\n+\n+          // 详细输出测试结果\n+          if (isHealthy) {\n+            console.log(`   ✅ 健康检查: 通过 (${health.responseTime}ms)`)\n+            if (health.endpoint) {\n+              console.log(`   🔗 可用端点: ${health.endpoint}`)\n+            }\n+          } else {\n+            console.log(`   ❌ 健康检查: 失败 (${health.error || '连接失败'})`)\n+          }\n+\n+          // 队列信息详细输出\n+          if (queue.healthy) {\n+            console.log(`   📊 队列信息: 运行中 ${queue.running || 0} | 等待中 ${queue.pending || 0} | 总计 ${queue.total || 0}`)\n+            if (queue.isEstimate) {\n+              console.log(`   ⚠️  队列数据为估算值`)\n+            }\n+          } else {\n+            console.log(`   ❌ 队列信息: 获取失败 (${queue.error || '连接失败'})`)\n+          }\n+\n+          // 服务器状态总结\n+          if (isHealthy) {\n+            const queueStatus = queue.total === 0 ? '🟢 空闲' :\n+                              queue.running > 0 ? '🟡 繁忙' : '🔴 队列满'\n+            console.log(`   📈 服务器状态: ${queueStatus}`)\n+          } else {\n+            console.log(`   📈 服务器状态: 🔴 不可用`)\n+          }\n+\n+          return {\n+            ...server,\n+            healthy: isHealthy,\n+            queue: queue,\n+            responseTime: health.responseTime || 0,\n+            error: health.error,\n+            healthCheckEndpoint: health.endpoint\n+          }\n+        } catch (error) {\n+          console.log(`   ❌ 测试失败: ${error.message}`)\n+          return {\n+            ...server,\n+            healthy: false,\n+            queue: { total: 999, healthy: false },\n+            responseTime: 0,\n+            error: error.message\n+          }\n+        }\n+      })\n+\n+      const serverResults = await Promise.all(serverChecks)\n+\n+      // 输出测试结果汇总\n+      console.log('\\n' + '=' .repeat(60))\n+      const healthyServers = serverResults.filter(s => s.healthy)\n+      console.log(`📊 服务器连接测试完成: ${healthyServers.length}/${serverResults.length} 个服务器可用`)\n+\n+      // 详细的服务器状态表格\n+      console.log('\\n📋 服务器状态汇总:')\n+      console.log('   状态 | 类型     | 服务器URL                    | 队列(运行/等待/总计) | 响应时间')\n+      console.log('   -----|----------|------------------------------|---------------------|----------')\n+\n+      serverResults.forEach(server => {\n+        const status = server.healthy ? '✅' : '❌'\n+        const type = server.type === 'primary' ? '主服务器' : '备用    '\n+        const url = server.url.length > 28 ? server.url.substring(0, 25) + '...' : server.url.padEnd(28)\n+        const queueInfo = server.queue ?\n+          `${(server.queue.running || 0).toString().padStart(2)}/${(server.queue.pending || 0).toString().padStart(2)}/${(server.queue.total || 0).toString().padStart(2)}`.padEnd(19) :\n+          'N/A'.padEnd(19)\n+        const responseTime = server.responseTime ? `${server.responseTime}ms` : 'N/A'\n+\n+        console.log(`   ${status} | ${type} | ${url} | ${queueInfo} | ${responseTime}`)\n+      })\n+\n+      // 选择最优服务器\n+      if (healthyServers.length > 0) {\n+        const bestServer = healthyServers.sort((a, b) => {\n+          const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n+          if (queueDiff !== 0) return queueDiff\n+          return a.priority - b.priority\n+        })[0]\n+\n+        console.log('\\n🎯 最优服务器选择结果:')\n+        console.log(`   选择服务器: ${bestServer.url}`)\n+        console.log(`   选择原因: ${bestServer.type === 'primary' ? '主服务器' : '备用服务器'} | 队列最少 (${bestServer.queue.total || 0} 个任务)`)\n+        console.log(`   队列详情: 运行中 ${bestServer.queue.running || 0} | 等待中 ${bestServer.queue.pending || 0}`)\n+        console.log(`   响应时间: ${bestServer.responseTime}ms`)\n+        console.log(`   优先级: ${bestServer.priority}`)\n+\n+        console.log('\\n✅ 服务器初始化完成，系统已准备就绪！')\n+        console.log('=' .repeat(60))\n+\n+        return bestServer.url\n+      } else {\n+        console.log('\\n❌ 服务器选择结果: 所有服务器都不可用')\n+        console.log('💡 建议: 请检查服务器配置或网络连接')\n+        console.log('=' .repeat(60))\n+        return null\n+      }\n+\n+    } catch (error) {\n+      console.error('\\n❌ 服务器初始化失败:', error)\n+      console.log('=' .repeat(60))\n+      return null\n+    }\n+  }\n+\n+  /**\n    * 选择最优服务器（主要接口）\n    * 只在用户发起生图请求时调用\n    */\n   async getOptimalServer() {\n"
                },
                {
                    "date": 1752517124766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -434,24 +434,18 @@\n    * 只在用户发起生图请求时调用\n    */\n   async getOptimalServer() {\n     try {\n-      console.log('🎯 开始选择最优服务器...')\n+      console.log('🎯 选择最优服务器 (用于生图请求)...')\n \n       // 1. 获取最新的服务器列表\n       const servers = await this.getLatestServerList()\n \n       if (servers.length === 0) {\n         throw new Error('没有可用的服务器配置')\n       }\n \n-      console.log(`📋 发现 ${servers.length} 个配置的服务器:`)\n-      servers.forEach((server, index) => {\n-        console.log(`   ${index + 1}. ${server.url} (${server.type}, 优先级: ${server.priority})`)\n-      })\n-\n       // 2. 并行检查所有服务器的健康状态和队列信息\n-      console.log('🔍 正在测试所有服务器的健康状态和队列信息...')\n       const serverChecks = servers.map(async (server) => {\n         try {\n           const [healthResult, queueResult] = await Promise.allSettled([\n             this.checkServerHealth(server.url),\n@@ -460,24 +454,20 @@\n \n           const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n           const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n \n-          // 输出每个服务器的测试结果\n-          if (health.healthy) {\n-            console.log(`✅ ${server.url} - 健康 (响应时间: ${health.responseTime}ms, 队列: ${queue.total || 0})`)\n-          } else {\n-            console.log(`❌ ${server.url} - 不可用 (${health.error || '连接失败'})`)\n-          }\n+          // 更智能的健康判断\n+          const isHealthy = health.healthy || (health.responseTime > 0 && health.responseTime < 30000)\n \n           return {\n             ...server,\n-            healthy: health.healthy,\n+            healthy: isHealthy,\n             queue: queue,\n             responseTime: health.responseTime || 0,\n-            error: health.error\n+            error: health.error,\n+            healthCheckEndpoint: health.endpoint\n           }\n         } catch (error) {\n-          console.error(`❌ 检查服务器 ${server.url} 失败:`, error)\n           return {\n             ...server,\n             healthy: false,\n             queue: { total: 999, healthy: false },\n@@ -488,15 +478,9 @@\n       })\n \n       const serverResults = await Promise.all(serverChecks)\n \n-      // 3. 显示测试结果汇总\n-      const healthyCount = serverResults.filter(s => s.healthy).length\n-      const unhealthyCount = serverResults.length - healthyCount\n-\n-      console.log(`📊 服务器测试结果汇总: ${healthyCount} 个健康, ${unhealthyCount} 个不可用`)\n-\n-      // 4. 过滤健康的服务器并按队列长度排序\n+      // 3. 过滤健康的服务器并按队列长度排序\n       const healthyServers = serverResults\n         .filter(server => server.healthy)\n         .sort((a, b) => {\n           // 按队列数量排序\n@@ -506,9 +490,9 @@\n           // 如果队列相同，按优先级排序\n           return a.priority - b.priority\n         })\n \n-      // 5. 选择最优服务器\n+      // 4. 选择最优服务器\n       if (healthyServers.length === 0) {\n         console.warn('⚠️ 没有健康的服务器可用，尝试使用响应最快的服务器')\n \n         // 如果没有健康服务器，选择响应时间最快的\n@@ -516,31 +500,20 @@\n           .filter(server => server.responseTime > 0)\n           .sort((a, b) => a.responseTime - b.responseTime)[0]\n \n         if (fastestServer) {\n-          console.log(`🆘 最终选择: ${fastestServer.url}`)\n-          console.log(`   原因: 响应最快的服务器 (${fastestServer.responseTime}ms)`)\n-          console.log(`   状态: 可能不稳定，建议检查服务器配置`)\n+          console.log(`🆘 选择响应最快的服务器: ${fastestServer.url} (${fastestServer.responseTime}ms)`)\n           return fastestServer.url\n         }\n \n         // 最后的备用方案：返回第一个配置的服务器\n-        console.log(`🆘 最终选择: ${servers[0].url}`)\n-        console.log(`   原因: 备用方案 - 使用第一个配置的服务器`)\n-        console.log(`   状态: 未知，可能无法正常工作`)\n+        console.log(`🆘 使用第一个配置的服务器: ${servers[0].url}`)\n         return servers[0].url\n       }\n \n       const selectedServer = healthyServers[0]\n-      console.log(`🎯 最终选择: ${selectedServer.url}`)\n-      console.log(`   类型: ${selectedServer.type === 'primary' ? '主服务器' : '备用服务器'}`)\n-      console.log(`   队列数: ${selectedServer.queue.total || 0} (运行中: ${selectedServer.queue.running || 0}, 等待中: ${selectedServer.queue.pending || 0})`)\n-      console.log(`   响应时间: ${selectedServer.responseTime}ms`)\n-      console.log(`   优先级: ${selectedServer.priority}`)\n+      console.log(`🎯 选择服务器: ${selectedServer.url} (队列: ${selectedServer.queue.total || 0}, 响应时间: ${selectedServer.responseTime}ms)`)\n \n-      // 6. 记录所有服务器状态（用于调试）\n-      this.logServerStatus(serverResults)\n-\n       return selectedServer.url\n \n     } catch (error) {\n       console.error('❌ 服务器选择失败:', error)\n"
                },
                {
                    "date": 1752517847163,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -319,10 +319,10 @@\n \n           const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n           const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n \n-          // 更智能的健康判断\n-          const isHealthy = health.healthy || (health.responseTime > 0 && health.responseTime < 30000)\n+          // 健康判断：只有明确返回 healthy: true 才认为健康\n+          const isHealthy = health.healthy === true\n \n           // 详细输出测试结果\n           if (isHealthy) {\n             console.log(`   ✅ 健康检查: 通过 (${health.responseTime}ms)`)\n"
                },
                {
                    "date": 1752517862947,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -454,10 +454,10 @@\n \n           const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n           const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n \n-          // 更智能的健康判断\n-          const isHealthy = health.healthy || (health.responseTime > 0 && health.responseTime < 30000)\n+          // 健康判断：只有明确返回 healthy: true 才认为健康\n+          const isHealthy = health.healthy === true\n \n           return {\n             ...server,\n             healthy: isHealthy,\n"
                },
                {
                    "date": 1752517945786,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -267,15 +267,14 @@\n       }\n \n     } catch (error) {\n       console.warn(`⚠️ 获取服务器 ${serverUrl} 队列信息失败:`, error.message)\n-      // 如果队列信息获取失败，但服务器可能仍然健康，使用估算值\n+      // 如果队列信息获取失败，说明服务器可能不可用\n       return {\n         running: 0,\n         pending: 0,\n-        total: 1, // 使用较低的估算值，避免影响服务器选择\n-        healthy: true, // 队列信息获取失败不代表服务器不健康\n-        isEstimate: true,\n+        total: 999, // 使用高值，避免选择这个服务器\n+        healthy: false, // 队列信息获取失败说明服务器可能有问题\n         error: error.message\n       }\n     }\n   }\n"
                },
                {
                    "date": 1752517964443,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -255,15 +255,15 @@\n           }\n         }\n       } else {\n         console.warn(`⚠️ 服务器 ${serverUrl} 队列API返回状态码: ${response.status}`)\n-        // 如果队列API不可用但服务器可达，使用估算值\n+        // 如果队列API返回错误状态码，说明服务器可能有问题\n         return {\n           running: 0,\n           pending: 0,\n-          total: 1, // 使用1而不是0，避免所有用户都选择这个服务器\n-          healthy: true,\n-          isEstimate: true\n+          total: 999, // 使用高值，避免选择这个服务器\n+          healthy: false,\n+          error: `HTTP ${response.status}`\n         }\n       }\n \n     } catch (error) {\n"
                },
                {
                    "date": 1752518240043,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,16 +1,11 @@\n-// ComfyUI 极简负载均衡器\n-import configService from './configService.js'\n-\n /**\n- * ComfyUI 极简负载均衡器\n- * 只在用户发起请求时选择队列最少的可用服务器\n+ * ComfyUI 负载均衡器 - 重写版本\n+ * 使用直接连接测试作为健康判断标准\n  */\n-class ComfyUILoadBalancer {\n+class LoadBalancer {\n   constructor() {\n-    this.queueCheckTimeout = 5000 // 5秒队列检查超时\n-    this.healthCheckTimeout = 5000 // 5秒健康检查超时\n-    this.initialized = false\n+    this.connectionTimeout = 10000 // 10秒连接超时\n   }\n \n   /**\n    * 初始化负载均衡器（仅在页面加载时执行一次）\n"
                },
                {
                    "date": 1752518259328,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,23 +7,13 @@\n     this.connectionTimeout = 10000 // 10秒连接超时\n   }\n \n   /**\n-   * 初始化负载均衡器（仅在页面加载时执行一次）\n+   * 初始化负载均衡器\n    */\n   async initialize() {\n-    if (this.initialized) {\n-      return\n-    }\n-\n-    try {\n-      console.log('🔄 初始化负载均衡器...')\n-      this.initialized = true\n-      console.log('✅ 负载均衡器初始化完成')\n-    } catch (error) {\n-      console.error('❌ 负载均衡器初始化失败:', error)\n-      this.initialized = false\n-    }\n+    console.log('🔧 初始化负载均衡器...')\n+    return true\n   }\n \n   /**\n    * 获取最新的服务器列表（从数据库/配置中获取）\n"
                },
                {
                    "date": 1752518284230,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,72 +15,42 @@\n     return true\n   }\n \n   /**\n-   * 获取最新的服务器列表（从数据库/配置中获取）\n+   * 获取服务器列表\n    */\n-  async getLatestServerList() {\n-    try {\n-      console.log('🔄 获取最新服务器列表...')\n+  async getServerList() {\n+    const servers = []\n \n-      // 从配置服务获取最新配置\n-      const config = await configService.getConfig()\n-      const servers = []\n+    // 主服务器\n+    const primaryServer = window.getConfig?.('comfyui.server_url')\n+    if (primaryServer && primaryServer.trim()) {\n+      servers.push({\n+        url: primaryServer.trim(),\n+        type: 'primary',\n+        priority: 1\n+      })\n+    }\n \n-      // 主服务器\n-      if (config['comfyui.server_url']) {\n+    // 备用服务器\n+    const backupServersConfig = window.getConfig?.('comfyui.backup_servers')\n+    if (backupServersConfig && backupServersConfig.trim()) {\n+      const backupServers = backupServersConfig\n+        .replace(/\\s*,\\s*/g, '\\n')\n+        .split('\\n')\n+        .map(url => url.trim())\n+        .filter(url => url && url.startsWith('http'))\n+\n+      backupServers.forEach((url, index) => {\n         servers.push({\n-          url: config['comfyui.server_url'],\n-          type: 'primary',\n-          priority: 1\n+          url,\n+          type: 'backup',\n+          priority: index + 2\n         })\n-      }\n+      })\n+    }\n \n-      // 备用服务器 - 支持换行符和逗号两种分隔方式\n-      if (config['comfyui.backup_servers']) {\n-        const backupServers = config['comfyui.backup_servers']\n-          .replace(/\\s*,\\s*/g, '\\n') // 将逗号替换为换行符\n-          .split('\\n')\n-          .map(url => url.trim())\n-          .filter(url => url && url.startsWith('http'))\n-\n-        backupServers.forEach((url, index) => {\n-          servers.push({\n-            url,\n-            type: 'backup',\n-            priority: index + 2\n-          })\n-        })\n-      }\n-\n-      // 如果没有配置服务器，使用默认配置\n-      if (servers.length === 0) {\n-        console.warn('⚠️ 未找到配置的服务器，使用默认服务器列表')\n-\n-        // 使用更新后的默认服务器列表\n-        const defaultServers = [\n-          {\n-            url: 'https://l9s75ay3rp-8188.cnb.run',\n-            type: 'primary',\n-            priority: 1\n-          },\n-          {\n-            url: 'https://0rv00xh2vg-8188.cnb.run',\n-            type: 'backup',\n-            priority: 2\n-          }\n-        ]\n-\n-        servers.push(...defaultServers)\n-      }\n-\n-      console.log(`✅ 获取到 ${servers.length} 个服务器:`, servers.map(s => s.url))\n-      return servers\n-\n-    } catch (error) {\n-      console.error('❌ 获取服务器列表失败:', error)\n-      return []\n-    }\n+    return servers\n   }\n \n   /**\n    * 检查服务器健康状态\n"
                },
                {
                    "date": 1752518311193,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,74 +52,42 @@\n     return servers\n   }\n \n   /**\n-   * 检查服务器健康状态\n-   * 基于 ComfyUI 官方文档的端点进行检测\n+   * 直接连接测试 - 简单有效的健康检查\n    */\n-  async checkServerHealth(serverUrl) {\n-    // 基于实际服务器的端点列表，按优先级排序\n-    const testEndpoints = [\n-      '/api/queue',        // 实际的队列端点路径\n-      '/api/system_stats', // 系统状态端点\n-      '/api/object_info',  // 节点信息端点\n-      '/api/prompt',       // 提示状态端点\n-      '/queue',            // 备用标准路径\n-      '/system_stats',     // 备用标准路径\n-      '/'                  // 根路径，最后尝试\n-    ]\n+  async testDirectConnection(serverUrl) {\n+    try {\n+      const controller = new AbortController()\n+      const timeoutId = setTimeout(() => controller.abort(), this.connectionTimeout)\n \n-    let lastError = null\n-    const startTime = Date.now()\n+      const startTime = Date.now()\n+      const response = await fetch(serverUrl, {\n+        method: 'HEAD',\n+        signal: controller.signal,\n+        headers: {\n+          'Accept': '*/*',\n+          'Cache-Control': 'no-cache'\n+        }\n+      })\n \n-    for (const endpoint of testEndpoints) {\n-      try {\n-        const controller = new AbortController()\n-        const timeoutId = setTimeout(() => controller.abort(), this.healthCheckTimeout)\n+      clearTimeout(timeoutId)\n+      const responseTime = Date.now() - startTime\n \n-        console.log(`🔍 测试端点: ${serverUrl}${endpoint}`)\n+      // 只要能连接就认为健康，不管返回什么状态码\n+      return {\n+        healthy: true,\n+        responseTime,\n+        status: response.status\n+      }\n \n-        const response = await fetch(`${serverUrl}${endpoint}`, {\n-          method: 'GET',\n-          signal: controller.signal,\n-          headers: {\n-            'Accept': '*/*',\n-            'Cache-Control': 'max-age=0',\n-            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36',\n-            'comfy-user': 'loadbalancer-client'\n-          }\n-        })\n-\n-        clearTimeout(timeoutId)\n-        const endTime = Date.now()\n-\n-        // 如果响应成功，认为服务器健康\n-        if (response.ok) {\n-          console.log(`✅ 端点 ${endpoint} 响应成功 (${response.status})`)\n-          return {\n-            healthy: true,\n-            responseTime: endTime - startTime,\n-            status: response.status,\n-            endpoint: endpoint\n-          }\n-        } else {\n-          console.log(`⚠️ 端点 ${endpoint} 响应失败 (${response.status})`)\n-          lastError = `HTTP ${response.status}`\n-        }\n-      } catch (error) {\n-        console.log(`❌ 端点 ${endpoint} 连接失败: ${error.message}`)\n-        lastError = error.message\n-        continue\n+    } catch (error) {\n+      // 只有真正的连接失败才认为不健康\n+      return {\n+        healthy: false,\n+        error: error.message\n       }\n     }\n-\n-    // 所有端点都失败\n-    const endTime = Date.now()\n-    return {\n-      healthy: false,\n-      responseTime: endTime - startTime,\n-      error: lastError || '所有端点都无法访问'\n-    }\n   }\n \n   /**\n    * 获取服务器队列信息\n"
                },
                {
                    "date": 1752518345043,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,117 +89,47 @@\n     }\n   }\n \n   /**\n-   * 获取服务器队列信息\n+   * 获取队列信息\n    */\n-  async getServerQueueInfo(serverUrl) {\n+  async getQueueInfo(serverUrl) {\n     try {\n       const controller = new AbortController()\n-      const timeoutId = setTimeout(() => controller.abort(), this.queueCheckTimeout)\n+      const timeoutId = setTimeout(() => controller.abort(), this.connectionTimeout)\n \n-      console.log(`📊 获取服务器队列信息: ${serverUrl}/queue`)\n-\n       const response = await fetch(`${serverUrl}/api/queue`, {\n         method: 'GET',\n         signal: controller.signal,\n         headers: {\n           'Accept': '*/*',\n           'Cache-Control': 'max-age=0',\n-          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36',\n+          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',\n           'comfy-user': 'loadbalancer-client'\n         }\n       })\n \n       clearTimeout(timeoutId)\n \n       if (response.ok) {\n-        try {\n-          const responseText = await response.text()\n-          console.log(`📊 队列API原始响应: ${responseText.substring(0, 200)}...`)\n+        const data = await response.json()\n \n-          const queueData = JSON.parse(responseText)\n-          console.log(`📊 服务器 ${serverUrl} 队列数据结构:`, Object.keys(queueData))\n+        // 解析队列数据\n+        let running = 0, pending = 0, total = 0\n \n-          // 尝试多种可能的数据格式\n-          let running = 0\n-          let pending = 0\n+        if (data.queue_running !== undefined && data.queue_pending !== undefined) {\n+          running = Array.isArray(data.queue_running) ? data.queue_running.length : data.queue_running\n+          pending = Array.isArray(data.queue_pending) ? data.queue_pending.length : data.queue_pending\n+          total = running + pending\n+        }\n \n-          // 标准 ComfyUI 格式\n-          if (queueData.queue_running !== undefined && queueData.queue_pending !== undefined) {\n-            running = Array.isArray(queueData.queue_running) ? queueData.queue_running.length :\n-                     (typeof queueData.queue_running === 'number' ? queueData.queue_running : 0)\n-            pending = Array.isArray(queueData.queue_pending) ? queueData.queue_pending.length :\n-                     (typeof queueData.queue_pending === 'number' ? queueData.queue_pending : 0)\n-          }\n-          // 其他可能的格式\n-          else if (queueData.running !== undefined && queueData.pending !== undefined) {\n-            running = typeof queueData.running === 'number' ? queueData.running : 0\n-            pending = typeof queueData.pending === 'number' ? queueData.pending : 0\n-          }\n-          // 如果有 exec_info\n-          else if (queueData.exec_info) {\n-            running = queueData.exec_info.queue_remaining || 0\n-            pending = 0\n-          }\n-          // 简单的数字格式\n-          else if (typeof queueData === 'number') {\n-            running = 0\n-            pending = queueData\n-          }\n-          // 如果有 queue 字段\n-          else if (queueData.queue) {\n-            if (Array.isArray(queueData.queue)) {\n-              pending = queueData.queue.length\n-              running = 0\n-            } else if (typeof queueData.queue === 'number') {\n-              pending = queueData.queue\n-              running = 0\n-            }\n-          }\n-\n-          const total = running + pending\n-          console.log(`📊 队列统计 - 运行中: ${running}, 等待中: ${pending}, 总计: ${total}`)\n-\n-          return {\n-            running,\n-            pending,\n-            total,\n-            healthy: true\n-          }\n-        } catch (parseError) {\n-          console.warn(`⚠️ 解析队列数据失败:`, parseError.message)\n-          // 如果能连接但无法解析JSON，说明服务器可用但可能返回了非标准格式\n-          return {\n-            running: 0,\n-            pending: 0,\n-            total: 1, // 使用1而不是0，避免所有用户都选择这个服务器\n-            healthy: true,\n-            isEstimate: true\n-          }\n-        }\n+        return { running, pending, total, success: true }\n       } else {\n-        console.warn(`⚠️ 服务器 ${serverUrl} 队列API返回状态码: ${response.status}`)\n-        // 如果队列API返回错误状态码，说明服务器可能有问题\n-        return {\n-          running: 0,\n-          pending: 0,\n-          total: 999, // 使用高值，避免选择这个服务器\n-          healthy: false,\n-          error: `HTTP ${response.status}`\n-        }\n+        return { running: 0, pending: 0, total: 1, success: false, error: `HTTP ${response.status}` }\n       }\n \n     } catch (error) {\n-      console.warn(`⚠️ 获取服务器 ${serverUrl} 队列信息失败:`, error.message)\n-      // 如果队列信息获取失败，说明服务器可能不可用\n-      return {\n-        running: 0,\n-        pending: 0,\n-        total: 999, // 使用高值，避免选择这个服务器\n-        healthy: false, // 队列信息获取失败说明服务器可能有问题\n-        error: error.message\n-      }\n+      return { running: 0, pending: 0, total: 1, success: false, error: error.message }\n     }\n   }\n \n   /**\n"
                },
                {
                    "date": 1752518384766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -133,11 +133,133 @@\n   }\n \n   /**\n    * 页面加载时初始化服务器连接测试\n-   * 提供详细的服务器状态反馈\n    */\n   async initializeServerConnection() {\n+    console.log('🚀 正在初始化 ComfyUI 服务器连接...')\n+    console.log('=' .repeat(60))\n+\n+    const servers = await this.getServerList()\n+\n+    if (servers.length === 0) {\n+      console.warn('⚠️ 未找到任何配置的服务器')\n+      return null\n+    }\n+\n+    console.log(`📋 发现 ${servers.length} 个配置的服务器:`)\n+    servers.forEach((server, index) => {\n+      console.log(`   ${index + 1}. ${server.url} (${server.type === 'primary' ? '主服务器' : '备用服务器'}, 优先级: ${server.priority})`)\n+    })\n+    console.log('')\n+\n+    console.log('🔍 开始服务器连接测试...')\n+    console.log('-' .repeat(60))\n+\n+    const serverResults = []\n+\n+    for (const server of servers) {\n+      console.log(`\\n🖥️  测试服务器: ${server.url}`)\n+      console.log(`   类型: ${server.type === 'primary' ? '主服务器' : '备用服务器'} | 优先级: ${server.priority}`)\n+\n+      // 直接连接测试\n+      const healthResult = await this.testDirectConnection(server.url)\n+\n+      if (healthResult.healthy) {\n+        console.log(`   ✅ 连接测试: 成功 (${healthResult.responseTime}ms, 状态码: ${healthResult.status})`)\n+\n+        // 获取队列信息\n+        const queueResult = await this.getQueueInfo(server.url)\n+\n+        if (queueResult.success) {\n+          console.log(`   📊 队列信息: 运行中 ${queueResult.running} | 等待中 ${queueResult.pending} | 总计 ${queueResult.total}`)\n+\n+          const queueStatus = queueResult.total === 0 ? '🟢 空闲' :\n+                            queueResult.running > 0 ? '🟡 繁忙' : '🔴 队列满'\n+          console.log(`   📈 服务器状态: ${queueStatus}`)\n+\n+          serverResults.push({\n+            ...server,\n+            healthy: true,\n+            responseTime: healthResult.responseTime,\n+            queue: queueResult\n+          })\n+        } else {\n+          console.log(`   ⚠️ 队列信息: 获取失败 (${queueResult.error})`)\n+          console.log(`   📈 服务器状态: 🟡 可用但队列信息未知`)\n+\n+          serverResults.push({\n+            ...server,\n+            healthy: true,\n+            responseTime: healthResult.responseTime,\n+            queue: { running: 0, pending: 0, total: 1, success: false }\n+          })\n+        }\n+      } else {\n+        console.log(`   ❌ 连接测试: 失败 (${healthResult.error})`)\n+        console.log(`   📈 服务器状态: 🔴 不可用`)\n+\n+        serverResults.push({\n+          ...server,\n+          healthy: false,\n+          error: healthResult.error\n+        })\n+      }\n+    }\n+\n+    // 输出测试结果汇总\n+    console.log('\\n' + '=' .repeat(60))\n+    const healthyServers = serverResults.filter(s => s.healthy)\n+    console.log(`📊 服务器连接测试完成: ${healthyServers.length}/${serverResults.length} 个服务器可用`)\n+\n+    // 详细的服务器状态表格\n+    console.log('\\n📋 服务器状态汇总:')\n+    console.log('   状态 | 类型     | 服务器URL                    | 队列(运行/等待/总计) | 响应时间')\n+    console.log('   -----|----------|------------------------------|---------------------|----------')\n+\n+    serverResults.forEach(server => {\n+      const status = server.healthy ? '✅' : '❌'\n+      const type = server.type === 'primary' ? '主服务器' : '备用    '\n+      const url = server.url.length > 28 ? server.url.substring(0, 25) + '...' : server.url.padEnd(28)\n+      const queueInfo = server.queue ?\n+        `${(server.queue.running || 0).toString().padStart(2)}/${(server.queue.pending || 0).toString().padStart(2)}/${(server.queue.total || 0).toString().padStart(2)}`.padEnd(19) :\n+        'N/A'.padEnd(19)\n+      const responseTime = server.responseTime ? `${server.responseTime}ms` : 'N/A'\n+\n+      console.log(`   ${status} | ${type} | ${url} | ${queueInfo} | ${responseTime}`)\n+    })\n+\n+    // 选择最优服务器\n+    if (healthyServers.length > 0) {\n+      const bestServer = healthyServers.sort((a, b) => {\n+        const queueDiff = (a.queue?.total || 0) - (b.queue?.total || 0)\n+        if (queueDiff !== 0) return queueDiff\n+        return a.priority - b.priority\n+      })[0]\n+\n+      console.log('\\n🎯 最优服务器选择结果:')\n+      console.log(`   选择服务器: ${bestServer.url}`)\n+      console.log(`   选择原因: ${bestServer.type === 'primary' ? '主服务器' : '备用服务器'} | 队列最少 (${bestServer.queue?.total || 0} 个任务)`)\n+      console.log(`   队列详情: 运行中 ${bestServer.queue?.running || 0} | 等待中 ${bestServer.queue?.pending || 0}`)\n+      console.log(`   响应时间: ${bestServer.responseTime}ms`)\n+      console.log(`   优先级: ${bestServer.priority}`)\n+\n+      console.log('\\n✅ 服务器初始化完成，系统已准备就绪！')\n+      console.log('=' .repeat(60))\n+\n+      return bestServer.url\n+    } else {\n+      console.log('\\n❌ 服务器选择结果: 所有服务器都不可用')\n+      console.log('💡 建议: 请检查服务器配置或网络连接')\n+      console.log('=' .repeat(60))\n+      return null\n+    }\n+  }\n+\n+  /**\n+   * 选择最优服务器（用于生图请求）\n+   */\n+  async getOptimalServer() {\n     try {\n       console.log('🚀 正在初始化 ComfyUI 服务器连接...')\n       console.log('=' .repeat(60))\n \n"
                },
                {
                    "date": 1752518407239,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -258,14 +258,11 @@\n   /**\n    * 选择最优服务器（用于生图请求）\n    */\n   async getOptimalServer() {\n-    try {\n-      console.log('🚀 正在初始化 ComfyUI 服务器连接...')\n-      console.log('=' .repeat(60))\n+    console.log('🎯 选择最优服务器 (用于生图请求)...')\n \n-      // 获取服务器列表\n-      const servers = await this.getLatestServerList()\n+    const servers = await this.getServerList()\n \n       if (servers.length === 0) {\n         console.warn('⚠️ 未找到任何配置的服务器')\n         return null\n"
                },
                {
                    "date": 1752518430963,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -262,39 +262,54 @@\n     console.log('🎯 选择最优服务器 (用于生图请求)...')\n \n     const servers = await this.getServerList()\n \n-      if (servers.length === 0) {\n-        console.warn('⚠️ 未找到任何配置的服务器')\n-        return null\n+    if (servers.length === 0) {\n+      throw new Error('没有可用的服务器配置')\n+    }\n+\n+    const serverResults = []\n+\n+    for (const server of servers) {\n+      // 直接连接测试\n+      const healthResult = await this.testDirectConnection(server.url)\n+\n+      if (healthResult.healthy) {\n+        // 获取队列信息\n+        const queueResult = await this.getQueueInfo(server.url)\n+\n+        serverResults.push({\n+          ...server,\n+          healthy: true,\n+          responseTime: healthResult.responseTime,\n+          queue: queueResult\n+        })\n+      } else {\n+        serverResults.push({\n+          ...server,\n+          healthy: false,\n+          error: healthResult.error\n+        })\n       }\n+    }\n \n-      console.log(`📋 发现 ${servers.length} 个配置的服务器:`)\n-      servers.forEach((server, index) => {\n-        console.log(`   ${index + 1}. ${server.url} (${server.type === 'primary' ? '主服务器' : '备用服务器'}, 优先级: ${server.priority})`)\n-      })\n-      console.log('')\n+    const healthyServers = serverResults.filter(s => s.healthy)\n \n-      console.log('🔍 开始服务器连接和队列测试...')\n-      console.log('-' .repeat(60))\n+    if (healthyServers.length === 0) {\n+      console.warn('⚠️ 没有健康的服务器可用')\n+      return servers[0]?.url || null\n+    }\n \n-      // 测试所有服务器\n-      const serverChecks = servers.map(async (server) => {\n-        console.log(`\\n🖥️  测试服务器: ${server.url}`)\n-        console.log(`   类型: ${server.type === 'primary' ? '主服务器' : '备用服务器'} | 优先级: ${server.priority}`)\n+    const bestServer = healthyServers.sort((a, b) => {\n+      const queueDiff = (a.queue?.total || 0) - (b.queue?.total || 0)\n+      if (queueDiff !== 0) return queueDiff\n+      return a.priority - b.priority\n+    })[0]\n \n-        try {\n-          const [healthResult, queueResult] = await Promise.allSettled([\n-            this.checkServerHealth(server.url),\n-            this.getServerQueueInfo(server.url)\n-          ])\n+    console.log(`🎯 选择服务器: ${bestServer.url} (队列: ${bestServer.queue?.total || 0}, 响应时间: ${bestServer.responseTime}ms)`)\n \n-          const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n-          const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n+    return bestServer.url\n \n-          // 健康判断：只有明确返回 healthy: true 才认为健康\n-          const isHealthy = health.healthy === true\n-\n           // 详细输出测试结果\n           if (isHealthy) {\n             console.log(`   ✅ 健康检查: 通过 (${health.responseTime}ms)`)\n             if (health.endpoint) {\n"
                },
                {
                    "date": 1752518778222,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -307,336 +307,11 @@\n \n     console.log(`🎯 选择服务器: ${bestServer.url} (队列: ${bestServer.queue?.total || 0}, 响应时间: ${bestServer.responseTime}ms)`)\n \n     return bestServer.url\n-\n-          // 详细输出测试结果\n-          if (isHealthy) {\n-            console.log(`   ✅ 健康检查: 通过 (${health.responseTime}ms)`)\n-            if (health.endpoint) {\n-              console.log(`   🔗 可用端点: ${health.endpoint}`)\n-            }\n-          } else {\n-            console.log(`   ❌ 健康检查: 失败 (${health.error || '连接失败'})`)\n-          }\n-\n-          // 队列信息详细输出\n-          if (queue.healthy) {\n-            console.log(`   📊 队列信息: 运行中 ${queue.running || 0} | 等待中 ${queue.pending || 0} | 总计 ${queue.total || 0}`)\n-            if (queue.isEstimate) {\n-              console.log(`   ⚠️  队列数据为估算值`)\n-            }\n-          } else {\n-            console.log(`   ❌ 队列信息: 获取失败 (${queue.error || '连接失败'})`)\n-          }\n-\n-          // 服务器状态总结\n-          if (isHealthy) {\n-            const queueStatus = queue.total === 0 ? '🟢 空闲' :\n-                              queue.running > 0 ? '🟡 繁忙' : '🔴 队列满'\n-            console.log(`   📈 服务器状态: ${queueStatus}`)\n-          } else {\n-            console.log(`   📈 服务器状态: 🔴 不可用`)\n-          }\n-\n-          return {\n-            ...server,\n-            healthy: isHealthy,\n-            queue: queue,\n-            responseTime: health.responseTime || 0,\n-            error: health.error,\n-            healthCheckEndpoint: health.endpoint\n-          }\n-        } catch (error) {\n-          console.log(`   ❌ 测试失败: ${error.message}`)\n-          return {\n-            ...server,\n-            healthy: false,\n-            queue: { total: 999, healthy: false },\n-            responseTime: 0,\n-            error: error.message\n-          }\n-        }\n-      })\n-\n-      const serverResults = await Promise.all(serverChecks)\n-\n-      // 输出测试结果汇总\n-      console.log('\\n' + '=' .repeat(60))\n-      const healthyServers = serverResults.filter(s => s.healthy)\n-      console.log(`📊 服务器连接测试完成: ${healthyServers.length}/${serverResults.length} 个服务器可用`)\n-\n-      // 详细的服务器状态表格\n-      console.log('\\n📋 服务器状态汇总:')\n-      console.log('   状态 | 类型     | 服务器URL                    | 队列(运行/等待/总计) | 响应时间')\n-      console.log('   -----|----------|------------------------------|---------------------|----------')\n-\n-      serverResults.forEach(server => {\n-        const status = server.healthy ? '✅' : '❌'\n-        const type = server.type === 'primary' ? '主服务器' : '备用    '\n-        const url = server.url.length > 28 ? server.url.substring(0, 25) + '...' : server.url.padEnd(28)\n-        const queueInfo = server.queue ?\n-          `${(server.queue.running || 0).toString().padStart(2)}/${(server.queue.pending || 0).toString().padStart(2)}/${(server.queue.total || 0).toString().padStart(2)}`.padEnd(19) :\n-          'N/A'.padEnd(19)\n-        const responseTime = server.responseTime ? `${server.responseTime}ms` : 'N/A'\n-\n-        console.log(`   ${status} | ${type} | ${url} | ${queueInfo} | ${responseTime}`)\n-      })\n-\n-      // 选择最优服务器\n-      if (healthyServers.length > 0) {\n-        const bestServer = healthyServers.sort((a, b) => {\n-          const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n-          if (queueDiff !== 0) return queueDiff\n-          return a.priority - b.priority\n-        })[0]\n-\n-        console.log('\\n🎯 最优服务器选择结果:')\n-        console.log(`   选择服务器: ${bestServer.url}`)\n-        console.log(`   选择原因: ${bestServer.type === 'primary' ? '主服务器' : '备用服务器'} | 队列最少 (${bestServer.queue.total || 0} 个任务)`)\n-        console.log(`   队列详情: 运行中 ${bestServer.queue.running || 0} | 等待中 ${bestServer.queue.pending || 0}`)\n-        console.log(`   响应时间: ${bestServer.responseTime}ms`)\n-        console.log(`   优先级: ${bestServer.priority}`)\n-\n-        console.log('\\n✅ 服务器初始化完成，系统已准备就绪！')\n-        console.log('=' .repeat(60))\n-\n-        return bestServer.url\n-      } else {\n-        console.log('\\n❌ 服务器选择结果: 所有服务器都不可用')\n-        console.log('💡 建议: 请检查服务器配置或网络连接')\n-        console.log('=' .repeat(60))\n-        return null\n-      }\n-\n-    } catch (error) {\n-      console.error('\\n❌ 服务器初始化失败:', error)\n-      console.log('=' .repeat(60))\n-      return null\n-    }\n   }\n-\n-  /**\n-   * 选择最优服务器（主要接口）\n-   * 只在用户发起生图请求时调用\n-   */\n-  async getOptimalServer() {\n-    try {\n-      console.log('🎯 选择最优服务器 (用于生图请求)...')\n-\n-      // 1. 获取最新的服务器列表\n-      const servers = await this.getLatestServerList()\n-\n-      if (servers.length === 0) {\n-        throw new Error('没有可用的服务器配置')\n-      }\n-\n-      // 2. 并行检查所有服务器的健康状态和队列信息\n-      const serverChecks = servers.map(async (server) => {\n-        try {\n-          const [healthResult, queueResult] = await Promise.allSettled([\n-            this.checkServerHealth(server.url),\n-            this.getServerQueueInfo(server.url)\n-          ])\n-\n-          const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n-          const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n-\n-          // 健康判断：只有明确返回 healthy: true 才认为健康\n-          const isHealthy = health.healthy === true\n-\n-          return {\n-            ...server,\n-            healthy: isHealthy,\n-            queue: queue,\n-            responseTime: health.responseTime || 0,\n-            error: health.error,\n-            healthCheckEndpoint: health.endpoint\n-          }\n-        } catch (error) {\n-          return {\n-            ...server,\n-            healthy: false,\n-            queue: { total: 999, healthy: false },\n-            responseTime: 0,\n-            error: error.message\n-          }\n-        }\n-      })\n-\n-      const serverResults = await Promise.all(serverChecks)\n-\n-      // 3. 过滤健康的服务器并按队列长度排序\n-      const healthyServers = serverResults\n-        .filter(server => server.healthy)\n-        .sort((a, b) => {\n-          // 按队列数量排序\n-          const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n-          if (queueDiff !== 0) return queueDiff\n-\n-          // 如果队列相同，按优先级排序\n-          return a.priority - b.priority\n-        })\n-\n-      // 4. 选择最优服务器\n-      if (healthyServers.length === 0) {\n-        console.warn('⚠️ 没有健康的服务器可用，尝试使用响应最快的服务器')\n-\n-        // 如果没有健康服务器，选择响应时间最快的\n-        const fastestServer = serverResults\n-          .filter(server => server.responseTime > 0)\n-          .sort((a, b) => a.responseTime - b.responseTime)[0]\n-\n-        if (fastestServer) {\n-          console.log(`🆘 选择响应最快的服务器: ${fastestServer.url} (${fastestServer.responseTime}ms)`)\n-          return fastestServer.url\n-        }\n-\n-        // 最后的备用方案：返回第一个配置的服务器\n-        console.log(`🆘 使用第一个配置的服务器: ${servers[0].url}`)\n-        return servers[0].url\n-      }\n-\n-      const selectedServer = healthyServers[0]\n-      console.log(`🎯 选择服务器: ${selectedServer.url} (队列: ${selectedServer.queue.total || 0}, 响应时间: ${selectedServer.responseTime}ms)`)\n-\n-      return selectedServer.url\n-\n-    } catch (error) {\n-      console.error('❌ 服务器选择失败:', error)\n-\n-      // 错误时的备用方案\n-      try {\n-        const config = await configService.getConfig()\n-        const fallbackUrl = config['comfyui.server_url'] || 'https://your-comfyui-server.com'\n-        console.log(`🆘 使用备用服务器: ${fallbackUrl}`)\n-        return fallbackUrl\n-      } catch (configError) {\n-        console.error('❌ 获取备用服务器配置失败:', configError)\n-        return 'https://your-comfyui-server.com'\n-      }\n-    }\n-  }\n-\n-  /**\n-   * 页面加载时初始化服务器连接测试\n-   * 提供详细的服务器状态反馈\n-   */\n-  async initializeServerConnection() {\n-    try {\n-      console.log('🚀 正在初始化 ComfyUI 服务器连接...')\n-\n-      // 获取服务器列表\n-      const servers = await this.getLatestServerList()\n-\n-      if (servers.length === 0) {\n-        console.warn('⚠️ 未找到任何配置的服务器')\n-        return null\n-      }\n-\n-      console.log(`📋 发现 ${servers.length} 个配置的服务器，开始连接测试...`)\n-\n-      // 测试所有服务器\n-      const serverChecks = servers.map(async (server) => {\n-        console.log(`🔍 测试服务器: ${server.url}`)\n-\n-        try {\n-          const [healthResult, queueResult] = await Promise.allSettled([\n-            this.checkServerHealth(server.url),\n-            this.getServerQueueInfo(server.url)\n-          ])\n-\n-          const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n-          const queue = queueResult.status === 'fulfilled' ? queueResult.value : {\n-            total: 1,\n-            running: 0,\n-            pending: 0,\n-            healthy: true,\n-            isEstimate: true\n-          }\n-\n-          // 服务器健康状态主要基于健康检查结果\n-          const isHealthy = health.healthy\n-\n-          // 如果队列信息获取失败但服务器健康，给出警告但不影响选择\n-          if (isHealthy && queue.isEstimate) {\n-            console.warn(`⚠️ ${server.url} 健康但队列信息不可用，使用估算值`)\n-          }\n-\n-          return {\n-            ...server,\n-            healthy: isHealthy,\n-            queue: queue,\n-            responseTime: health.responseTime || 0,\n-            error: health.error,\n-            healthCheckEndpoint: health.endpoint\n-          }\n-        } catch (error) {\n-          return {\n-            ...server,\n-            healthy: false,\n-            queue: { total: 999, healthy: false },\n-            responseTime: 0,\n-            error: error.message\n-          }\n-        }\n-      })\n-\n-      const serverResults = await Promise.all(serverChecks)\n-\n-      // 输出测试结果\n-      const healthyServers = serverResults.filter(s => s.healthy)\n-      console.log(`✅ 服务器连接测试完成: ${healthyServers.length}/${serverResults.length} 个服务器可用`)\n-\n-      // 选择最优服务器\n-      if (healthyServers.length > 0) {\n-        const bestServer = healthyServers.sort((a, b) => {\n-          const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n-          if (queueDiff !== 0) return queueDiff\n-          return a.priority - b.priority\n-        })[0]\n-\n-        console.log(`🎯 推荐服务器: ${bestServer.url}`)\n-        console.log(`   队列状态: ${bestServer.queue.total || 0} 个任务 (运行中: ${bestServer.queue.running || 0}, 等待中: ${bestServer.queue.pending || 0})`)\n-        console.log(`   响应时间: ${bestServer.responseTime}ms`)\n-\n-        return bestServer.url\n-      } else {\n-        console.warn('❌ 所有服务器都不可用，请检查服务器配置')\n-        return null\n-      }\n-\n-    } catch (error) {\n-      console.error('❌ 服务器初始化失败:', error)\n-      return null\n-    }\n-  }\n-\n-  /**\n-   * 记录服务器状态（用于调试）\n-   */\n-  logServerStatus(servers) {\n-    console.log('📊 详细服务器状态报告:')\n-    console.log('   状态 | 类型 | 服务器URL | 队列(运行/等待/总计) | 优先级 | 响应时间 | 错误信息')\n-    console.log('   -----|------|-----------|-------------------|--------|----------|----------')\n-\n-    servers.forEach(server => {\n-      const status = server.healthy ? '✅' : '❌'\n-      const type = server.type === 'primary' ? '主服务器' : '备用'\n-      const queueInfo = server.queue ?\n-        `${server.queue.running || 0}/${server.queue.pending || 0}/${server.queue.total || 0}` :\n-        'N/A'\n-      const priority = server.priority || 'N/A'\n-      const responseTime = server.responseTime ? `${server.responseTime}ms` : 'N/A'\n-      const error = server.error ? server.error.substring(0, 20) + '...' : ''\n-\n-      console.log(`   ${status} | ${type} | ${server.url} | ${queueInfo} | ${priority} | ${responseTime} | ${error}`)\n-    })\n-\n-    console.log('') // 空行分隔\n-  }\n }\n \n // 创建单例实例\n-const loadBalancer = new ComfyUILoadBalancer()\n+const loadBalancer = new LoadBalancer()\n \n export default loadBalancer\n"
                },
                {
                    "date": 1752520085551,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,24 +89,69 @@\n     }\n   }\n \n   /**\n-   * 获取队列信息\n+   * 检测服务器API前缀\n    */\n+  async detectApiPrefix(serverUrl) {\n+    const testEndpoints = ['/api/queue', '/queue']\n+\n+    for (const endpoint of testEndpoints) {\n+      try {\n+        const controller = new AbortController()\n+        const timeoutId = setTimeout(() => controller.abort(), 3000)\n+\n+        const response = await fetch(`${serverUrl.replace(/\\/$/, '')}${endpoint}`, {\n+          method: 'GET',\n+          signal: controller.signal,\n+          headers: {\n+            'Accept': '*/*',\n+            'comfy-user': 'prefix-detector'\n+          },\n+          mode: 'cors',\n+          credentials: 'omit'\n+        })\n+\n+        clearTimeout(timeoutId)\n+\n+        if (response.ok) {\n+          const apiPrefix = endpoint.startsWith('/api/') ? '/api' : ''\n+          console.log(`🔍 检测到API前缀: ${apiPrefix || '(无前缀)'}`)\n+          return apiPrefix\n+        }\n+      } catch (error) {\n+        // 继续尝试下一个端点\n+        continue\n+      }\n+    }\n+\n+    console.log('🔍 无法检测API前缀，使用默认')\n+    return '' // 默认无前缀\n+  }\n+\n+  /**\n+   * 获取队列信息 - 支持API前缀自动检测\n+   */\n   async getQueueInfo(serverUrl) {\n     try {\n+      // 检测API前缀\n+      const apiPrefix = await this.detectApiPrefix(serverUrl)\n+\n       const controller = new AbortController()\n       const timeoutId = setTimeout(() => controller.abort(), this.connectionTimeout)\n \n-      const response = await fetch(`${serverUrl}/api/queue`, {\n+      const queueUrl = `${serverUrl.replace(/\\/$/, '')}${apiPrefix}/queue`\n+      const response = await fetch(queueUrl, {\n         method: 'GET',\n         signal: controller.signal,\n         headers: {\n           'Accept': '*/*',\n           'Cache-Control': 'max-age=0',\n           'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',\n           'comfy-user': 'loadbalancer-client'\n-        }\n+        },\n+        mode: 'cors',\n+        credentials: 'omit'\n       })\n \n       clearTimeout(timeoutId)\n \n@@ -121,9 +166,16 @@\n           pending = Array.isArray(data.queue_pending) ? data.queue_pending.length : data.queue_pending\n           total = running + pending\n         }\n \n-        return { running, pending, total, success: true }\n+        return {\n+          running,\n+          pending,\n+          total,\n+          success: true,\n+          apiPrefix,\n+          endpoint: queueUrl\n+        }\n       } else {\n         return { running: 0, pending: 0, total: 1, success: false, error: `HTTP ${response.status}` }\n       }\n \n"
                },
                {
                    "date": 1752520105099,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -223,8 +223,9 @@\n         const queueResult = await this.getQueueInfo(server.url)\n \n         if (queueResult.success) {\n           console.log(`   📊 队列信息: 运行中 ${queueResult.running} | 等待中 ${queueResult.pending} | 总计 ${queueResult.total}`)\n+          console.log(`   🔗 队列端点: ${queueResult.endpoint}`)\n \n           const queueStatus = queueResult.total === 0 ? '🟢 空闲' :\n                             queueResult.running > 0 ? '🟡 繁忙' : '🔴 队列满'\n           console.log(`   📈 服务器状态: ${queueStatus}`)\n"
                },
                {
                    "date": 1752520832460,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,11 @@\n /**\n- * ComfyUI 负载均衡器 - 重写版本\n- * 使用直接连接测试作为健康判断标准\n+ * ComfyUI 负载均衡器 - 完全重写版本\n+ * 简单直接的逻辑：选择可直连且队列最少的服务器\n  */\n class LoadBalancer {\n   constructor() {\n-    this.connectionTimeout = 10000 // 10秒连接超时\n+    this.connectionTimeout = 8000 // 8秒连接超时\n   }\n \n   /**\n    * 初始化负载均衡器\n@@ -15,41 +15,31 @@\n     return true\n   }\n \n   /**\n-   * 获取服务器列表\n+   * 获取所有配置的服务器列表\n    */\n   async getServerList() {\n     const servers = []\n \n     // 主服务器\n     const primaryServer = window.getConfig?.('comfyui.server_url')\n     if (primaryServer && primaryServer.trim()) {\n-      servers.push({\n-        url: primaryServer.trim(),\n-        type: 'primary',\n-        priority: 1\n-      })\n+      servers.push(primaryServer.trim())\n     }\n \n-    // 备用服务器\n+    // 备用服务器（换行符分隔）\n     const backupServersConfig = window.getConfig?.('comfyui.backup_servers')\n     if (backupServersConfig && backupServersConfig.trim()) {\n       const backupServers = backupServersConfig\n-        .replace(/\\s*,\\s*/g, '\\n')\n         .split('\\n')\n         .map(url => url.trim())\n         .filter(url => url && url.startsWith('http'))\n \n-      backupServers.forEach((url, index) => {\n-        servers.push({\n-          url,\n-          type: 'backup',\n-          priority: index + 2\n-        })\n-      })\n+      servers.push(...backupServers)\n     }\n \n+    console.log(`📋 配置的服务器列表 (${servers.length}个):`, servers)\n     return servers\n   }\n \n   /**\n"
                },
                {
                    "date": 1752520851796,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,12 +42,14 @@\n     return servers\n   }\n \n   /**\n-   * 直接连接测试 - 简单有效的健康检查\n+   * 测试服务器是否可直连\n    */\n-  async testDirectConnection(serverUrl) {\n+  async testConnection(serverUrl) {\n     try {\n+      console.log(`🔍 测试连接: ${serverUrl}`)\n+\n       const controller = new AbortController()\n       const timeoutId = setTimeout(() => controller.abort(), this.connectionTimeout)\n \n       const startTime = Date.now()\n@@ -62,19 +64,19 @@\n \n       clearTimeout(timeoutId)\n       const responseTime = Date.now() - startTime\n \n-      // 只要能连接就认为健康，不管返回什么状态码\n+      console.log(`✅ 连接成功: ${serverUrl} (${responseTime}ms, 状态: ${response.status})`)\n       return {\n-        healthy: true,\n+        success: true,\n         responseTime,\n         status: response.status\n       }\n \n     } catch (error) {\n-      // 只有真正的连接失败才认为不健康\n+      console.log(`❌ 连接失败: ${serverUrl} - ${error.message}`)\n       return {\n-        healthy: false,\n+        success: false,\n         error: error.message\n       }\n     }\n   }\n"
                },
                {
                    "date": 1752520880792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -81,99 +81,66 @@\n     }\n   }\n \n   /**\n-   * 检测服务器API前缀\n+   * 获取服务器队列信息\n    */\n-  async detectApiPrefix(serverUrl) {\n-    const testEndpoints = ['/api/queue', '/queue']\n+  async getQueueInfo(serverUrl) {\n+    // 尝试两种可能的端点\n+    const endpoints = ['/api/queue', '/queue']\n \n-    for (const endpoint of testEndpoints) {\n+    for (const endpoint of endpoints) {\n       try {\n+        console.log(`📊 获取队列信息: ${serverUrl}${endpoint}`)\n+\n         const controller = new AbortController()\n-        const timeoutId = setTimeout(() => controller.abort(), 3000)\n+        const timeoutId = setTimeout(() => controller.abort(), this.connectionTimeout)\n \n-        const response = await fetch(`${serverUrl.replace(/\\/$/, '')}${endpoint}`, {\n+        const response = await fetch(`${serverUrl}${endpoint}`, {\n           method: 'GET',\n           signal: controller.signal,\n           headers: {\n             'Accept': '*/*',\n-            'comfy-user': 'prefix-detector'\n-          },\n-          mode: 'cors',\n-          credentials: 'omit'\n+            'comfy-user': 'loadbalancer-client'\n+          }\n         })\n \n         clearTimeout(timeoutId)\n \n         if (response.ok) {\n-          const apiPrefix = endpoint.startsWith('/api/') ? '/api' : ''\n-          console.log(`🔍 检测到API前缀: ${apiPrefix || '(无前缀)'}`)\n-          return apiPrefix\n+          const data = await response.json()\n+\n+          // 解析队列数据\n+          let running = 0, pending = 0, total = 0\n+\n+          if (data.queue_running !== undefined && data.queue_pending !== undefined) {\n+            running = Array.isArray(data.queue_running) ? data.queue_running.length : data.queue_running\n+            pending = Array.isArray(data.queue_pending) ? data.queue_pending.length : data.queue_pending\n+            total = running + pending\n+          }\n+\n+          console.log(`✅ 队列信息获取成功: ${serverUrl}${endpoint} - 运行:${running}, 等待:${pending}, 总计:${total}`)\n+          return {\n+            running,\n+            pending,\n+            total,\n+            success: true,\n+            endpoint: `${serverUrl}${endpoint}`\n+          }\n         }\n       } catch (error) {\n-        // 继续尝试下一个端点\n+        console.log(`❌ 队列信息获取失败: ${serverUrl}${endpoint} - ${error.message}`)\n         continue\n       }\n     }\n \n-    console.log('🔍 无法检测API前缀，使用默认')\n-    return '' // 默认无前缀\n-  }\n-\n-  /**\n-   * 获取队列信息 - 支持API前缀自动检测\n-   */\n-  async getQueueInfo(serverUrl) {\n-    try {\n-      // 检测API前缀\n-      const apiPrefix = await this.detectApiPrefix(serverUrl)\n-\n-      const controller = new AbortController()\n-      const timeoutId = setTimeout(() => controller.abort(), this.connectionTimeout)\n-\n-      const queueUrl = `${serverUrl.replace(/\\/$/, '')}${apiPrefix}/queue`\n-      const response = await fetch(queueUrl, {\n-        method: 'GET',\n-        signal: controller.signal,\n-        headers: {\n-          'Accept': '*/*',\n-          'Cache-Control': 'max-age=0',\n-          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',\n-          'comfy-user': 'loadbalancer-client'\n-        },\n-        mode: 'cors',\n-        credentials: 'omit'\n-      })\n-\n-      clearTimeout(timeoutId)\n-\n-      if (response.ok) {\n-        const data = await response.json()\n-\n-        // 解析队列数据\n-        let running = 0, pending = 0, total = 0\n-\n-        if (data.queue_running !== undefined && data.queue_pending !== undefined) {\n-          running = Array.isArray(data.queue_running) ? data.queue_running.length : data.queue_running\n-          pending = Array.isArray(data.queue_pending) ? data.queue_pending.length : data.queue_pending\n-          total = running + pending\n-        }\n-\n-        return {\n-          running,\n-          pending,\n-          total,\n-          success: true,\n-          apiPrefix,\n-          endpoint: queueUrl\n-        }\n-      } else {\n-        return { running: 0, pending: 0, total: 1, success: false, error: `HTTP ${response.status}` }\n-      }\n-\n-    } catch (error) {\n-      return { running: 0, pending: 0, total: 1, success: false, error: error.message }\n+    console.log(`⚠️ 所有队列端点都失败: ${serverUrl}`)\n+    return {\n+      running: 0,\n+      pending: 0,\n+      total: 999, // 设置一个很大的值，让这个服务器优先级降低\n+      success: false,\n+      error: '无法获取队列信息'\n     }\n   }\n \n   /**\n"
                },
                {
                    "date": 1752520924360,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -143,125 +143,77 @@\n     }\n   }\n \n   /**\n-   * 页面加载时初始化服务器连接测试\n+   * 核心方法：选择可用的最优服务器\n    */\n-  async initializeServerConnection() {\n-    console.log('🚀 正在初始化 ComfyUI 服务器连接...')\n-    console.log('=' .repeat(60))\n+  async selectOptimalServer() {\n+    console.log('🎯 开始选择最优服务器...')\n \n-    const servers = await this.getServerList()\n-\n-    if (servers.length === 0) {\n-      console.warn('⚠️ 未找到任何配置的服务器')\n-      return null\n+    // 1. 获取所有配置的服务器\n+    const allServers = await this.getServerList()\n+    if (allServers.length === 0) {\n+      throw new Error('没有配置任何服务器')\n     }\n \n-    console.log(`📋 发现 ${servers.length} 个配置的服务器:`)\n-    servers.forEach((server, index) => {\n-      console.log(`   ${index + 1}. ${server.url} (${server.type === 'primary' ? '主服务器' : '备用服务器'}, 优先级: ${server.priority})`)\n-    })\n-    console.log('')\n+    console.log(`📋 总共 ${allServers.length} 个服务器需要测试`)\n \n-    console.log('🔍 开始服务器连接测试...')\n-    console.log('-' .repeat(60))\n+    // 2. 测试所有服务器的连接性\n+    const availableServers = []\n \n-    const serverResults = []\n+    for (const serverUrl of allServers) {\n+      const connectionResult = await this.testConnection(serverUrl)\n \n-    for (const server of servers) {\n-      console.log(`\\n🖥️  测试服务器: ${server.url}`)\n-      console.log(`   类型: ${server.type === 'primary' ? '主服务器' : '备用服务器'} | 优先级: ${server.priority}`)\n+      if (connectionResult.success) {\n+        // 连接成功，获取队列信息\n+        const queueInfo = await this.getQueueInfo(serverUrl)\n \n-      // 直接连接测试\n-      const healthResult = await this.testDirectConnection(server.url)\n-\n-      if (healthResult.healthy) {\n-        console.log(`   ✅ 连接测试: 成功 (${healthResult.responseTime}ms, 状态码: ${healthResult.status})`)\n-\n-        // 获取队列信息\n-        const queueResult = await this.getQueueInfo(server.url)\n-\n-        if (queueResult.success) {\n-          console.log(`   📊 队列信息: 运行中 ${queueResult.running} | 等待中 ${queueResult.pending} | 总计 ${queueResult.total}`)\n-          console.log(`   🔗 队列端点: ${queueResult.endpoint}`)\n-\n-          const queueStatus = queueResult.total === 0 ? '🟢 空闲' :\n-                            queueResult.running > 0 ? '🟡 繁忙' : '🔴 队列满'\n-          console.log(`   📈 服务器状态: ${queueStatus}`)\n-\n-          serverResults.push({\n-            ...server,\n-            healthy: true,\n-            responseTime: healthResult.responseTime,\n-            queue: queueResult\n-          })\n-        } else {\n-          console.log(`   ⚠️ 队列信息: 获取失败 (${queueResult.error})`)\n-          console.log(`   📈 服务器状态: 🟡 可用但队列信息未知`)\n-\n-          serverResults.push({\n-            ...server,\n-            healthy: true,\n-            responseTime: healthResult.responseTime,\n-            queue: { running: 0, pending: 0, total: 1, success: false }\n-          })\n-        }\n-      } else {\n-        console.log(`   ❌ 连接测试: 失败 (${healthResult.error})`)\n-        console.log(`   📈 服务器状态: 🔴 不可用`)\n-\n-        serverResults.push({\n-          ...server,\n-          healthy: false,\n-          error: healthResult.error\n+        availableServers.push({\n+          url: serverUrl,\n+          responseTime: connectionResult.responseTime,\n+          queue: queueInfo\n         })\n       }\n     }\n \n-    // 输出测试结果汇总\n-    console.log('\\n' + '=' .repeat(60))\n-    const healthyServers = serverResults.filter(s => s.healthy)\n-    console.log(`📊 服务器连接测试完成: ${healthyServers.length}/${serverResults.length} 个服务器可用`)\n+    console.log(`✅ 可连接的服务器: ${availableServers.length}/${allServers.length}`)\n \n-    // 详细的服务器状态表格\n-    console.log('\\n📋 服务器状态汇总:')\n-    console.log('   状态 | 类型     | 服务器URL                    | 队列(运行/等待/总计) | 响应时间')\n-    console.log('   -----|----------|------------------------------|---------------------|----------')\n+    // 3. 如果没有可用服务器，抛出错误\n+    if (availableServers.length === 0) {\n+      throw new Error('没有可连接的服务器')\n+    }\n \n-    serverResults.forEach(server => {\n-      const status = server.healthy ? '✅' : '❌'\n-      const type = server.type === 'primary' ? '主服务器' : '备用    '\n-      const url = server.url.length > 28 ? server.url.substring(0, 25) + '...' : server.url.padEnd(28)\n-      const queueInfo = server.queue ?\n-        `${(server.queue.running || 0).toString().padStart(2)}/${(server.queue.pending || 0).toString().padStart(2)}/${(server.queue.total || 0).toString().padStart(2)}`.padEnd(19) :\n-        'N/A'.padEnd(19)\n-      const responseTime = server.responseTime ? `${server.responseTime}ms` : 'N/A'\n-\n-      console.log(`   ${status} | ${type} | ${url} | ${queueInfo} | ${responseTime}`)\n+    // 4. 按队列数量排序，选择队列最少的服务器\n+    const sortedServers = availableServers.sort((a, b) => {\n+      return a.queue.total - b.queue.total\n     })\n \n-    // 选择最优服务器\n-    if (healthyServers.length > 0) {\n-      const bestServer = healthyServers.sort((a, b) => {\n-        const queueDiff = (a.queue?.total || 0) - (b.queue?.total || 0)\n-        if (queueDiff !== 0) return queueDiff\n-        return a.priority - b.priority\n-      })[0]\n+    const selectedServer = sortedServers[0]\n \n-      console.log('\\n🎯 最优服务器选择结果:')\n-      console.log(`   选择服务器: ${bestServer.url}`)\n-      console.log(`   选择原因: ${bestServer.type === 'primary' ? '主服务器' : '备用服务器'} | 队列最少 (${bestServer.queue?.total || 0} 个任务)`)\n-      console.log(`   队列详情: 运行中 ${bestServer.queue?.running || 0} | 等待中 ${bestServer.queue?.pending || 0}`)\n-      console.log(`   响应时间: ${bestServer.responseTime}ms`)\n-      console.log(`   优先级: ${bestServer.priority}`)\n+    console.log('🎯 服务器选择结果:')\n+    console.log(`   选择的服务器: ${selectedServer.url}`)\n+    console.log(`   队列信息: 运行中 ${selectedServer.queue.running} | 等待中 ${selectedServer.queue.pending} | 总计 ${selectedServer.queue.total}`)\n+    console.log(`   响应时间: ${selectedServer.responseTime}ms`)\n \n+    return selectedServer.url\n+  }\n+\n+  /**\n+   * 页面加载时初始化服务器连接测试\n+   */\n+  async initializeServerConnection() {\n+    console.log('🚀 正在初始化 ComfyUI 服务器连接...')\n+    console.log('=' .repeat(60))\n+\n+    try {\n+      const selectedServer = await this.selectOptimalServer()\n+\n       console.log('\\n✅ 服务器初始化完成，系统已准备就绪！')\n       console.log('=' .repeat(60))\n \n-      return bestServer.url\n-    } else {\n-      console.log('\\n❌ 服务器选择结果: 所有服务器都不可用')\n+      return selectedServer\n+    } catch (error) {\n+      console.log('\\n❌ 服务器选择失败:', error.message)\n       console.log('💡 建议: 请检查服务器配置或网络连接')\n       console.log('=' .repeat(60))\n       return null\n     }\n"
                },
                {
                    "date": 1752520944954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -219,60 +219,27 @@\n     }\n   }\n \n   /**\n-   * 选择最优服务器（用于生图请求）\n+   * 获取最优服务器（用于生图请求）\n    */\n   async getOptimalServer() {\n-    console.log('🎯 选择最优服务器 (用于生图请求)...')\n+    console.log('🎯 获取最优服务器 (用于生图请求)...')\n \n-    const servers = await this.getServerList()\n+    try {\n+      return await this.selectOptimalServer()\n+    } catch (error) {\n+      console.error('❌ 获取最优服务器失败:', error.message)\n \n-    if (servers.length === 0) {\n-      throw new Error('没有可用的服务器配置')\n-    }\n-\n-    const serverResults = []\n-\n-    for (const server of servers) {\n-      // 直接连接测试\n-      const healthResult = await this.testDirectConnection(server.url)\n-\n-      if (healthResult.healthy) {\n-        // 获取队列信息\n-        const queueResult = await this.getQueueInfo(server.url)\n-\n-        serverResults.push({\n-          ...server,\n-          healthy: true,\n-          responseTime: healthResult.responseTime,\n-          queue: queueResult\n-        })\n-      } else {\n-        serverResults.push({\n-          ...server,\n-          healthy: false,\n-          error: healthResult.error\n-        })\n+      // 备用方案：返回第一个配置的服务器\n+      const servers = await this.getServerList()\n+      if (servers.length > 0) {\n+        console.log(`⚠️ 使用备用方案，返回第一个服务器: ${servers[0]}`)\n+        return servers[0]\n       }\n-    }\n \n-    const healthyServers = serverResults.filter(s => s.healthy)\n-\n-    if (healthyServers.length === 0) {\n-      console.warn('⚠️ 没有健康的服务器可用')\n-      return servers[0]?.url || null\n+      throw new Error('没有可用的服务器')\n     }\n-\n-    const bestServer = healthyServers.sort((a, b) => {\n-      const queueDiff = (a.queue?.total || 0) - (b.queue?.total || 0)\n-      if (queueDiff !== 0) return queueDiff\n-      return a.priority - b.priority\n-    })[0]\n-\n-    console.log(`🎯 选择服务器: ${bestServer.url} (队列: ${bestServer.queue?.total || 0}, 响应时间: ${bestServer.responseTime}ms)`)\n-\n-    return bestServer.url\n   }\n }\n \n // 创建单例实例\n"
                },
                {
                    "date": 1752544154145,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,9 +42,9 @@\n     return servers\n   }\n \n   /**\n-   * 测试服务器是否可直连\n+   * 测试服务器是否可直连 - 使用正确的ComfyUI端点\n    */\n   async testConnection(serverUrl) {\n     try {\n       console.log(`🔍 测试连接: ${serverUrl}`)\n@@ -52,15 +52,23 @@\n       const controller = new AbortController()\n       const timeoutId = setTimeout(() => controller.abort(), this.connectionTimeout)\n \n       const startTime = Date.now()\n-      const response = await fetch(serverUrl, {\n+\n+      // 清理URL，确保没有尾部斜杠\n+      const cleanUrl = serverUrl.replace(/\\/$/, '')\n+\n+      const response = await fetch(cleanUrl, {\n         method: 'HEAD',\n         signal: controller.signal,\n         headers: {\n           'Accept': '*/*',\n-          'Cache-Control': 'no-cache'\n-        }\n+          'Cache-Control': 'no-cache',\n+          'comfy-user': 'loadbalancer-client',\n+          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36'\n+        },\n+        mode: 'cors',\n+        credentials: 'omit'\n       })\n \n       clearTimeout(timeoutId)\n       const responseTime = Date.now() - startTime\n"
                },
                {
                    "date": 1752544181669,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,60 +89,69 @@\n     }\n   }\n \n   /**\n-   * 获取服务器队列信息\n+   * 获取服务器队列信息 - 使用正确的ComfyUI API端点\n    */\n   async getQueueInfo(serverUrl) {\n-    // 尝试两种可能的端点\n+    // 尝试两种可能的端点，优先使用/api/queue\n     const endpoints = ['/api/queue', '/queue']\n \n+    // 清理URL，确保没有尾部斜杠\n+    const cleanUrl = serverUrl.replace(/\\/$/, '')\n+\n     for (const endpoint of endpoints) {\n       try {\n-        console.log(`📊 获取队列信息: ${serverUrl}${endpoint}`)\n+        const fullUrl = `${cleanUrl}${endpoint}`\n+        console.log(`📊 获取队列信息: ${fullUrl}`)\n \n         const controller = new AbortController()\n         const timeoutId = setTimeout(() => controller.abort(), this.connectionTimeout)\n \n-        const response = await fetch(`${serverUrl}${endpoint}`, {\n+        const response = await fetch(fullUrl, {\n           method: 'GET',\n           signal: controller.signal,\n           headers: {\n             'Accept': '*/*',\n-            'comfy-user': 'loadbalancer-client'\n-          }\n+            'Cache-Control': 'max-age=0',\n+            'comfy-user': 'loadbalancer-client',\n+            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36'\n+          },\n+          mode: 'cors',\n+          credentials: 'omit'\n         })\n \n         clearTimeout(timeoutId)\n \n         if (response.ok) {\n           const data = await response.json()\n \n-          // 解析队列数据\n+          // 解析队列数据 - 根据ComfyUI API文档\n           let running = 0, pending = 0, total = 0\n \n           if (data.queue_running !== undefined && data.queue_pending !== undefined) {\n             running = Array.isArray(data.queue_running) ? data.queue_running.length : data.queue_running\n             pending = Array.isArray(data.queue_pending) ? data.queue_pending.length : data.queue_pending\n             total = running + pending\n           }\n \n-          console.log(`✅ 队列信息获取成功: ${serverUrl}${endpoint} - 运行:${running}, 等待:${pending}, 总计:${total}`)\n+          console.log(`✅ 队列信息获取成功: ${fullUrl} - 运行:${running}, 等待:${pending}, 总计:${total}`)\n           return {\n             running,\n             pending,\n             total,\n             success: true,\n-            endpoint: `${serverUrl}${endpoint}`\n+            endpoint: fullUrl,\n+            apiPrefix: endpoint.startsWith('/api/') ? '/api' : ''\n           }\n         }\n       } catch (error) {\n-        console.log(`❌ 队列信息获取失败: ${serverUrl}${endpoint} - ${error.message}`)\n+        console.log(`❌ 队列信息获取失败: ${fullUrl} - ${error.message}`)\n         continue\n       }\n     }\n \n-    console.log(`⚠️ 所有队列端点都失败: ${serverUrl}`)\n+    console.log(`⚠️ 所有队列端点都失败: ${cleanUrl}`)\n     return {\n       running: 0,\n       pending: 0,\n       total: 999, // 设置一个很大的值，让这个服务器优先级降低\n"
                },
                {
                    "date": 1752544292221,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,18 +1,19 @@\n /**\n- * ComfyUI 负载均衡器 - 完全重写版本\n- * 简单直接的逻辑：选择可直连且队列最少的服务器\n+ * ComfyUI 服务器健康监测器\n+ * 专注于基础的服务器连接测试，移除复杂的负载均衡策略\n  */\n-class LoadBalancer {\n+class ServerHealthMonitor {\n   constructor() {\n-    this.connectionTimeout = 8000 // 8秒连接超时\n+    this.connectionTimeout = 10000 // 10秒连接超时\n+    this.healthCheckResults = new Map() // 缓存健康检查结果\n   }\n \n   /**\n-   * 初始化负载均衡器\n+   * 初始化健康监测器\n    */\n   async initialize() {\n-    console.log('🔧 初始化负载均衡器...')\n+    console.log('🔧 初始化服务器健康监测器...')\n     return true\n   }\n \n   /**\n"
                },
                {
                    "date": 1752544317266,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,50 +43,81 @@\n     return servers\n   }\n \n   /**\n-   * 测试服务器是否可直连 - 使用正确的ComfyUI端点\n+   * 测试服务器基础连接 - 使用多种方法确保准确性\n    */\n-  async testConnection(serverUrl) {\n+  async testBasicConnection(serverUrl) {\n+    const cleanUrl = serverUrl.replace(/\\/$/, '')\n+    console.log(`🔍 测试基础连接: ${cleanUrl}`)\n+\n+    // 方法1: 尝试根路径\n     try {\n-      console.log(`🔍 测试连接: ${serverUrl}`)\n-\n       const controller = new AbortController()\n       const timeoutId = setTimeout(() => controller.abort(), this.connectionTimeout)\n \n       const startTime = Date.now()\n-\n-      // 清理URL，确保没有尾部斜杠\n-      const cleanUrl = serverUrl.replace(/\\/$/, '')\n-\n       const response = await fetch(cleanUrl, {\n         method: 'HEAD',\n         signal: controller.signal,\n         headers: {\n           'Accept': '*/*',\n           'Cache-Control': 'no-cache',\n-          'comfy-user': 'loadbalancer-client',\n-          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36'\n+          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n         },\n         mode: 'cors',\n         credentials: 'omit'\n       })\n \n       clearTimeout(timeoutId)\n       const responseTime = Date.now() - startTime\n \n-      console.log(`✅ 连接成功: ${serverUrl} (${responseTime}ms, 状态: ${response.status})`)\n+      if (response.ok || response.status === 404) { // 404也算连接成功\n+        console.log(`✅ 基础连接成功: ${cleanUrl} (${responseTime}ms, 状态: ${response.status})`)\n+        return {\n+          success: true,\n+          responseTime,\n+          status: response.status,\n+          method: 'HEAD /'\n+        }\n+      }\n+    } catch (error) {\n+      console.log(`⚠️ HEAD请求失败: ${error.message}`)\n+    }\n+\n+    // 方法2: 尝试GET请求根路径\n+    try {\n+      const controller = new AbortController()\n+      const timeoutId = setTimeout(() => controller.abort(), this.connectionTimeout)\n+\n+      const startTime = Date.now()\n+      const response = await fetch(cleanUrl, {\n+        method: 'GET',\n+        signal: controller.signal,\n+        headers: {\n+          'Accept': '*/*',\n+          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n+        },\n+        mode: 'cors',\n+        credentials: 'omit'\n+      })\n+\n+      clearTimeout(timeoutId)\n+      const responseTime = Date.now() - startTime\n+\n+      console.log(`✅ GET连接成功: ${cleanUrl} (${responseTime}ms, 状态: ${response.status})`)\n       return {\n         success: true,\n         responseTime,\n-        status: response.status\n+        status: response.status,\n+        method: 'GET /'\n       }\n-\n     } catch (error) {\n-      console.log(`❌ 连接失败: ${serverUrl} - ${error.message}`)\n+      console.log(`❌ 连接完全失败: ${cleanUrl} - ${error.message}`)\n       return {\n         success: false,\n-        error: error.message\n+        error: error.message,\n+        method: 'ALL_FAILED'\n       }\n     }\n   }\n \n"
                },
                {
                    "date": 1752544375595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -121,75 +121,71 @@\n     }\n   }\n \n   /**\n-   * 获取服务器队列信息 - 使用正确的ComfyUI API端点\n+   * 测试ComfyUI API端点 - 专门测试队列端点的可用性\n    */\n-  async getQueueInfo(serverUrl) {\n-    // 尝试两种可能的端点，优先使用/api/queue\n-    const endpoints = ['/api/queue', '/queue']\n-\n-    // 清理URL，确保没有尾部斜杠\n+  async testComfyUIEndpoints(serverUrl) {\n     const cleanUrl = serverUrl.replace(/\\/$/, '')\n+    const endpoints = ['/api/queue', '/queue'] // 优先测试 /api/queue\n \n+    console.log(`🔍 测试ComfyUI端点: ${cleanUrl}`)\n+\n     for (const endpoint of endpoints) {\n       try {\n         const fullUrl = `${cleanUrl}${endpoint}`\n-        console.log(`📊 获取队列信息: ${fullUrl}`)\n+        console.log(`   测试端点: ${endpoint}`)\n \n         const controller = new AbortController()\n         const timeoutId = setTimeout(() => controller.abort(), this.connectionTimeout)\n \n         const response = await fetch(fullUrl, {\n           method: 'GET',\n           signal: controller.signal,\n           headers: {\n-            'Accept': '*/*',\n-            'Cache-Control': 'max-age=0',\n-            'comfy-user': 'loadbalancer-client',\n-            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36'\n+            'Accept': 'application/json, */*',\n+            'Cache-Control': 'no-cache',\n+            'comfy-user': 'health-monitor',\n+            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n           },\n           mode: 'cors',\n           credentials: 'omit'\n         })\n \n         clearTimeout(timeoutId)\n \n         if (response.ok) {\n-          const data = await response.json()\n+          // 尝试解析JSON响应\n+          try {\n+            const data = await response.json()\n+            console.log(`✅ ComfyUI端点可用: ${endpoint}`)\n+            console.log(`   响应数据结构:`, Object.keys(data))\n \n-          // 解析队列数据 - 根据ComfyUI API文档\n-          let running = 0, pending = 0, total = 0\n-\n-          if (data.queue_running !== undefined && data.queue_pending !== undefined) {\n-            running = Array.isArray(data.queue_running) ? data.queue_running.length : data.queue_running\n-            pending = Array.isArray(data.queue_pending) ? data.queue_pending.length : data.queue_pending\n-            total = running + pending\n+            return {\n+              success: true,\n+              endpoint,\n+              fullUrl,\n+              status: response.status,\n+              hasQueueData: !!(data.queue_running !== undefined || data.queue_pending !== undefined),\n+              apiPrefix: endpoint.startsWith('/api/') ? '/api' : '',\n+              data: data\n+            }\n+          } catch (jsonError) {\n+            console.log(`⚠️ 端点响应但JSON解析失败: ${endpoint} - ${jsonError.message}`)\n+            continue\n           }\n-\n-          console.log(`✅ 队列信息获取成功: ${fullUrl} - 运行:${running}, 等待:${pending}, 总计:${total}`)\n-          return {\n-            running,\n-            pending,\n-            total,\n-            success: true,\n-            endpoint: fullUrl,\n-            apiPrefix: endpoint.startsWith('/api/') ? '/api' : ''\n-          }\n+        } else {\n+          console.log(`⚠️ 端点响应错误: ${endpoint} (状态: ${response.status})`)\n         }\n       } catch (error) {\n-        console.log(`❌ 队列信息获取失败: ${fullUrl} - ${error.message}`)\n+        console.log(`❌ 端点测试失败: ${endpoint} - ${error.message}`)\n         continue\n       }\n     }\n \n-    console.log(`⚠️ 所有队列端点都失败: ${cleanUrl}`)\n     return {\n-      running: 0,\n-      pending: 0,\n-      total: 999, // 设置一个很大的值，让这个服务器优先级降低\n       success: false,\n-      error: '无法获取队列信息'\n+      error: '所有ComfyUI端点都不可用'\n     }\n   }\n \n   /**\n"
                },
                {
                    "date": 1752544401822,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -188,59 +188,61 @@\n     }\n   }\n \n   /**\n-   * 核心方法：选择可用的最优服务器\n+   * 执行完整的服务器健康检查\n    */\n-  async selectOptimalServer() {\n-    console.log('🎯 开始选择最优服务器...')\n+  async performHealthCheck(serverUrl) {\n+    console.log(`\\n🏥 开始健康检查: ${serverUrl}`)\n+    console.log('=' .repeat(50))\n \n-    // 1. 获取所有配置的服务器\n-    const allServers = await this.getServerList()\n-    if (allServers.length === 0) {\n-      throw new Error('没有配置任何服务器')\n+    const healthResult = {\n+      url: serverUrl,\n+      timestamp: new Date().toISOString(),\n+      basicConnection: null,\n+      comfyuiEndpoints: null,\n+      overall: false,\n+      errors: []\n     }\n \n-    console.log(`📋 总共 ${allServers.length} 个服务器需要测试`)\n+    try {\n+      // 1. 基础连接测试\n+      console.log('1️⃣ 测试基础连接...')\n+      healthResult.basicConnection = await this.testBasicConnection(serverUrl)\n \n-    // 2. 测试所有服务器的连接性\n-    const availableServers = []\n+      if (!healthResult.basicConnection.success) {\n+        healthResult.errors.push('基础连接失败')\n+        console.log('❌ 基础连接失败，跳过后续测试')\n+        return healthResult\n+      }\n \n-    for (const serverUrl of allServers) {\n-      const connectionResult = await this.testConnection(serverUrl)\n+      // 2. ComfyUI端点测试\n+      console.log('2️⃣ 测试ComfyUI端点...')\n+      healthResult.comfyuiEndpoints = await this.testComfyUIEndpoints(serverUrl)\n \n-      if (connectionResult.success) {\n-        // 连接成功，获取队列信息\n-        const queueInfo = await this.getQueueInfo(serverUrl)\n-\n-        availableServers.push({\n-          url: serverUrl,\n-          responseTime: connectionResult.responseTime,\n-          queue: queueInfo\n-        })\n+      if (!healthResult.comfyuiEndpoints.success) {\n+        healthResult.errors.push('ComfyUI端点不可用')\n       }\n-    }\n \n-    console.log(`✅ 可连接的服务器: ${availableServers.length}/${allServers.length}`)\n+      // 3. 综合评估\n+      healthResult.overall = healthResult.basicConnection.success && healthResult.comfyuiEndpoints.success\n \n-    // 3. 如果没有可用服务器，抛出错误\n-    if (availableServers.length === 0) {\n-      throw new Error('没有可连接的服务器')\n-    }\n+      console.log(`\\n📊 健康检查结果: ${healthResult.overall ? '✅ 健康' : '❌ 不健康'}`)\n+      if (healthResult.errors.length > 0) {\n+        console.log(`⚠️ 问题: ${healthResult.errors.join(', ')}`)\n+      }\n+      console.log('=' .repeat(50))\n \n-    // 4. 按队列数量排序，选择队列最少的服务器\n-    const sortedServers = availableServers.sort((a, b) => {\n-      return a.queue.total - b.queue.total\n-    })\n+      // 缓存结果\n+      this.healthCheckResults.set(serverUrl, healthResult)\n \n-    const selectedServer = sortedServers[0]\n+      return healthResult\n \n-    console.log('🎯 服务器选择结果:')\n-    console.log(`   选择的服务器: ${selectedServer.url}`)\n-    console.log(`   队列信息: 运行中 ${selectedServer.queue.running} | 等待中 ${selectedServer.queue.pending} | 总计 ${selectedServer.queue.total}`)\n-    console.log(`   响应时间: ${selectedServer.responseTime}ms`)\n-\n-    return selectedServer.url\n+    } catch (error) {\n+      console.error(`❌ 健康检查异常: ${error.message}`)\n+      healthResult.errors.push(`检查异常: ${error.message}`)\n+      return healthResult\n+    }\n   }\n \n   /**\n    * 页面加载时初始化服务器连接测试\n"
                },
                {
                    "date": 1752544427433,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -244,49 +244,74 @@\n     }\n   }\n \n   /**\n-   * 页面加载时初始化服务器连接测试\n+   * 检查所有配置的服务器健康状态\n    */\n-  async initializeServerConnection() {\n-    console.log('🚀 正在初始化 ComfyUI 服务器连接...')\n-    console.log('=' .repeat(60))\n+  async checkAllServers() {\n+    console.log('\\n🚀 开始检查所有服务器健康状态...')\n \n-    try {\n-      const selectedServer = await this.selectOptimalServer()\n+    const servers = await this.getServerList()\n+    if (servers.length === 0) {\n+      console.log('❌ 没有配置任何服务器')\n+      return []\n+    }\n \n-      console.log('\\n✅ 服务器初始化完成，系统已准备就绪！')\n-      console.log('=' .repeat(60))\n+    console.log(`📋 发现 ${servers.length} 个配置的服务器`)\n \n-      return selectedServer\n-    } catch (error) {\n-      console.log('\\n❌ 服务器选择失败:', error.message)\n-      console.log('💡 建议: 请检查服务器配置或网络连接')\n-      console.log('=' .repeat(60))\n-      return null\n+    const results = []\n+    for (const serverUrl of servers) {\n+      const healthResult = await this.performHealthCheck(serverUrl)\n+      results.push(healthResult)\n     }\n+\n+    // 汇总结果\n+    const healthyServers = results.filter(r => r.overall)\n+    const unhealthyServers = results.filter(r => !r.overall)\n+\n+    console.log('\\n📊 健康检查汇总:')\n+    console.log(`✅ 健康服务器: ${healthyServers.length}`)\n+    console.log(`❌ 不健康服务器: ${unhealthyServers.length}`)\n+\n+    if (healthyServers.length > 0) {\n+      console.log('\\n🟢 健康的服务器:')\n+      healthyServers.forEach(server => {\n+        console.log(`   ✅ ${server.url}`)\n+        if (server.comfyuiEndpoints?.success) {\n+          console.log(`      - ComfyUI端点: ${server.comfyuiEndpoints.endpoint}`)\n+          console.log(`      - API前缀: ${server.comfyuiEndpoints.apiPrefix || '无'}`)\n+        }\n+      })\n+    }\n+\n+    if (unhealthyServers.length > 0) {\n+      console.log('\\n🔴 不健康的服务器:')\n+      unhealthyServers.forEach(server => {\n+        console.log(`   ❌ ${server.url}`)\n+        console.log(`      - 问题: ${server.errors.join(', ')}`)\n+      })\n+    }\n+\n+    return results\n   }\n \n   /**\n-   * 获取最优服务器（用于生图请求）\n+   * 获取第一个健康的服务器（简化版本）\n    */\n-  async getOptimalServer() {\n-    console.log('🎯 获取最优服务器 (用于生图请求)...')\n+  async getFirstHealthyServer() {\n+    console.log('🎯 获取第一个健康的服务器...')\n \n-    try {\n-      return await this.selectOptimalServer()\n-    } catch (error) {\n-      console.error('❌ 获取最优服务器失败:', error.message)\n+    const results = await this.checkAllServers()\n+    const healthyServers = results.filter(r => r.overall)\n \n-      // 备用方案：返回第一个配置的服务器\n-      const servers = await this.getServerList()\n-      if (servers.length > 0) {\n-        console.log(`⚠️ 使用备用方案，返回第一个服务器: ${servers[0]}`)\n-        return servers[0]\n-      }\n+    if (healthyServers.length === 0) {\n+      throw new Error('没有找到健康的服务器')\n+    }\n \n-      throw new Error('没有可用的服务器')\n-    }\n+    const selectedServer = healthyServers[0]\n+    console.log(`✅ 选择服务器: ${selectedServer.url}`)\n+\n+    return selectedServer.url\n   }\n }\n \n // 创建单例实例\n"
                },
                {
                    "date": 1752544438934,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -314,7 +314,7 @@\n   }\n }\n \n // 创建单例实例\n-const loadBalancer = new LoadBalancer()\n+const serverHealthMonitor = new ServerHealthMonitor()\n \n-export default loadBalancer\n+export default serverHealthMonitor\n"
                },
                {
                    "date": 1752545456827,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -121,13 +121,19 @@\n     }\n   }\n \n   /**\n-   * 测试ComfyUI API端点 - 专门测试队列端点的可用性\n+   * 测试ComfyUI API端点 - 基于官方文档的端点检测\n    */\n   async testComfyUIEndpoints(serverUrl) {\n     const cleanUrl = serverUrl.replace(/\\/$/, '')\n-    const endpoints = ['/api/queue', '/queue'] // 优先测试 /api/queue\n+    // 基于ComfyUI官方文档的端点列表，按优先级排序\n+    const endpoints = [\n+      '/api/queue',        // ComfyUI官方队列端点\n+      '/api/system_stats', // ComfyUI官方系统状态端点\n+      '/queue',            // 备用队列端点\n+      '/system_stats'      // 备用系统状态端点\n+    ]\n \n     console.log(`🔍 测试ComfyUI端点: ${cleanUrl}`)\n \n     for (const endpoint of endpoints) {\n@@ -142,11 +148,12 @@\n           method: 'GET',\n           signal: controller.signal,\n           headers: {\n             'Accept': 'application/json, */*',\n+            'Accept-Language': 'zh-CN,zh;q=0.9',\n             'Cache-Control': 'no-cache',\n             'comfy-user': 'health-monitor',\n-            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n+            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0 Safari/537.36'\n           },\n           mode: 'cors',\n           credentials: 'omit'\n         })\n"
                },
                {
                    "date": 1752545471345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,9 +94,11 @@\n         method: 'GET',\n         signal: controller.signal,\n         headers: {\n           'Accept': '*/*',\n-          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n+          'Accept-Language': 'zh-CN,zh;q=0.9',\n+          'Cache-Control': 'max-age=0',\n+          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0 Safari/537.36'\n         },\n         mode: 'cors',\n         credentials: 'omit'\n       })\n"
                },
                {
                    "date": 1752547442869,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,12 @@\n+import {\n+  COMFYUI_HEALTH_CONFIG,\n+  COMFYUI_HEADERS,\n+  HEALTH_STATUS,\n+  validateComfyUIResponse,\n+  getApiPrefix\n+} from '../constants/comfyui-health.js'\n+\n /**\n  * ComfyUI 服务器健康监测器\n  * 专注于基础的服务器连接测试，移除复杂的负载均衡策略\n  */\n"
                },
                {
                    "date": 1752547530163,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,19 +1,13 @@\n-import {\n-  COMFYUI_HEALTH_CONFIG,\n-  COMFYUI_HEADERS,\n-  HEALTH_STATUS,\n-  validateComfyUIResponse,\n-  getApiPrefix\n-} from '../constants/comfyui-health.js'\n+import comfyUIConfig from '../config/comfyui.config.js'\n \n /**\n  * ComfyUI 服务器健康监测器\n- * 专注于基础的服务器连接测试，移除复杂的负载均衡策略\n+ * 使用统一的官方端点配置进行健康检测\n  */\n class ServerHealthMonitor {\n   constructor() {\n-    this.connectionTimeout = 10000 // 10秒连接超时\n+    this.connectionTimeout = comfyUIConfig.HEALTH_CHECK.TIMEOUT\n     this.healthCheckResults = new Map() // 缓存健康检查结果\n   }\n \n   /**\n"
                },
                {
                    "date": 1752547542982,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,8 +14,9 @@\n    * 初始化健康监测器\n    */\n   async initialize() {\n     console.log('🔧 初始化服务器健康监测器...')\n+    console.log('📋 使用官方端点配置:', comfyUIConfig.getHealthCheckEndpoints())\n     return true\n   }\n \n   /**\n"
                },
                {
                    "date": 1752547561263,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -95,14 +95,9 @@\n       const startTime = Date.now()\n       const response = await fetch(cleanUrl, {\n         method: 'GET',\n         signal: controller.signal,\n-        headers: {\n-          'Accept': '*/*',\n-          'Accept-Language': 'zh-CN,zh;q=0.9',\n-          'Cache-Control': 'max-age=0',\n-          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0 Safari/537.36'\n-        },\n+        headers: comfyUIConfig.HEALTH_CHECK.HEADERS,\n         mode: 'cors',\n         credentials: 'omit'\n       })\n \n"
                },
                {
                    "date": 1752547588513,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -121,21 +121,16 @@\n     }\n   }\n \n   /**\n-   * 测试ComfyUI API端点 - 基于官方文档的端点检测\n+   * 测试ComfyUI API端点 - 使用统一的官方端点配置\n    */\n   async testComfyUIEndpoints(serverUrl) {\n     const cleanUrl = serverUrl.replace(/\\/$/, '')\n-    // 基于ComfyUI官方文档的端点列表，按优先级排序\n-    const endpoints = [\n-      '/api/queue',        // ComfyUI官方队列端点\n-      '/api/system_stats', // ComfyUI官方系统状态端点\n-      '/queue',            // 备用队列端点\n-      '/system_stats'      // 备用系统状态端点\n-    ]\n+    const endpoints = comfyUIConfig.getHealthCheckEndpoints()\n \n     console.log(`🔍 测试ComfyUI端点: ${cleanUrl}`)\n+    console.log(`📋 使用端点列表:`, endpoints)\n \n     for (const endpoint of endpoints) {\n       try {\n         const fullUrl = `${cleanUrl}${endpoint}`\n@@ -146,15 +141,9 @@\n \n         const response = await fetch(fullUrl, {\n           method: 'GET',\n           signal: controller.signal,\n-          headers: {\n-            'Accept': 'application/json, */*',\n-            'Accept-Language': 'zh-CN,zh;q=0.9',\n-            'Cache-Control': 'no-cache',\n-            'comfy-user': 'health-monitor',\n-            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0 Safari/537.36'\n-          },\n+          headers: comfyUIConfig.HEALTH_CHECK.HEADERS,\n           mode: 'cors',\n           credentials: 'omit'\n         })\n \n"
                },
                {
                    "date": 1752547612064,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -152,19 +152,29 @@\n         if (response.ok) {\n           // 尝试解析JSON响应\n           try {\n             const data = await response.json()\n-            console.log(`✅ ComfyUI端点可用: ${endpoint}`)\n-            console.log(`   响应数据结构:`, Object.keys(data))\n \n-            return {\n-              success: true,\n-              endpoint,\n-              fullUrl,\n-              status: response.status,\n-              hasQueueData: !!(data.queue_running !== undefined || data.queue_pending !== undefined),\n-              apiPrefix: endpoint.startsWith('/api/') ? '/api' : '',\n-              data: data\n+            // 使用统一的响应验证\n+            const isValidResponse = comfyUIConfig.validateResponse(endpoint, data)\n+\n+            if (isValidResponse) {\n+              console.log(`✅ ComfyUI端点可用: ${endpoint}`)\n+              console.log(`   响应数据结构:`, Object.keys(data))\n+\n+              return {\n+                success: true,\n+                endpoint,\n+                fullUrl,\n+                status: response.status,\n+                hasQueueData: !!(data.queue_running !== undefined || data.queue_pending !== undefined),\n+                apiPrefix: endpoint.startsWith('/api/') ? '/api' : '',\n+                data: data,\n+                validated: true\n+              }\n+            } else {\n+              console.log(`⚠️ 端点响应但验证失败: ${endpoint} - 不是有效的ComfyUI响应`)\n+              continue\n             }\n           } catch (jsonError) {\n             console.log(`⚠️ 端点响应但JSON解析失败: ${endpoint} - ${jsonError.message}`)\n             continue\n"
                },
                {
                    "date": 1752548666532,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,18 @@\n import comfyUIConfig from '../config/comfyui.config.js'\n+import configService from './configService.js'\n \n /**\n- * ComfyUI 服务器健康监测器\n- * 使用统一的官方端点配置进行健康检测\n+ * ComfyUI 负载均衡器\n+ * 使用统一的官方端点配置进行健康检测和服务器选择\n  */\n-class ServerHealthMonitor {\n+class LoadBalancer {\n   constructor() {\n     this.connectionTimeout = comfyUIConfig.HEALTH_CHECK.TIMEOUT\n     this.healthCheckResults = new Map() // 缓存健康检查结果\n+    this.serverList = [] // 服务器列表\n+    this.lastHealthCheck = 0 // 上次健康检查时间\n+    this.healthCheckInterval = 30000 // 30秒检查一次\n   }\n \n   /**\n    * 初始化健康监测器\n"
                },
                {
                    "date": 1752548684116,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,17 +14,75 @@\n     this.healthCheckInterval = 30000 // 30秒检查一次\n   }\n \n   /**\n-   * 初始化健康监测器\n+   * 初始化负载均衡器\n    */\n   async initialize() {\n-    console.log('🔧 初始化服务器健康监测器...')\n+    console.log('🔧 初始化ComfyUI负载均衡器...')\n     console.log('📋 使用官方端点配置:', comfyUIConfig.getHealthCheckEndpoints())\n+\n+    // 获取服务器列表\n+    await this.loadServerList()\n+\n     return true\n   }\n \n   /**\n+   * 加载服务器列表\n+   */\n+  async loadServerList() {\n+    try {\n+      // 从配置服务获取服务器列表\n+      const config = await configService.getConfig()\n+\n+      this.serverList = []\n+\n+      // 主服务器\n+      if (config['comfyui.server_url']) {\n+        this.serverList.push({\n+          url: config['comfyui.server_url'],\n+          type: 'primary',\n+          healthy: null,\n+          lastCheck: 0\n+        })\n+      }\n+\n+      // 备用服务器\n+      if (config['comfyui.backup_servers']) {\n+        const backupServers = config['comfyui.backup_servers']\n+          .split(/[,\\n]/)\n+          .map(url => url.trim())\n+          .filter(url => url && url.startsWith('http'))\n+\n+        backupServers.forEach(url => {\n+          this.serverList.push({\n+            url,\n+            type: 'backup',\n+            healthy: null,\n+            lastCheck: 0\n+          })\n+        })\n+      }\n+\n+      console.log(`📊 加载了 ${this.serverList.length} 个服务器:`)\n+      this.serverList.forEach((server, index) => {\n+        console.log(`   ${index + 1}. ${server.type}: ${server.url}`)\n+      })\n+\n+    } catch (error) {\n+      console.error('❌ 加载服务器列表失败:', error)\n+      // 使用默认服务器\n+      this.serverList = [{\n+        url: comfyUIConfig.BASE_URL,\n+        type: 'default',\n+        healthy: null,\n+        lastCheck: 0\n+      }]\n+    }\n+  }\n+\n+  /**\n    * 获取所有配置的服务器列表\n    */\n   async getServerList() {\n     const servers = []\n"
                },
                {
                    "date": 1752548694981,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -382,7 +382,7 @@\n   }\n }\n \n // 创建单例实例\n-const serverHealthMonitor = new ServerHealthMonitor()\n+const loadBalancer = new LoadBalancer()\n \n-export default serverHealthMonitor\n+export default loadBalancer\n"
                },
                {
                    "date": 1752548714452,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -108,8 +108,83 @@\n     return servers\n   }\n \n   /**\n+   * 获取最优服务器\n+   */\n+  async getOptimalServer() {\n+    // 检查是否需要刷新健康状态\n+    const now = Date.now()\n+    if (now - this.lastHealthCheck > this.healthCheckInterval) {\n+      await this.refreshHealthStatus()\n+      this.lastHealthCheck = now\n+    }\n+\n+    // 优先返回健康的主服务器\n+    const primaryServers = this.serverList.filter(s => s.type === 'primary' && s.healthy === true)\n+    if (primaryServers.length > 0) {\n+      return primaryServers[0].url\n+    }\n+\n+    // 然后返回健康的备用服务器\n+    const backupServers = this.serverList.filter(s => s.type === 'backup' && s.healthy === true)\n+    if (backupServers.length > 0) {\n+      return backupServers[0].url\n+    }\n+\n+    // 如果没有健康的服务器，返回第一个服务器（可能是默认服务器）\n+    if (this.serverList.length > 0) {\n+      console.warn('⚠️ 没有健康的服务器，使用第一个服务器')\n+      return this.serverList[0].url\n+    }\n+\n+    // 最后的备用方案\n+    console.warn('⚠️ 没有配置的服务器，使用默认配置')\n+    return comfyUIConfig.BASE_URL\n+  }\n+\n+  /**\n+   * 刷新所有服务器的健康状态\n+   */\n+  async refreshHealthStatus() {\n+    console.log('🔄 刷新服务器健康状态...')\n+\n+    const promises = this.serverList.map(async (server) => {\n+      try {\n+        const result = await this.testComfyUIEndpoints(server.url)\n+        server.healthy = result.success\n+        server.lastCheck = Date.now()\n+\n+        if (result.success) {\n+          console.log(`✅ 服务器健康: ${server.url}`)\n+        } else {\n+          console.log(`❌ 服务器异常: ${server.url}`)\n+        }\n+      } catch (error) {\n+        server.healthy = false\n+        server.lastCheck = Date.now()\n+        console.log(`❌ 服务器检查失败: ${server.url} - ${error.message}`)\n+      }\n+    })\n+\n+    await Promise.all(promises)\n+  }\n+\n+  /**\n+   * 记录服务器失败\n+   */\n+  async recordFailure(serverUrl, errorType = 'unknown') {\n+    console.log(`📝 记录服务器失败: ${serverUrl} (${errorType})`)\n+\n+    // 找到对应的服务器并标记为不健康\n+    const server = this.serverList.find(s => s.url === serverUrl)\n+    if (server) {\n+      server.healthy = false\n+      server.lastCheck = Date.now()\n+    }\n+  }\n+\n+  /**\n    * 测试服务器基础连接 - 使用多种方法确保准确性\n    */\n   async testBasicConnection(serverUrl) {\n     const cleanUrl = serverUrl.replace(/\\/$/, '')\n"
                },
                {
                    "date": 1752548979128,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,5 @@\n import comfyUIConfig from '../config/comfyui.config.js'\n-import configService from './configService.js'\n \n /**\n  * ComfyUI 负载均衡器\n  * 使用统一的官方端点配置进行健康检测和服务器选择\n"
                },
                {
                    "date": 1752549007788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,17 +30,18 @@\n    * 加载服务器列表\n    */\n   async loadServerList() {\n     try {\n-      // 从配置服务获取服务器列表\n+      // 动态导入配置服务以避免循环依赖\n+      const { default: configService } = await import('./configService.js')\n       const config = await configService.getConfig()\n \n       this.serverList = []\n \n       // 主服务器\n       if (config['comfyui.server_url']) {\n         this.serverList.push({\n-          url: config['comfyui.server_url'],\n+          url: config['comfyui.server_url'].replace(/\\/$/, ''),\n           type: 'primary',\n           healthy: null,\n           lastCheck: 0\n         })\n@@ -49,9 +50,9 @@\n       // 备用服务器\n       if (config['comfyui.backup_servers']) {\n         const backupServers = config['comfyui.backup_servers']\n           .split(/[,\\n]/)\n-          .map(url => url.trim())\n+          .map(url => url.trim().replace(/\\/$/, ''))\n           .filter(url => url && url.startsWith('http'))\n \n         backupServers.forEach(url => {\n           this.serverList.push({\n@@ -71,13 +72,14 @@\n     } catch (error) {\n       console.error('❌ 加载服务器列表失败:', error)\n       // 使用默认服务器\n       this.serverList = [{\n-        url: comfyUIConfig.BASE_URL,\n+        url: comfyUIConfig.BASE_URL.replace(/\\/$/, ''),\n         type: 'default',\n         healthy: null,\n         lastCheck: 0\n       }]\n+      console.log('📊 使用默认服务器:', this.serverList[0].url)\n     }\n   }\n \n   /**\n"
                },
                {
                    "date": 1752549023391,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,8 +109,17 @@\n     return servers\n   }\n \n   /**\n+   * 初始化服务器连接（兼容旧接口）\n+   */\n+  async initializeServerConnection() {\n+    console.log('🔗 初始化服务器连接...')\n+    await this.loadServerList()\n+    await this.refreshHealthStatus()\n+  }\n+\n+  /**\n    * 获取最优服务器\n    */\n   async getOptimalServer() {\n     // 检查是否需要刷新健康状态\n"
                },
                {
                    "date": 1752550402084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -290,9 +290,10 @@\n           method: 'GET',\n           signal: controller.signal,\n           headers: comfyUIConfig.HEALTH_CHECK.HEADERS,\n           mode: 'cors',\n-          credentials: 'omit'\n+          credentials: 'omit',\n+          cache: 'no-cache'\n         })\n \n         clearTimeout(timeoutId)\n \n"
                },
                {
                    "date": 1752550421554,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -331,8 +331,23 @@\n           console.log(`⚠️ 端点响应错误: ${endpoint} (状态: ${response.status})`)\n         }\n       } catch (error) {\n         console.log(`❌ 端点测试失败: ${endpoint} - ${error.message}`)\n+\n+        // 如果是网络错误，尝试简化的请求\n+        if (error.message.includes('Failed to fetch') || error.message.includes('ERR_FAILED')) {\n+          console.log(`🔄 尝试简化请求: ${endpoint}`)\n+          try {\n+            const simpleResponse = await this.testSimpleEndpoint(fullUrl)\n+            if (simpleResponse.success) {\n+              console.log(`✅ 简化请求成功: ${endpoint}`)\n+              return simpleResponse\n+            }\n+          } catch (simpleError) {\n+            console.log(`❌ 简化请求也失败: ${simpleError.message}`)\n+          }\n+        }\n+\n         continue\n       }\n     }\n \n"
                },
                {
                    "date": 1752550442974,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -193,8 +193,48 @@\n     }\n   }\n \n   /**\n+   * 简化的端点测试 - 用于CORS问题的备用方案\n+   */\n+  async testSimpleEndpoint(url) {\n+    try {\n+      console.log(`🔍 简化测试: ${url}`)\n+\n+      const controller = new AbortController()\n+      const timeoutId = setTimeout(() => controller.abort(), 5000) // 5秒超时\n+\n+      const response = await fetch(url, {\n+        method: 'GET',\n+        signal: controller.signal,\n+        mode: 'no-cors', // 使用no-cors模式避免CORS问题\n+        cache: 'no-cache'\n+      })\n+\n+      clearTimeout(timeoutId)\n+\n+      // no-cors模式下，response.ok总是false，但如果没有抛出错误就说明连接成功\n+      console.log(`✅ 简化测试连接成功: ${url}`)\n+\n+      return {\n+        success: true,\n+        endpoint: url.split('/').pop(),\n+        fullUrl: url,\n+        status: 'unknown', // no-cors模式下无法获取状态码\n+        note: '简化模式连接成功',\n+        validated: false // 无法验证响应内容\n+      }\n+\n+    } catch (error) {\n+      console.log(`❌ 简化测试失败: ${url} - ${error.message}`)\n+      return {\n+        success: false,\n+        error: error.message\n+      }\n+    }\n+  }\n+\n+  /**\n    * 测试服务器基础连接 - 使用多种方法确保准确性\n    */\n   async testBasicConnection(serverUrl) {\n     const cleanUrl = serverUrl.replace(/\\/$/, '')\n"
                },
                {
                    "date": 1752550456489,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -202,18 +202,18 @@\n \n       const controller = new AbortController()\n       const timeoutId = setTimeout(() => controller.abort(), 5000) // 5秒超时\n \n-      const response = await fetch(url, {\n+      await fetch(url, {\n         method: 'GET',\n         signal: controller.signal,\n         mode: 'no-cors', // 使用no-cors模式避免CORS问题\n         cache: 'no-cache'\n       })\n \n       clearTimeout(timeoutId)\n \n-      // no-cors模式下，response.ok总是false，但如果没有抛出错误就说明连接成功\n+      // no-cors模式下，如果没有抛出错误就说明连接成功\n       console.log(`✅ 简化测试连接成功: ${url}`)\n \n       return {\n         success: true,\n"
                },
                {
                    "date": 1752551082574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,8 +10,9 @@\n     this.healthCheckResults = new Map() // 缓存健康检查结果\n     this.serverList = [] // 服务器列表\n     this.lastHealthCheck = 0 // 上次健康检查时间\n     this.healthCheckInterval = 30000 // 30秒检查一次\n+    this.verboseLogging = false // 详细日志开关\n   }\n \n   /**\n    * 初始化负载均衡器\n"
                },
                {
                    "date": 1752551120948,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,8 @@\n    * 初始化负载均衡器\n    */\n   async initialize() {\n     console.log('🔧 初始化ComfyUI负载均衡器...')\n-    console.log('📋 使用官方端点配置:', comfyUIConfig.getHealthCheckEndpoints())\n \n     // 获取服务器列表\n     await this.loadServerList()\n \n"
                },
                {
                    "date": 1752551138273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,9 +42,11 @@\n         this.serverList.push({\n           url: config['comfyui.server_url'].replace(/\\/$/, ''),\n           type: 'primary',\n           healthy: null,\n-          lastCheck: 0\n+          lastCheck: 0,\n+          queueInfo: { running: 0, pending: 0, total: 0 },\n+          systemInfo: null\n         })\n       }\n \n       // 备用服务器\n"
                },
                {
                    "date": 1752551153519,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,9 +60,11 @@\n           this.serverList.push({\n             url,\n             type: 'backup',\n             healthy: null,\n-            lastCheck: 0\n+            lastCheck: 0,\n+            queueInfo: { running: 0, pending: 0, total: 0 },\n+            systemInfo: null\n           })\n         })\n       }\n \n"
                },
                {
                    "date": 1752551171754,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,12 +67,9 @@\n           })\n         })\n       }\n \n-      console.log(`📊 加载了 ${this.serverList.length} 个服务器:`)\n-      this.serverList.forEach((server, index) => {\n-        console.log(`   ${index + 1}. ${server.type}: ${server.url}`)\n-      })\n+      console.log(`📊 加载了 ${this.serverList.length} 个服务器`)\n \n     } catch (error) {\n       console.error('❌ 加载服务器列表失败:', error)\n       // 使用默认服务器\n"
                },
                {
                    "date": 1752551189500,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,9 +76,11 @@\n       this.serverList = [{\n         url: comfyUIConfig.BASE_URL.replace(/\\/$/, ''),\n         type: 'default',\n         healthy: null,\n-        lastCheck: 0\n+        lastCheck: 0,\n+        queueInfo: { running: 0, pending: 0, total: 0 },\n+        systemInfo: null\n       }]\n       console.log('📊 使用默认服务器:', this.serverList[0].url)\n     }\n   }\n"
                },
                {
                    "date": 1752551214922,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -121,9 +121,9 @@\n     await this.refreshHealthStatus()\n   }\n \n   /**\n-   * 获取最优服务器\n+   * 获取最优服务器 - 基于队列数量的负载均衡\n    */\n   async getOptimalServer() {\n     // 检查是否需要刷新健康状态\n     const now = Date.now()\n@@ -131,29 +131,34 @@\n       await this.refreshHealthStatus()\n       this.lastHealthCheck = now\n     }\n \n-    // 优先返回健康的主服务器\n-    const primaryServers = this.serverList.filter(s => s.type === 'primary' && s.healthy === true)\n-    if (primaryServers.length > 0) {\n-      return primaryServers[0].url\n-    }\n+    // 获取所有健康的服务器\n+    const healthyServers = this.serverList.filter(s => s.healthy === true)\n \n-    // 然后返回健康的备用服务器\n-    const backupServers = this.serverList.filter(s => s.type === 'backup' && s.healthy === true)\n-    if (backupServers.length > 0) {\n-      return backupServers[0].url\n+    if (healthyServers.length === 0) {\n+      console.warn('⚠️ 没有健康的服务器，使用第一个服务器')\n+      return this.serverList.length > 0 ? this.serverList[0].url : comfyUIConfig.BASE_URL\n     }\n \n-    // 如果没有健康的服务器，返回第一个服务器（可能是默认服务器）\n-    if (this.serverList.length > 0) {\n-      console.warn('⚠️ 没有健康的服务器，使用第一个服务器')\n-      return this.serverList[0].url\n+    // 按优先级和队列数量排序选择最优服务器\n+    const sortedServers = healthyServers.sort((a, b) => {\n+      // 1. 优先级：primary > backup > default\n+      const priorityOrder = { 'primary': 0, 'backup': 1, 'default': 2 }\n+      const priorityDiff = priorityOrder[a.type] - priorityOrder[b.type]\n+      if (priorityDiff !== 0) return priorityDiff\n+\n+      // 2. 相同优先级下，选择队列最少的服务器\n+      return a.queueInfo.total - b.queueInfo.total\n+    })\n+\n+    const selectedServer = sortedServers[0]\n+\n+    if (this.verboseLogging) {\n+      console.log(`🎯 选择服务器: ${selectedServer.url} (队列: ${selectedServer.queueInfo.total})`)\n     }\n \n-    // 最后的备用方案\n-    console.warn('⚠️ 没有配置的服务器，使用默认配置')\n-    return comfyUIConfig.BASE_URL\n+    return selectedServer.url\n   }\n \n   /**\n    * 刷新所有服务器的健康状态\n"
                },
                {
                    "date": 1752551237157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -163,29 +163,41 @@\n   /**\n    * 刷新所有服务器的健康状态\n    */\n   async refreshHealthStatus() {\n-    console.log('🔄 刷新服务器健康状态...')\n+    if (this.verboseLogging) {\n+      console.log('🔄 刷新服务器健康状态...')\n+    }\n \n     const promises = this.serverList.map(async (server) => {\n       try {\n         const result = await this.testComfyUIEndpoints(server.url)\n         server.healthy = result.success\n         server.lastCheck = Date.now()\n \n-        if (result.success) {\n-          console.log(`✅ 服务器健康: ${server.url}`)\n-        } else {\n-          console.log(`❌ 服务器异常: ${server.url}`)\n+        // 更新队列和系统信息\n+        if (result.success && result.data) {\n+          if (result.endpoint.includes('queue')) {\n+            server.queueInfo = comfyUIConfig.parseQueueInfo(result.data)\n+          } else if (result.endpoint.includes('system_stats')) {\n+            server.systemInfo = comfyUIConfig.parseSystemInfo(result.data)\n+          }\n         }\n+\n       } catch (error) {\n         server.healthy = false\n         server.lastCheck = Date.now()\n-        console.log(`❌ 服务器检查失败: ${server.url} - ${error.message}`)\n+        server.queueInfo = { running: 0, pending: 0, total: 0 }\n+        if (this.verboseLogging) {\n+          console.log(`❌ 服务器检查失败: ${server.url} - ${error.message}`)\n+        }\n       }\n     })\n \n     await Promise.all(promises)\n+\n+    // 显示简化的服务器状态\n+    this.logServerStatus()\n   }\n \n   /**\n    * 记录服务器失败\n"
                },
                {
                    "date": 1752551257210,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -199,8 +199,52 @@\n     this.logServerStatus()\n   }\n \n   /**\n+   * 显示简化的服务器状态日志\n+   */\n+  logServerStatus() {\n+    const healthyServers = this.serverList.filter(s => s.healthy === true)\n+    const totalServers = this.serverList.length\n+\n+    if (healthyServers.length === 0) {\n+      console.warn(`⚠️ 服务器状态: 0/${totalServers} 可用`)\n+      return\n+    }\n+\n+    console.log(`✅ 服务器状态: ${healthyServers.length}/${totalServers} 可用`)\n+\n+    // 显示可用服务器的队列信息\n+    healthyServers.forEach(server => {\n+      const queueText = server.queueInfo.total > 0\n+        ? `队列: ${server.queueInfo.running}运行/${server.queueInfo.pending}等待`\n+        : '队列: 空闲'\n+\n+      console.log(`  📊 ${server.type}: ${queueText}`)\n+    })\n+  }\n+\n+  /**\n+   * 获取服务器状态摘要\n+   */\n+  getServerStatusSummary() {\n+    const healthyServers = this.serverList.filter(s => s.healthy === true)\n+    const totalQueue = healthyServers.reduce((sum, server) => sum + server.queueInfo.total, 0)\n+\n+    return {\n+      total: this.serverList.length,\n+      healthy: healthyServers.length,\n+      totalQueue,\n+      servers: healthyServers.map(server => ({\n+        url: server.url,\n+        type: server.type,\n+        queueInfo: server.queueInfo,\n+        systemInfo: server.systemInfo\n+      }))\n+    }\n+  }\n+\n+  /**\n    * 记录服务器失败\n    */\n   async recordFailure(serverUrl, errorType = 'unknown') {\n     console.log(`📝 记录服务器失败: ${serverUrl} (${errorType})`)\n"
                },
                {
                    "date": 1752551274429,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -378,10 +378,11 @@\n   async testComfyUIEndpoints(serverUrl) {\n     const cleanUrl = serverUrl.replace(/\\/$/, '')\n     const endpoints = comfyUIConfig.getHealthCheckEndpoints()\n \n-    console.log(`🔍 测试ComfyUI端点: ${cleanUrl}`)\n-    console.log(`📋 使用端点列表:`, endpoints)\n+    if (this.verboseLogging) {\n+      console.log(`🔍 测试ComfyUI端点: ${cleanUrl}`)\n+    }\n \n     for (const endpoint of endpoints) {\n       try {\n         const fullUrl = `${cleanUrl}${endpoint}`\n"
                },
                {
                    "date": 1752551291071,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -385,9 +385,11 @@\n \n     for (const endpoint of endpoints) {\n       try {\n         const fullUrl = `${cleanUrl}${endpoint}`\n-        console.log(`   测试端点: ${endpoint}`)\n+        if (this.verboseLogging) {\n+          console.log(`   测试端点: ${endpoint}`)\n+        }\n \n         const controller = new AbortController()\n         const timeoutId = setTimeout(() => controller.abort(), this.connectionTimeout)\n \n"
                },
                {
                    "date": 1752551311322,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -412,10 +412,12 @@\n             // 使用统一的响应验证\n             const isValidResponse = comfyUIConfig.validateResponse(endpoint, data)\n \n             if (isValidResponse) {\n-              console.log(`✅ ComfyUI端点可用: ${endpoint}`)\n-              console.log(`   响应数据结构:`, Object.keys(data))\n+              if (this.verboseLogging) {\n+                console.log(`✅ ComfyUI端点可用: ${endpoint}`)\n+                console.log(`   响应数据结构:`, Object.keys(data))\n+              }\n \n               return {\n                 success: true,\n                 endpoint,\n@@ -426,9 +428,11 @@\n                 data: data,\n                 validated: true\n               }\n             } else {\n-              console.log(`⚠️ 端点响应但验证失败: ${endpoint} - 不是有效的ComfyUI响应`)\n+              if (this.verboseLogging) {\n+                console.log(`⚠️ 端点响应但验证失败: ${endpoint} - 不是有效的ComfyUI响应`)\n+              }\n               continue\n             }\n           } catch (jsonError) {\n             console.log(`⚠️ 端点响应但JSON解析失败: ${endpoint} - ${jsonError.message}`)\n"
                },
                {
                    "date": 1752551327864,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -434,9 +434,11 @@\n               }\n               continue\n             }\n           } catch (jsonError) {\n-            console.log(`⚠️ 端点响应但JSON解析失败: ${endpoint} - ${jsonError.message}`)\n+            if (this.verboseLogging) {\n+              console.log(`⚠️ 端点响应但JSON解析失败: ${endpoint} - ${jsonError.message}`)\n+            }\n             continue\n           }\n         } else {\n           console.log(`⚠️ 端点响应错误: ${endpoint} (状态: ${response.status})`)\n"
                },
                {
                    "date": 1752551364869,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -440,9 +440,11 @@\n             }\n             continue\n           }\n         } else {\n-          console.log(`⚠️ 端点响应错误: ${endpoint} (状态: ${response.status})`)\n+          if (this.verboseLogging) {\n+            console.log(`⚠️ 端点响应错误: ${endpoint} (状态: ${response.status})`)\n+          }\n         }\n       } catch (error) {\n         console.log(`❌ 端点测试失败: ${endpoint} - ${error.message}`)\n \n"
                },
                {
                    "date": 1752551384376,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -445,21 +445,29 @@\n             console.log(`⚠️ 端点响应错误: ${endpoint} (状态: ${response.status})`)\n           }\n         }\n       } catch (error) {\n-        console.log(`❌ 端点测试失败: ${endpoint} - ${error.message}`)\n+        if (this.verboseLogging) {\n+          console.log(`❌ 端点测试失败: ${endpoint} - ${error.message}`)\n+        }\n \n         // 如果是网络错误，尝试简化的请求\n         if (error.message.includes('Failed to fetch') || error.message.includes('ERR_FAILED')) {\n-          console.log(`🔄 尝试简化请求: ${endpoint}`)\n+          if (this.verboseLogging) {\n+            console.log(`🔄 尝试简化请求: ${endpoint}`)\n+          }\n           try {\n             const simpleResponse = await this.testSimpleEndpoint(fullUrl)\n             if (simpleResponse.success) {\n-              console.log(`✅ 简化请求成功: ${endpoint}`)\n+              if (this.verboseLogging) {\n+                console.log(`✅ 简化请求成功: ${endpoint}`)\n+              }\n               return simpleResponse\n             }\n           } catch (simpleError) {\n-            console.log(`❌ 简化请求也失败: ${simpleError.message}`)\n+            if (this.verboseLogging) {\n+              console.log(`❌ 简化请求也失败: ${simpleError.message}`)\n+            }\n           }\n         }\n \n         continue\n"
                },
                {
                    "date": 1752551400733,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -112,8 +112,16 @@\n     return servers\n   }\n \n   /**\n+   * 启用/禁用详细日志\n+   */\n+  setVerboseLogging(enabled) {\n+    this.verboseLogging = enabled\n+    console.log(`📝 详细日志已${enabled ? '启用' : '禁用'}`)\n+  }\n+\n+  /**\n    * 初始化服务器连接（兼容旧接口）\n    */\n   async initializeServerConnection() {\n     console.log('🔗 初始化服务器连接...')\n"
                },
                {
                    "date": 1752553464817,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -130,22 +130,30 @@\n   }\n \n   /**\n    * 获取最优服务器 - 基于队列数量的负载均衡\n+   * @param {Array} excludeUrls - 要排除的服务器URL列表\n    */\n-  async getOptimalServer() {\n+  async getOptimalServer(excludeUrls = []) {\n     // 检查是否需要刷新健康状态\n     const now = Date.now()\n     if (now - this.lastHealthCheck > this.healthCheckInterval) {\n       await this.refreshHealthStatus()\n       this.lastHealthCheck = now\n     }\n \n-    // 获取所有健康的服务器\n-    const healthyServers = this.serverList.filter(s => s.healthy === true)\n+    // 获取所有健康的服务器，排除指定的服务器\n+    const healthyServers = this.serverList.filter(s =>\n+      s.healthy === true && !excludeUrls.includes(s.url)\n+    )\n \n     if (healthyServers.length === 0) {\n-      console.warn('⚠️ 没有健康的服务器，使用第一个服务器')\n+      console.warn('⚠️ 没有可用的健康服务器，使用第一个服务器')\n+      // 如果所有服务器都被排除，则使用第一个未被排除的服务器\n+      const fallbackServers = this.serverList.filter(s => !excludeUrls.includes(s.url))\n+      if (fallbackServers.length > 0) {\n+        return fallbackServers[0].url\n+      }\n       return this.serverList.length > 0 ? this.serverList[0].url : comfyUIConfig.BASE_URL\n     }\n \n     // 按优先级和队列数量排序选择最优服务器\n@@ -162,8 +170,11 @@\n     const selectedServer = sortedServers[0]\n \n     if (this.verboseLogging) {\n       console.log(`🎯 选择服务器: ${selectedServer.url} (队列: ${selectedServer.queueInfo.total})`)\n+      if (excludeUrls.length > 0) {\n+        console.log(`🚫 排除的服务器: ${excludeUrls.join(', ')}`)\n+      }\n     }\n \n     return selectedServer.url\n   }\n"
                },
                {
                    "date": 1752553580032,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -262,8 +262,27 @@\n     }\n   }\n \n   /**\n+   * 显示当前负载均衡状态（页面加载时调用）\n+   */\n+  async showLoadBalancingStatus() {\n+    console.log('🎯 负载均衡状态检查...')\n+\n+    // 刷新服务器状态\n+    await this.refreshHealthStatus()\n+\n+    // 获取最优服务器\n+    const optimalServer = await this.getOptimalServer()\n+\n+    console.log('📊 负载均衡结果:')\n+    console.log(`🎯 当前最优服务器: ${optimalServer}`)\n+\n+    // 显示所有服务器状态\n+    this.logServerStatus()\n+  }\n+\n+  /**\n    * 记录服务器失败\n    */\n   async recordFailure(serverUrl, errorType = 'unknown') {\n     console.log(`📝 记录服务器失败: ${serverUrl} (${errorType})`)\n"
                },
                {
                    "date": 1752555358670,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -130,30 +130,22 @@\n   }\n \n   /**\n    * 获取最优服务器 - 基于队列数量的负载均衡\n-   * @param {Array} excludeUrls - 要排除的服务器URL列表\n    */\n-  async getOptimalServer(excludeUrls = []) {\n+  async getOptimalServer() {\n     // 检查是否需要刷新健康状态\n     const now = Date.now()\n     if (now - this.lastHealthCheck > this.healthCheckInterval) {\n       await this.refreshHealthStatus()\n       this.lastHealthCheck = now\n     }\n \n-    // 获取所有健康的服务器，排除指定的服务器\n-    const healthyServers = this.serverList.filter(s =>\n-      s.healthy === true && !excludeUrls.includes(s.url)\n-    )\n+    // 获取所有健康的服务器\n+    const healthyServers = this.serverList.filter(s => s.healthy === true)\n \n     if (healthyServers.length === 0) {\n       console.warn('⚠️ 没有可用的健康服务器，使用第一个服务器')\n-      // 如果所有服务器都被排除，则使用第一个未被排除的服务器\n-      const fallbackServers = this.serverList.filter(s => !excludeUrls.includes(s.url))\n-      if (fallbackServers.length > 0) {\n-        return fallbackServers[0].url\n-      }\n       return this.serverList.length > 0 ? this.serverList[0].url : comfyUIConfig.BASE_URL\n     }\n \n     // 按优先级和队列数量排序选择最优服务器\n@@ -168,14 +160,9 @@\n     })\n \n     const selectedServer = sortedServers[0]\n \n-    if (this.verboseLogging) {\n-      console.log(`🎯 选择服务器: ${selectedServer.url} (队列: ${selectedServer.queueInfo.total})`)\n-      if (excludeUrls.length > 0) {\n-        console.log(`🚫 排除的服务器: ${excludeUrls.join(', ')}`)\n-      }\n-    }\n+    console.log(`🎯 选择服务器: ${selectedServer.url} (队列: ${selectedServer.queueInfo.total})`)\n \n     return selectedServer.url\n   }\n \n"
                },
                {
                    "date": 1752557175474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -336,16 +336,9 @@\n \n       const startTime = Date.now()\n       const response = await fetch(cleanUrl, {\n         method: 'HEAD',\n-        signal: controller.signal,\n-        headers: {\n-          'Accept': '*/*',\n-          'Cache-Control': 'no-cache',\n-          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n-        },\n-        mode: 'cors',\n-        credentials: 'omit'\n+        signal: controller.signal\n       })\n \n       clearTimeout(timeoutId)\n       const responseTime = Date.now() - startTime\n"
                },
                {
                    "date": 1752557205220,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,12 +363,9 @@\n \n       const startTime = Date.now()\n       const response = await fetch(cleanUrl, {\n         method: 'GET',\n-        signal: controller.signal,\n-        headers: comfyUIConfig.HEALTH_CHECK.HEADERS,\n-        mode: 'cors',\n-        credentials: 'omit'\n+        signal: controller.signal\n       })\n \n       clearTimeout(timeoutId)\n       const responseTime = Date.now() - startTime\n"
                },
                {
                    "date": 1752557236822,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -409,13 +409,9 @@\n         const timeoutId = setTimeout(() => controller.abort(), this.connectionTimeout)\n \n         const response = await fetch(fullUrl, {\n           method: 'GET',\n-          signal: controller.signal,\n-          headers: comfyUIConfig.HEALTH_CHECK.HEADERS,\n-          mode: 'cors',\n-          credentials: 'omit',\n-          cache: 'no-cache'\n+          signal: controller.signal\n         })\n \n         clearTimeout(timeoutId)\n \n"
                },
                {
                    "date": 1752557254956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -293,11 +293,9 @@\n       const timeoutId = setTimeout(() => controller.abort(), 5000) // 5秒超时\n \n       await fetch(url, {\n         method: 'GET',\n-        signal: controller.signal,\n-        mode: 'no-cors', // 使用no-cors模式避免CORS问题\n-        cache: 'no-cache'\n+        signal: controller.signal\n       })\n \n       clearTimeout(timeoutId)\n \n"
                }
            ],
            "date": 1752333548051,
            "name": "Commit-0",
            "content": "// ComfyUI 负载均衡器 - 基于任务队列的智能选择\nimport configService from './configService.js'\n\n/**\n * ComfyUI 负载均衡器\n * 根据服务器任务队列情况选择最优服务器\n */\nclass ComfyUILoadBalancer {\n  constructor() {\n    this.servers = []\n    this.serverLoads = new Map()\n    this.lockedServer = null\n    this.lastLockTime = 0\n    this.lockDuration = 30000 // 30秒锁定时间\n    this.healthCheckTimeout = 10000 // 10秒健康检查超时\n    this.queueCheckTimeout = 5000 // 5秒队列检查超时\n    this.lastUpdateTime = 0\n    this.updateInterval = 15000 // 15秒更新间隔\n  }\n\n  /**\n   * 初始化负载均衡器\n   */\n  async initialize() {\n    try {\n      console.log('🚀 初始化 ComfyUI 负载均衡器...')\n\n      // 获取服务器配置\n      const config = await configService.getConfig()\n\n      // 构建服务器列表\n      this.servers = []\n\n      // 主服务器\n      if (config['comfyui.server_url']) {\n        this.servers.push({\n          url: config['comfyui.server_url'],\n          type: 'primary',\n          priority: 1\n        })\n      }\n\n      // 备用服务器\n      if (config['comfyui.backup_servers']) {\n        const backupServers = config['comfyui.backup_servers']\n          .split('\\n')\n          .map(url => url.trim())\n          .filter(url => url && url.startsWith('http'))\n\n        backupServers.forEach((url, index) => {\n          this.servers.push({\n            url,\n            type: 'backup',\n            priority: index + 2\n          })\n        })\n      }\n\n      // 如果没有配置服务器，使用默认配置\n      if (this.servers.length === 0) {\n        console.warn('⚠️ 未找到配置的服务器，使用默认配置')\n        // 从本地配置获取默认服务器\n        const localConfig = JSON.parse(localStorage.getItem('comfyui_config') || '{}')\n        const defaultUrl = localConfig.COMFYUI_SERVER_URL || 'https://your-comfyui-server.com'\n\n        this.servers.push({\n          url: defaultUrl,\n          type: 'primary',\n          priority: 1\n        })\n      }\n\n      console.log(`✅ 发现 ${this.servers.length} 个 ComfyUI 服务器:`)\n      this.servers.forEach((server, index) => {\n        console.log(`   ${index + 1}. ${server.url} (${server.type})`)\n      })\n\n      // 初始化服务器负载信息\n      await this.updateServerLoads()\n\n      console.log('✅ ComfyUI 负载均衡器初始化完成')\n\n    } catch (error) {\n      console.error('❌ 负载均衡器初始化失败:', error)\n      // 不抛出错误，允许应用继续运行\n      console.log('🔄 使用降级模式，将使用单服务器配置')\n    }\n  }\n\n  /**\n   * 更新所有服务器的负载信息\n   */\n  async updateServerLoads() {\n    const now = Date.now()\n\n    // 如果距离上次更新时间不足间隔，跳过更新\n    if (now - this.lastUpdateTime < this.updateInterval) {\n      console.log('⏭️ 跳过负载更新，距离上次更新时间不足')\n      return\n    }\n\n    console.log('🔄 更新服务器负载信息...')\n\n    const updatePromises = this.servers.map(async (server) => {\n      try {\n        // 并行检查健康状态和队列信息\n        const [healthResult, queueResult] = await Promise.allSettled([\n          this.checkServerHealth(server.url),\n          this.getServerQueueInfo(server.url)\n        ])\n\n        const health = healthResult.status === 'fulfilled' ? healthResult.value : { healthy: false }\n        const queue = queueResult.status === 'fulfilled' ? queueResult.value : { total: 999, healthy: false }\n\n        this.serverLoads.set(server.url, {\n          ...server,\n          healthy: health.healthy && queue.healthy,\n          queue: queue,\n          lastCheck: now,\n          responseTime: health.responseTime || 0\n        })\n\n        console.log(`📊 ${server.url}: 健康=${health.healthy}, 队列=${queue.total || 0}`)\n\n      } catch (error) {\n        console.error(`❌ 更新服务器负载失败 ${server.url}:`, error)\n        this.serverLoads.set(server.url, {\n          ...server,\n          healthy: false,\n          queue: { total: 999, healthy: false },\n          lastCheck: now,\n          error: error.message\n        })\n      }\n    })\n\n    await Promise.allSettled(updatePromises)\n    this.lastUpdateTime = now\n\n    console.log('✅ 服务器负载信息更新完成')\n  }\n\n  /**\n   * 检查服务器健康状态\n   */\n  async checkServerHealth(serverUrl) {\n    try {\n      const startTime = Date.now()\n\n      const controller = new AbortController()\n      const timeoutId = setTimeout(() => controller.abort(), this.healthCheckTimeout)\n\n      const response = await fetch(`${serverUrl}/system_stats`, {\n        method: 'GET',\n        signal: controller.signal,\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      })\n\n      clearTimeout(timeoutId)\n      const responseTime = Date.now() - startTime\n\n      if (response.ok) {\n        return { healthy: true, responseTime, status: response.status }\n      } else {\n        return { healthy: false, responseTime, status: response.status }\n      }\n\n    } catch (error) {\n      console.warn(`⚠️ 健康检查失败 ${serverUrl}:`, error.message)\n      return { healthy: false, error: error.message }\n    }\n  }\n\n  /**\n   * 获取服务器队列信息\n   */\n  async getServerQueueInfo(serverUrl) {\n    try {\n      const controller = new AbortController()\n      const timeoutId = setTimeout(() => controller.abort(), this.queueCheckTimeout)\n\n      const response = await fetch(`${serverUrl}/queue`, {\n        method: 'GET',\n        signal: controller.signal,\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      })\n\n      clearTimeout(timeoutId)\n\n      if (response.ok) {\n        const queueData = await response.json()\n\n        // ComfyUI 队列 API 返回格式: { queue_running: [...], queue_pending: [...] }\n        const running = queueData.queue_running ? queueData.queue_running.length : 0\n        const pending = queueData.queue_pending ? queueData.queue_pending.length : 0\n        const total = running + pending\n\n        return {\n          running,\n          pending,\n          total,\n          healthy: true,\n          supportsQueueAPI: true\n        }\n      } else {\n        // 如果队列 API 不可用，尝试使用系统状态作为备用\n        return await this.getServerQueueInfoFallback(serverUrl)\n      }\n\n    } catch (error) {\n      console.warn(`⚠️ 队列信息获取失败 ${serverUrl}:`, error.message)\n      return await this.getServerQueueInfoFallback(serverUrl)\n    }\n  }\n\n  /**\n   * 备用队列信息获取方法\n   */\n  async getServerQueueInfoFallback(serverUrl) {\n    try {\n      const controller = new AbortController()\n      const timeoutId = setTimeout(() => controller.abort(), this.queueCheckTimeout)\n\n      const response = await fetch(`${serverUrl}/system_stats`, {\n        method: 'GET',\n        signal: controller.signal\n      })\n\n      clearTimeout(timeoutId)\n\n      if (response.ok) {\n        // 如果无法获取精确队列信息，假设服务器可用但队列未知\n        return {\n          running: 0,\n          pending: 0,\n          total: 0,\n          healthy: true,\n          supportsQueueAPI: false\n        }\n      }\n    } catch (error) {\n      // 忽略错误\n    }\n\n    return {\n      running: 0,\n      pending: 0,\n      total: 999, // 高值表示不可用\n      healthy: false,\n      supportsQueueAPI: false\n    }\n  }\n\n  /**\n   * 根据最小队列选择服务器\n   */\n  async selectServerByMinQueue() {\n    try {\n      console.log('🎯 开始选择最优服务器...')\n\n      // 检查是否有锁定的服务器\n      if (this.isServerLocked()) {\n        const lockedServer = this.getLockedServer()\n        if (lockedServer) {\n          console.log(`🔒 使用锁定的服务器: ${lockedServer}`)\n          return lockedServer\n        }\n      }\n\n      // 更新服务器负载信息\n      await this.updateServerLoads()\n\n      // 获取所有健康的服务器\n      const healthyServers = Array.from(this.serverLoads.values())\n        .filter(server => server.healthy)\n        .sort((a, b) => {\n          // 首先按队列数量排序\n          const queueDiff = (a.queue.total || 0) - (b.queue.total || 0)\n          if (queueDiff !== 0) return queueDiff\n\n          // 队列相同时按优先级排序\n          return a.priority - b.priority\n        })\n\n      if (healthyServers.length === 0) {\n        console.warn('⚠️ 没有健康的服务器可用')\n        return await this.fallbackToAnyServer()\n      }\n\n      const selectedServer = healthyServers[0]\n      console.log(`✅ 选择服务器: ${selectedServer.url} (队列: ${selectedServer.queue.total || 0})`)\n\n      // 锁定选中的服务器\n      this.lockServer(selectedServer.url)\n\n      return selectedServer.url\n\n    } catch (error) {\n      console.error('❌ 服务器选择失败:', error)\n      return await this.fallbackToAnyServer()\n    }\n  }\n\n  /**\n   * 备用服务器选择\n   */\n  async fallbackToAnyServer() {\n    console.log('🔄 使用备用服务器选择策略...')\n\n    // 按优先级返回第一个服务器\n    if (this.servers.length > 0) {\n      const fallbackServer = this.servers[0].url\n      console.log(`🆘 备用服务器: ${fallbackServer}`)\n      return fallbackServer\n    }\n\n    // 如果没有配置的服务器，使用配置服务的默认值\n    const config = await configService.getConfig()\n    const defaultServer = config['comfyui.server_url']\n\n    if (defaultServer) {\n      console.log(`🆘 默认服务器: ${defaultServer}`)\n      return defaultServer\n    }\n\n    throw new Error('没有可用的 ComfyUI 服务器')\n  }\n\n  /**\n   * 锁定服务器\n   */\n  lockServer(serverUrl) {\n    this.lockedServer = serverUrl\n    this.lastLockTime = Date.now()\n    console.log(`🔒 锁定服务器: ${serverUrl}, 持续 ${this.lockDuration / 1000} 秒`)\n\n    // 显示当前所有服务器状态\n    this.logServerStatus()\n  }\n\n  /**\n   * 检查服务器是否被锁定\n   */\n  isServerLocked() {\n    if (!this.lockedServer) return false\n\n    const now = Date.now()\n    const isLocked = (now - this.lastLockTime) < this.lockDuration\n\n    if (!isLocked) {\n      console.log('🔓 服务器锁定已过期')\n      this.lockedServer = null\n      this.lastLockTime = 0\n    }\n\n    return isLocked\n  }\n\n  /**\n   * 获取锁定的服务器\n   */\n  getLockedServer() {\n    if (this.isServerLocked()) {\n      return this.lockedServer\n    }\n    return null\n  }\n\n  /**\n   * 记录服务器失败\n   */\n  async recordFailure(serverUrl) {\n    console.log(`📝 记录服务器失败: ${serverUrl}`)\n\n    // 如果失败的是当前锁定的服务器，解除锁定\n    if (this.lockedServer === serverUrl) {\n      console.log('🔓 解除失败服务器的锁定')\n      this.lockedServer = null\n      this.lastLockTime = 0\n    }\n\n    // 标记服务器为不健康\n    if (this.serverLoads.has(serverUrl)) {\n      const serverInfo = this.serverLoads.get(serverUrl)\n      serverInfo.healthy = false\n      serverInfo.lastFailure = Date.now()\n      this.serverLoads.set(serverUrl, serverInfo)\n    }\n\n    // 强制更新服务器负载信息\n    this.lastUpdateTime = 0\n  }\n\n  /**\n   * 获取最优服务器（主要接口）\n   */\n  async getOptimalServer() {\n    return await this.selectServerByMinQueue()\n  }\n\n  /**\n   * 显示服务器状态\n   */\n  logServerStatus() {\n    console.log('📊 当前所有服务器状态:')\n    for (const [url, info] of this.serverLoads.entries()) {\n      const status = info.healthy ? '✅' : '❌'\n      const queue = info.healthy ? `队列:${info.queue.total || 0}` : '不健康'\n      const locked = url === this.lockedServer ? '🔒' : ''\n      const priority = `优先级:${info.priority}`\n      console.log(`   ${status} ${url} ${queue} ${priority} ${locked}`)\n    }\n  }\n\n  /**\n   * 获取服务器统计信息\n   */\n  getServerStats() {\n    const stats = {\n      total: this.servers.length,\n      healthy: 0,\n      locked: this.lockedServer,\n      servers: []\n    }\n\n    for (const [url, info] of this.serverLoads.entries()) {\n      if (info.healthy) stats.healthy++\n\n      stats.servers.push({\n        url,\n        healthy: info.healthy,\n        queue: info.queue.total || 0,\n        priority: info.priority,\n        type: info.type,\n        locked: url === this.lockedServer\n      })\n    }\n\n    return stats\n  }\n}\n\n// 创建单例实例\nconst loadBalancer = new ComfyUILoadBalancer()\n\nexport default loadBalancer\n"
        }
    ]
}