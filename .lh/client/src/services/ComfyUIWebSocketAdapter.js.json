{
    "sourceFile": "client/src/services/ComfyUIWebSocketAdapter.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1753463668651,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753463707565,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -445,4 +445,189 @@\n \n     // 更新进度\n     this.safeProgressCallback(promptId, `缓存命中 ${data.nodes.length} 个节点`, 25)\n   }\n+\n+  /**\n+   * 🔧 处理执行错误消息\n+   */\n+  handleExecutionError(message) {\n+    const data = message.data\n+    if (!data || !data.prompt_id) {\n+      return\n+    }\n+\n+    const promptId = data.prompt_id\n+    const task = this.getTask(promptId)\n+    if (!task) {\n+      console.log(`🔍 [${webSocketManager.windowId}] 忽略其他窗口的执行错误消息: ${promptId}`)\n+      return\n+    }\n+\n+    console.error(`❌ [${webSocketManager.windowId}] 任务执行错误: ${promptId}`, data)\n+\n+    // 更新任务状态\n+    this.updateTaskStatus(promptId, TASK_STATUS.ERROR, {\n+      errorTime: Date.now(),\n+      errorData: data\n+    })\n+\n+    // 清理任务\n+    this.removeTask(promptId)\n+\n+    // 调用错误回调\n+    if (task.onError) {\n+      const error = new Error(`执行错误: ${data.exception_message || '未知错误'}`)\n+      error.details = data\n+      task.onError(error)\n+    }\n+  }\n+\n+  /**\n+   * 🔧 处理执行中断消息\n+   */\n+  handleExecutionInterrupted(message) {\n+    const data = message.data\n+    if (!data || !data.prompt_id) {\n+      return\n+    }\n+\n+    const promptId = data.prompt_id\n+    const task = this.getTask(promptId)\n+    if (!task) {\n+      console.log(`🔍 [${webSocketManager.windowId}] 忽略其他窗口的执行中断消息: ${promptId}`)\n+      return\n+    }\n+\n+    console.warn(`⚠️ [${webSocketManager.windowId}] 任务被中断: ${promptId}`)\n+\n+    // 更新任务状态\n+    this.updateTaskStatus(promptId, TASK_STATUS.INTERRUPTED, {\n+      interruptTime: Date.now()\n+    })\n+\n+    // 清理任务\n+    this.removeTask(promptId)\n+\n+    // 调用错误回调\n+    if (task.onError) {\n+      task.onError(new Error('任务执行被中断'))\n+    }\n+  }\n+\n+  /**\n+   * 🔧 处理任务完成\n+   */\n+  async handleTaskCompletion(promptId) {\n+    const task = this.getTask(promptId)\n+    if (!task) {\n+      console.warn(`⚠️ [${webSocketManager.windowId}] 任务未找到或不属于当前窗口: ${promptId}`)\n+      return\n+    }\n+\n+    console.log(`🚀 [${webSocketManager.windowId}] 开始处理任务完成: ${promptId}`)\n+\n+    try {\n+      // 更新进度到98%，表示正在获取结果\n+      this.safeProgressCallback(promptId, '正在获取处理结果...', 98)\n+\n+      // 触发完成回调\n+      const handlers = this.taskHandlers.get(promptId)\n+      if (handlers && handlers.onComplete) {\n+        // 立即更新进度到100%\n+        this.safeProgressCallback(promptId, '处理完成', 100)\n+\n+        // 清理任务\n+        this.removeTask(promptId)\n+\n+        // 检查是否可以解锁服务器\n+        this.checkServerUnlockCondition()\n+\n+        console.log(`🎉 [${webSocketManager.windowId}] 调用完成回调: ${promptId}`)\n+\n+        // 使用setTimeout确保回调立即执行\n+        setTimeout(() => {\n+          handlers.onComplete({ promptId })\n+        }, 0)\n+      }\n+\n+    } catch (error) {\n+      console.error(`❌ [${webSocketManager.windowId}] 任务完成处理失败: ${promptId}`, error)\n+\n+      // 清理任务\n+      this.removeTask(promptId)\n+\n+      // 调用错误回调\n+      if (task.onError) {\n+        task.onError(error)\n+      }\n+    }\n+  }\n+\n+  /**\n+   * 🔧 检查服务器解锁条件\n+   */\n+  checkServerUnlockCondition() {\n+    if (this.tasks.size === 0) {\n+      console.log(`🔓 [${webSocketManager.windowId}] 所有任务已完成，自动解锁服务器`)\n+      webSocketManager.unlockServer()\n+      return true\n+    } else {\n+      console.log(`🔒 [${webSocketManager.windowId}] 仍有 ${this.tasks.size} 个待处理任务，保持服务器锁定`)\n+\n+      // 列出待处理任务\n+      const taskIds = Array.from(this.tasks.keys())\n+      console.log(`📋 [${webSocketManager.windowId}] 待处理任务: [${taskIds.join(', ')}]`)\n+\n+      return false\n+    }\n+  }\n+\n+  /**\n+   * 🔧 获取WebSocket状态\n+   */\n+  getWebSocketStatus() {\n+    const wsStatus = webSocketManager.getStatus()\n+    return {\n+      ...wsStatus,\n+      taskCount: this.tasks.size,\n+      tasks: Array.from(this.tasks.keys())\n+    }\n+  }\n+\n+  /**\n+   * 🔧 断开连接\n+   */\n+  disconnect() {\n+    webSocketManager.disconnect()\n+    this.tasks.clear()\n+    this.taskHandlers.clear()\n+    this.progressCallbackDebounce.clear()\n+    console.log(`🔌 [${webSocketManager.windowId}] ComfyUI适配器已断开连接`)\n+  }\n+\n+  /**\n+   * 🔧 调试信息\n+   */\n+  debug() {\n+    const wsStatus = this.getWebSocketStatus()\n+    console.log(`🔍 [${webSocketManager.windowId}] ===== ComfyUI适配器状态 =====`)\n+    console.log(`📊 任务数量: ${wsStatus.taskCount}`)\n+    console.log(`📋 任务列表: [${wsStatus.tasks.join(', ')}]`)\n+    console.log(`🔗 WebSocket状态: ${wsStatus.state}`)\n+    console.log(`🔒 锁定服务器: ${wsStatus.lockedServer || '无'}`)\n+    console.log(`🔍 [${webSocketManager.windowId}] ===== 状态信息结束 =====`)\n+\n+    return wsStatus\n+  }\n+}\n+\n+// 创建全局实例\n+const comfyUIAdapter = new ComfyUIWebSocketAdapter()\n+\n+// 暴露调试函数到全局\n+if (typeof window !== 'undefined') {\n+  window.comfyUIAdapter = comfyUIAdapter\n+  window.debugComfyUIAdapter = () => comfyUIAdapter.debug()\n+}\n+\n+export default comfyUIAdapter\n"
                }
            ],
            "date": 1753463668651,
            "name": "Commit-0",
            "content": "/**\n * 🔥 ComfyUI WebSocket适配器\n *\n * 将独立的WebSocket管理器适配到ComfyUI服务\n *\n * 核心功能：\n * 1. 将WebSocket消息适配为ComfyUI业务逻辑\n * 2. 管理任务生命周期和状态\n * 3. 提供向后兼容的API接口\n * 4. 处理多窗口任务隔离\n *\n * 架构优势：\n * - 业务逻辑与WebSocket管理解耦\n * - 保持原有API接口不变\n * - 支持任务状态管理和进度回调\n * - 提供完整的错误处理机制\n */\n\nimport webSocketManager from './WebSocketManager.js'\n\n// 任务状态枚举\nexport const TASK_STATUS = {\n  WAITING: 'waiting',\n  EXECUTING: 'executing',\n  COMPLETED: 'completed',\n  ERROR: 'error',\n  INTERRUPTED: 'interrupted'\n}\n\nclass ComfyUIWebSocketAdapter {\n  constructor() {\n    // 任务管理（窗口级别）\n    this.tasks = new Map() // promptId -> task\n    this.taskHandlers = new Map() // promptId -> handlers\n\n    // 进度回调防抖\n    this.progressCallbackDebounce = new Map()\n\n    // 设置事件处理器\n    this.setupEventHandlers()\n\n    console.log(`🔧 [${webSocketManager.windowId}] ComfyUI WebSocket适配器初始化完成`)\n  }\n\n  /**\n   * 🔧 设置事件处理器\n   */\n  setupEventHandlers() {\n    // 监听WebSocket连接事件\n    webSocketManager.on('connected', this.handleConnected.bind(this))\n    webSocketManager.on('disconnected', this.handleDisconnected.bind(this))\n    webSocketManager.on('error', this.handleError.bind(this))\n\n    // 监听WebSocket消息\n    webSocketManager.on('message', this.handleMessage.bind(this))\n\n    // 监听特定消息类型\n    webSocketManager.on('message:executing', this.handleExecuting.bind(this))\n    webSocketManager.on('message:executed', this.handleExecuted.bind(this))\n    webSocketManager.on('message:progress', this.handleProgress.bind(this))\n    webSocketManager.on('message:status', this.handleStatus.bind(this))\n    webSocketManager.on('message:execution_start', this.handleExecutionStart.bind(this))\n    webSocketManager.on('message:execution_error', this.handleExecutionError.bind(this))\n    webSocketManager.on('message:execution_interrupted', this.handleExecutionInterrupted.bind(this))\n    webSocketManager.on('message:execution_cached', this.handleExecutionCached.bind(this))\n\n    console.log(`📡 [${webSocketManager.windowId}] WebSocket事件处理器已设置`)\n  }\n\n  /**\n   * 🔧 确保WebSocket连接\n   */\n  async ensureConnection(serverUrl = null) {\n    try {\n      const connected = await webSocketManager.ensureConnection(serverUrl)\n\n      if (connected) {\n        console.log(`✅ [${webSocketManager.windowId}] WebSocket连接确保成功`)\n      } else {\n        console.warn(`⚠️ [${webSocketManager.windowId}] WebSocket连接失败，但不阻止操作`)\n      }\n\n      return connected\n    } catch (error) {\n      console.warn(`⚠️ [${webSocketManager.windowId}] WebSocket连接异常:`, error.message)\n      return false\n    }\n  }\n\n  /**\n   * 🔧 注册任务\n   */\n  registerTask(promptId, task) {\n    // 确保任务属于当前窗口\n    task.windowId = webSocketManager.windowId\n    task.clientId = webSocketManager.clientId\n    task.registeredAt = Date.now()\n    task.status = task.status || TASK_STATUS.WAITING\n\n    this.tasks.set(promptId, task)\n\n    console.log(`📝 [${webSocketManager.windowId}] 注册任务: ${promptId}`)\n    console.log(`📊 [${webSocketManager.windowId}] 当前任务数: ${this.tasks.size}`)\n\n    return task\n  }\n\n  /**\n   * 🔧 获取任务\n   */\n  getTask(promptId) {\n    const task = this.tasks.get(promptId)\n\n    // 验证任务是否属于当前窗口\n    if (task && task.windowId !== webSocketManager.windowId) {\n      console.warn(`⚠️ [${webSocketManager.windowId}] 任务 ${promptId} 不属于当前窗口`)\n      return null\n    }\n\n    return task\n  }\n\n  /**\n   * 🔧 移除任务\n   */\n  removeTask(promptId) {\n    const task = this.getTask(promptId)\n    if (task) {\n      this.tasks.delete(promptId)\n      this.taskHandlers.delete(promptId)\n      this.progressCallbackDebounce.delete(promptId)\n\n      console.log(`🧹 [${webSocketManager.windowId}] 移除任务: ${promptId}`)\n      console.log(`📊 [${webSocketManager.windowId}] 剩余任务数: ${this.tasks.size}`)\n\n      return true\n    }\n    return false\n  }\n\n  /**\n   * 🔧 注册任务处理器\n   */\n  registerTaskHandler(promptId, handlers) {\n    this.taskHandlers.set(promptId, handlers)\n    console.log(`📡 [${webSocketManager.windowId}] 注册任务处理器: ${promptId}`)\n  }\n\n  /**\n   * 🔧 移除任务处理器\n   */\n  unregisterTaskHandler(promptId) {\n    this.taskHandlers.delete(promptId)\n    console.log(`📡 [${webSocketManager.windowId}] 移除任务处理器: ${promptId}`)\n  }\n\n  /**\n   * 🔧 更新任务状态\n   */\n  updateTaskStatus(promptId, newStatus, additionalData = {}) {\n    const task = this.getTask(promptId)\n    if (!task) {\n      console.warn(`⚠️ [${webSocketManager.windowId}] 尝试更新不存在的任务状态: ${promptId}`)\n      return false\n    }\n\n    const oldStatus = task.status\n    task.status = newStatus\n    task.lastStatusUpdate = Date.now()\n\n    // 合并额外数据\n    Object.assign(task, additionalData)\n\n    console.log(`🔄 [${webSocketManager.windowId}] 任务状态变更: ${promptId} ${oldStatus} → ${newStatus}`)\n\n    return true\n  }\n\n  /**\n   * 🔧 安全的进度回调\n   */\n  safeProgressCallback(promptId, message, percent) {\n    const task = this.getTask(promptId)\n    if (!task || !task.onProgress) return\n\n    // 防抖：同一任务的进度回调间隔至少100ms\n    const lastCallTime = this.progressCallbackDebounce.get(promptId) || 0\n    const now = Date.now()\n\n    if (now - lastCallTime < 100) {\n      console.log(`🚫 [${webSocketManager.windowId}] 进度回调防抖: ${promptId} (${percent}%)`)\n      return\n    }\n\n    this.progressCallbackDebounce.set(promptId, now)\n\n    try {\n      // 使用queueMicrotask避免递归更新\n      queueMicrotask(() => {\n        try {\n          task.onProgress(message, percent)\n        } catch (callbackError) {\n          console.error(`❌ [${webSocketManager.windowId}] 进度回调执行失败: ${promptId}`, callbackError)\n\n          // 如果是递归更新错误，停止后续回调\n          if (callbackError.message?.includes('Maximum recursive updates')) {\n            console.error(`🔥 [${webSocketManager.windowId}] 检测到递归更新，禁用进度回调: ${promptId}`)\n            task.onProgress = null\n          }\n        }\n      })\n    } catch (error) {\n      console.error(`❌ [${webSocketManager.windowId}] 安全进度回调失败: ${promptId}`, error)\n    }\n  }\n\n  /**\n   * 🔧 处理WebSocket连接成功\n   */\n  handleConnected(data) {\n    console.log(`✅ [${webSocketManager.windowId}] WebSocket连接成功: ${data.server}`)\n  }\n\n  /**\n   * 🔧 处理WebSocket断开连接\n   */\n  handleDisconnected(data) {\n    console.log(`🔌 [${webSocketManager.windowId}] WebSocket连接断开`)\n\n    // 检查是否需要保持服务器锁定（有待处理任务时）\n    if (this.tasks.size > 0) {\n      console.log(`🔒 [${webSocketManager.windowId}] 有 ${this.tasks.size} 个待处理任务，保持服务器锁定`)\n    } else {\n      console.log(`🔓 [${webSocketManager.windowId}] 没有待处理任务，可以解锁服务器`)\n      webSocketManager.unlockServer()\n    }\n  }\n\n  /**\n   * 🔧 处理WebSocket错误\n   */\n  handleError(data) {\n    console.error(`❌ [${webSocketManager.windowId}] WebSocket错误:`, data.error)\n  }\n\n  /**\n   * 🔧 处理WebSocket消息\n   */\n  handleMessage(message) {\n    // 静默处理crystools.monitor消息，避免干扰正常消息处理\n    if (message.type === 'crystools.monitor') {\n      return\n    }\n\n    // 跨服务器消息过滤：只处理属于当前窗口的消息\n    if (message.data && message.data.prompt_id) {\n      const task = this.getTask(message.data.prompt_id)\n      if (!task) {\n        // 消息不属于当前窗口，忽略（避免跨服务器干扰）\n        console.log(`🔍 [${webSocketManager.windowId}] 忽略其他窗口/服务器的消息: ${message.type} (prompt_id: ${message.data.prompt_id})`)\n        return\n      }\n\n      // 记录消息处理日志（用于跨服务器调试）\n      console.log(`📨 [${webSocketManager.windowId}] 处理消息: ${message.type} (prompt_id: ${message.data.prompt_id})`)\n    }\n  }\n\n  /**\n   * 🔧 处理服务器状态消息\n   */\n  handleStatus(message) {\n    const data = message.data\n    if (!data || !data.status) {\n      return\n    }\n\n    const execInfo = data.status.exec_info\n    if (!execInfo) {\n      return\n    }\n\n    const queueRemaining = execInfo.queue_remaining || 0\n    console.log(`📊 [${webSocketManager.windowId}] 服务器队列状态: ${queueRemaining} 个任务等待`)\n\n    // 只更新属于当前窗口的等待中任务状态\n    this.tasks.forEach((task, promptId) => {\n      if (task.windowId === webSocketManager.windowId && task.status === TASK_STATUS.WAITING) {\n        if (queueRemaining > 1) {\n          this.safeProgressCallback(promptId, `队列中还有 ${queueRemaining} 个任务等待`, 8)\n        } else if (queueRemaining === 1) {\n          this.safeProgressCallback(promptId, '队列中还有 1 个任务等待', 10)\n        } else {\n          this.safeProgressCallback(promptId, '即将开始处理...', 12)\n        }\n      }\n    })\n  }\n\n  /**\n   * 🔧 处理任务开始执行消息\n   */\n  handleExecutionStart(message) {\n    const data = message.data\n    if (!data || !data.prompt_id) {\n      return\n    }\n\n    const promptId = data.prompt_id\n    const task = this.getTask(promptId)\n    if (!task) {\n      console.log(`🔍 [${webSocketManager.windowId}] 忽略其他窗口的执行开始消息: ${promptId}`)\n      return\n    }\n\n    console.log(`🚀 [${webSocketManager.windowId}] 任务开始执行: ${promptId}`)\n\n    // 更新任务状态\n    this.updateTaskStatus(promptId, TASK_STATUS.EXECUTING, {\n      executionStartTime: Date.now(),\n      currentNode: null,\n      completedNodes: []\n    })\n\n    // 更新进度\n    this.safeProgressCallback(promptId, '任务开始执行...', 15)\n  }\n\n  /**\n   * 🔧 处理节点执行状态消息\n   */\n  handleExecuting(message) {\n    const data = message.data\n    if (!data || !data.prompt_id) {\n      return\n    }\n\n    const promptId = data.prompt_id\n    const task = this.getTask(promptId)\n    if (!task) {\n      console.log(`🔍 [${webSocketManager.windowId}] 忽略其他窗口的执行状态消息: ${promptId}`)\n      return\n    }\n\n    // 官方标准双重条件检测：data.node === null && data.prompt_id === promptId\n    if (data.node === null && data.prompt_id === promptId) {\n      console.log(`🎯 [${webSocketManager.windowId}] 任务执行完成: ${promptId}`)\n\n      // 更新任务状态\n      this.updateTaskStatus(promptId, TASK_STATUS.COMPLETED, {\n        completionTime: Date.now()\n      })\n\n      // 立即处理任务完成\n      this.handleTaskCompletion(promptId)\n\n    } else if (data.node !== null) {\n      // 正在执行某个节点\n      console.log(`⚙️ [${webSocketManager.windowId}] 执行节点: ${data.node} (任务: ${promptId})`)\n\n      // 更新当前执行节点\n      if (task.status === TASK_STATUS.EXECUTING) {\n        task.currentNode = data.node\n        this.safeProgressCallback(promptId, `正在执行: ${data.node}`, 40)\n      }\n    }\n  }\n\n  /**\n   * 🔧 处理节点执行完成消息\n   */\n  handleExecuted(message) {\n    const data = message.data\n    if (!data || !data.prompt_id || !data.node) {\n      return\n    }\n\n    const promptId = data.prompt_id\n    const task = this.getTask(promptId)\n    if (!task || task.status !== TASK_STATUS.EXECUTING) {\n      if (!task) {\n        console.log(`🔍 [${webSocketManager.windowId}] 忽略其他窗口的节点完成消息: ${promptId}`)\n      }\n      return\n    }\n\n    console.log(`✅ [${webSocketManager.windowId}] 节点完成: ${data.node} (任务: ${promptId})`)\n\n    // 记录完成的节点\n    if (!task.completedNodes) {\n      task.completedNodes = []\n    }\n    task.completedNodes.push(data.node)\n\n    // 更新进度\n    this.safeProgressCallback(promptId, `节点 ${data.node} 完成`, 60)\n  }\n\n  /**\n   * 🔧 处理节点执行进度消息\n   */\n  handleProgress(message) {\n    const data = message.data\n    if (!data || !data.prompt_id) {\n      return\n    }\n\n    const promptId = data.prompt_id\n    const task = this.getTask(promptId)\n    if (!task || task.status !== TASK_STATUS.EXECUTING) {\n      if (!task) {\n        console.log(`🔍 [${webSocketManager.windowId}] 忽略其他窗口的进度消息: ${promptId}`)\n      }\n      return\n    }\n\n    if (data.value !== undefined && data.max !== undefined) {\n      const progress = Math.round((data.value / data.max) * 100)\n      const overallProgress = 40 + (progress * 0.5) // 40-90%区间\n\n      console.log(`📈 [${webSocketManager.windowId}] 进度更新: ${promptId} - ${data.value}/${data.max} (${progress}%)`)\n\n      // 更新进度\n      this.safeProgressCallback(promptId, `处理进度: ${data.value}/${data.max}`, overallProgress)\n    }\n  }\n\n  /**\n   * 🔧 处理节点缓存命中消息\n   */\n  handleExecutionCached(message) {\n    const data = message.data\n    if (!data || !data.prompt_id || !data.nodes) {\n      return\n    }\n\n    const promptId = data.prompt_id\n    const task = this.getTask(promptId)\n    if (!task) {\n      console.log(`🔍 [${webSocketManager.windowId}] 忽略其他窗口的缓存命中消息: ${promptId}`)\n      return\n    }\n\n    console.log(`⚡ [${webSocketManager.windowId}] 缓存命中: ${promptId}, 节点: [${data.nodes.join(', ')}]`)\n\n    // 更新进度\n    this.safeProgressCallback(promptId, `缓存命中 ${data.nodes.length} 个节点`, 25)\n  }\n"
        }
    ]
}