{
    "sourceFile": "client/src/services/webSocketManager_clean.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1753522050924,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1753522050924,
            "name": "Commit-0",
            "content": "// 极简版 WebSocket 管理器 - 基于官方 websockets_api_example.py\n// 支持多用户多窗口、服务器选择、任务锁定机制\n\nimport loadBalancer from './loadBalancer.js'\n\n// 生成唯一标识符\nfunction generateId() {\n  return `${Date.now()}_${Math.random().toString(36).substring(2, 11)}`\n}\n\n// 窗口唯一标识\nconst WINDOW_ID = generateId()\nconst CLIENT_ID = generateId()\n\nconsole.log(`🪟 窗口ID: ${WINDOW_ID}`)\nconsole.log(`🔑 客户端ID: ${CLIENT_ID}`)\n\n/**\n * 极简版 WebSocket 管理器\n * 基于官方 websockets_api_example.py 的核心逻辑\n */\nclass SimpleWebSocketManager {\n  constructor() {\n    // WebSocket 连接\n    this.ws = null\n    this.isConnected = false\n    this.currentServer = null\n\n    // 任务管理 - 只保留当前窗口的任务\n    this.tasks = new Map() // promptId -> { onComplete, onError, onProgress, server }\n\n    // 服务器锁定 - 简化为窗口级别\n    this.lockedServer = null\n    this.lockTimestamp = null\n\n    // 初始化窗口事件\n    this._initWindowEvents()\n  }\n\n  // 窗口关闭清理\n  _initWindowEvents() {\n    window.addEventListener('beforeunload', () => {\n      console.log(`🚪 [${WINDOW_ID}] 窗口关闭，清理资源`)\n      this._cleanup()\n    })\n  }\n\n  // 清理资源\n  _cleanup() {\n    if (this.ws) {\n      this.ws.close()\n      this.ws = null\n    }\n    this.tasks.clear()\n    this.lockedServer = null\n    this.isConnected = false\n  }\n\n  // 连接到指定服务器\n  async connectToServer(serverUrl) {\n    if (this.ws && this.isConnected && this.currentServer === serverUrl) {\n      console.log(`✅ [${WINDOW_ID}] 已连接到服务器: ${serverUrl}`)\n      return true\n    }\n\n    // 关闭现有连接\n    if (this.ws) {\n      this.ws.close()\n    }\n\n    try {\n      const wsUrl = `${serverUrl.replace('http', 'ws')}/ws?clientId=${CLIENT_ID}`\n      console.log(`🔌 [${WINDOW_ID}] 连接到: ${wsUrl}`)\n\n      this.ws = new WebSocket(wsUrl)\n      this.currentServer = serverUrl\n\n      return new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('连接超时'))\n        }, 10000)\n\n        this.ws.onopen = () => {\n          this.isConnected = true\n          clearTimeout(timeout)\n          console.log(`✅ [${WINDOW_ID}] WebSocket连接成功: ${serverUrl}`)\n          resolve(true)\n        }\n\n        this.ws.onerror = (error) => {\n          this.isConnected = false\n          clearTimeout(timeout)\n          console.error(`❌ [${WINDOW_ID}] WebSocket连接失败:`, error)\n          reject(error)\n        }\n\n        this.ws.onclose = () => {\n          this.isConnected = false\n          console.log(`🔌 [${WINDOW_ID}] WebSocket连接关闭`)\n        }\n\n        // 核心消息处理 - 基于官方样例\n        this.ws.onmessage = (event) => {\n          try {\n            // 忽略 Blob 类型消息（图片预览等二进制数据）\n            if (event.data instanceof Blob) {\n              return\n            }\n\n            const message = JSON.parse(event.data)\n            this._handleMessage(message)\n          } catch (error) {\n            console.error(`❌ [${WINDOW_ID}] 消息解析失败:`, error)\n          }\n        }\n      })\n    } catch (error) {\n      console.error(`❌ [${WINDOW_ID}] 连接失败:`, error)\n      throw error\n    }\n  }\n\n  // 消息处理 - 基于官方 websockets_api_example.py 第37-40行\n  _handleMessage(message) {\n    const { type, data } = message\n\n    // 只处理 executing 消息，检测任务完成\n    if (type === 'executing' && data) {\n      const { node, prompt_id } = data\n\n      // 任务完成检测：node 为 null 表示执行完成\n      if (node === null && prompt_id) {\n        this._handleTaskCompletion(prompt_id)\n      } else if (node && prompt_id) {\n        // 任务执行中，更新进度\n        this._handleTaskProgress(prompt_id, `执行节点: ${node}`, 50)\n      }\n    }\n\n    // 处理其他消息类型\n    if (type === 'progress' && data && data.prompt_id) {\n      this._handleTaskProgress(data.prompt_id, '处理中...', data.value || 0)\n    }\n\n    if (type === 'execution_error' && data && data.prompt_id) {\n      this._handleTaskError(data.prompt_id, data.exception_message || '执行错误')\n    }\n  }\n\n  // 任务进度处理\n  _handleTaskProgress(promptId, message, progress) {\n    const task = this.tasks.get(promptId)\n    if (task && task.onProgress) {\n      task.onProgress(message, progress)\n    }\n  }\n\n  // 任务完成处理 - 基于官方样例第47-56行\n  async _handleTaskCompletion(promptId) {\n    const task = this.tasks.get(promptId)\n    if (!task) {\n      console.warn(`⚠️ [${WINDOW_ID}] 任务不存在: ${promptId}`)\n      return\n    }\n\n    try {\n      // 获取任务历史 - 基于官方样例第47行\n      const history = await this._getHistory(promptId)\n\n      // 提取结果 - 基于官方样例第48-56行\n      const result = this._extractResults(history, promptId)\n\n      // 保存任务执行服务器信息\n      if (result && task && task.server) {\n        result.executionServer = task.server\n        result.promptId = promptId\n        result.taskStartTime = task.startTime\n      } else {\n        // 尝试从当前锁定服务器获取\n        const currentLock = this.getWindowServerLock()\n        if (currentLock && currentLock.server) {\n          result.executionServer = currentLock.server\n          result.promptId = promptId\n        }\n      }\n\n      // 调用完成回调\n      if (task.onComplete) {\n        task.onComplete(result)\n      }\n    } catch (error) {\n      console.error(`❌ [${WINDOW_ID}] 任务结果获取失败: ${promptId}`, error)\n      if (task.onError) {\n        task.onError(error)\n      }\n    } finally {\n      // 清理任务\n      this.tasks.delete(promptId)\n\n      // 检查是否需要解锁服务器\n      this._checkUnlock()\n    }\n  }\n\n  // 任务错误处理\n  _handleTaskError(promptId, errorMessage) {\n    const task = this.tasks.get(promptId)\n    if (task && task.onError) {\n      task.onError(new Error(errorMessage))\n    }\n    this.tasks.delete(promptId)\n    this._checkUnlock()\n  }\n\n  // 获取任务历史 - 基于官方样例第25-27行\n  async _getHistory(promptId) {\n    const response = await fetch(`${this.currentServer}/api/history/${promptId}`)\n    if (!response.ok) {\n      throw new Error(`获取历史失败: ${response.status}`)\n    }\n    return await response.json()\n  }\n\n  // 提取结果 - 基于官方样例第47-56行\n  _extractResults(history, promptId) {\n    const taskData = history[promptId]\n    if (!taskData || !taskData.outputs) {\n      return { outputs: {} }\n    }\n\n    // 保留完整的输出数据结构\n    const results = {\n      outputs: taskData.outputs,\n      promptId: promptId,\n      status: taskData.status,\n      meta: taskData.meta || {}\n    }\n\n    return results\n  }\n\n  // 选择最佳服务器\n  async _selectBestServer() {\n    try {\n      const bestServer = await loadBalancer.getBestServer()\n      return bestServer\n    } catch (error) {\n      console.error(`❌ [${WINDOW_ID}] 服务器选择失败:`, error)\n      throw error\n    }\n  }\n\n  // 锁定服务器\n  _lockServer(serverUrl) {\n    if (!this.lockedServer) {\n      this.lockedServer = serverUrl\n      this.lockTimestamp = Date.now()\n    }\n  }\n\n  // 检查解锁条件\n  _checkUnlock() {\n    if (this.tasks.size === 0 && this.lockedServer) {\n      this.lockedServer = null\n      this.lockTimestamp = null\n    }\n  }\n\n  // 提交任务 - 基于官方样例第13-17行\n  async submitTask(workflow, promptId, callbacks = {}) {\n    try {\n      // 选择服务器\n      const serverUrl = this.lockedServer || await this._selectBestServer()\n\n      // 连接到服务器\n      await this.connectToServer(serverUrl)\n\n      // 锁定服务器\n      this._lockServer(serverUrl)\n\n      // 注册任务\n      this.tasks.set(promptId, {\n        ...callbacks,\n        server: serverUrl,\n        startTime: Date.now()\n      })\n\n      // 提交工作流 - 基于官方样例第14-17行\n      const requestBody = {\n        prompt: workflow,\n        client_id: CLIENT_ID,\n        prompt_id: promptId\n      }\n\n      const response = await fetch(`${serverUrl}/api/prompt`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(requestBody)\n      })\n\n      if (!response.ok) {\n        throw new Error(`提交失败: ${response.status}`)\n      }\n\n      console.log(`✅ [${WINDOW_ID}] 任务提交成功: ${promptId}`)\n      return promptId\n\n    } catch (error) {\n      // 清理失败的任务\n      this.tasks.delete(promptId)\n      this._checkUnlock()\n      throw error\n    }\n  }\n\n  // 等待任务完成 - 基于官方样例第33-40行的 while True 逻辑\n  async waitForCompletion(promptId, callbacks = {}) {\n    return new Promise((resolve, reject) => {\n      const task = this.tasks.get(promptId)\n      if (!task) {\n        reject(new Error(`任务不存在: ${promptId}`))\n        return\n      }\n\n      // 更新回调\n      task.onComplete = resolve\n      task.onError = reject\n      task.onProgress = callbacks.onProgress || (() => {})\n\n      console.log(`⏳ [${WINDOW_ID}] 等待任务完成: ${promptId}`)\n    })\n  }\n\n  // 获取状态信息\n  getStatus() {\n    return {\n      windowId: WINDOW_ID,\n      clientId: CLIENT_ID,\n      connected: this.isConnected,\n      server: this.currentServer,\n      lockedServer: this.lockedServer,\n      taskCount: this.tasks.size\n    }\n  }\n\n  // ==================== 兼容性方法 ====================\n\n  // 兼容原有接口\n  async initializeWebSocket(targetServer = null) {\n    const serverUrl = targetServer || this.lockedServer || await this._selectBestServer()\n    return await this.connectToServer(serverUrl)\n  }\n\n  async ensureWebSocketConnection(taskServer = null) {\n    const serverUrl = taskServer || this.currentServer\n    if (serverUrl && this.isConnected && this.currentServer === serverUrl) {\n      return true\n    }\n    return await this.connectToServer(serverUrl || await this._selectBestServer())\n  }\n\n  // 任务管理兼容方法\n  registerWindowTask(promptId, task) {\n    this.tasks.set(promptId, task)\n    console.log(`📝 [${WINDOW_ID}] 任务已注册: ${promptId}`)\n  }\n\n  getWindowTask(promptId) {\n    return this.tasks.get(promptId)\n  }\n\n  removeWindowTask(promptId) {\n    const removed = this.tasks.delete(promptId)\n    if (removed) {\n      console.log(`🗑️ [${WINDOW_ID}] 任务已移除: ${promptId}`)\n      this._checkUnlock()\n    }\n    return removed\n  }\n\n  // 服务器锁定兼容方法\n  lockServerForWindow(serverUrl) {\n    this._lockServer(serverUrl)\n  }\n\n  unlockServerForWindow() {\n    console.log(`🔓 [${WINDOW_ID}] 手动解锁服务器: ${this.lockedServer}`)\n    this.lockedServer = null\n    this.lockTimestamp = null\n  }\n\n  getWindowServerLock() {\n    if (this.lockedServer) {\n      return {\n        server: this.lockedServer,\n        timestamp: this.lockTimestamp,\n        windowId: WINDOW_ID\n      }\n    }\n    return null\n  }\n\n  // 任务完成处理 - 供外部调用\n  async handleTaskCompletion(promptId) {\n    await this._handleTaskCompletion(promptId)\n  }\n\n  // 进度回调安全包装\n  safeProgressCallback(task, message, progress) {\n    if (task && task.onProgress) {\n      try {\n        task.onProgress(message, progress)\n      } catch (error) {\n        console.error(`❌ [${WINDOW_ID}] 进度回调错误:`, error)\n      }\n    }\n  }\n\n  // 获取任务绑定的服务器\n  getTaskBoundServer(promptId) {\n    const task = this.tasks.get(promptId)\n    return task ? task.server : null\n  }\n\n  // 检查服务器解锁条件\n  checkServerUnlockCondition() {\n    this._checkUnlock()\n  }\n\n  // 窗口任务属性（兼容性）\n  get windowTasks() {\n    return this.tasks\n  }\n\n  // 任务状态枚举（兼容性）\n  get TASK_STATUS() {\n    return {\n      WAITING: 'waiting',\n      EXECUTING: 'executing',\n      COMPLETED: 'completed',\n      ERROR: 'error',\n      INTERRUPTED: 'interrupted'\n    }\n  }\n\n  // 兼容性属性\n  get wsConnection() {\n    return this.ws\n  }\n\n  get isWsConnected() {\n    return this.isConnected\n  }\n\n  get currentWebSocketServer() {\n    return this.currentServer\n  }\n}\n\n// 创建全局实例\nconst webSocketManager = new SimpleWebSocketManager()\n\n// 全局兼容性设置\nif (typeof window !== 'undefined') {\n  // 保持原有的全局变量兼容性\n  window.pendingTasks = webSocketManager.tasks\n\n  // 兼容原有的全局函数\n  window.getWindowTask = webSocketManager.getWindowTask.bind(webSocketManager)\n  window.removeWindowTask = webSocketManager.removeWindowTask.bind(webSocketManager)\n\n  console.log(`🔧 [${WINDOW_ID}] 兼容性接口已设置`)\n}\n\n// 导出\nexport default webSocketManager\nexport { WINDOW_ID, CLIENT_ID, CLIENT_ID as WINDOW_CLIENT_ID }\n"
        }
    ]
}