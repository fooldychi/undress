{
    "sourceFile": "client/src/services/webSocketConnection.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1753509515084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1753509515084,
            "name": "Commit-0",
            "content": "// WebSocket 连接管理扩展 - 处理连接和消息\n// 这个文件包含 WebSocket 连接初始化、消息处理和重连逻辑\n\nimport webSocketManager, { WINDOW_ID, WINDOW_CLIENT_ID } from './webSocketManager.js'\nimport loadBalancer from './loadBalancer.js'\n\n/**\n * WebSocket 连接管理器扩展\n * 处理实际的 WebSocket 连接、消息路由和重连逻辑\n */\nclass WebSocketConnection {\n  constructor(manager) {\n    this.manager = manager\n  }\n\n  // 🔧 初始化 WebSocket 连接 - 重构版本（解决多服务器消息路由错乱）\n  async initializeWebSocket(targetServer = null) {\n    try {\n      // 🔧 关键修复：支持指定目标服务器，确保任务-服务器绑定一致性\n      let baseUrl\n      const currentLock = this.manager.getWindowServerLock()\n\n      if (targetServer) {\n        // 🔧 新增：强制连接到指定服务器（用于任务执行时的服务器绑定）\n        baseUrl = targetServer\n        console.log(`🎯 [${WINDOW_ID}] 强制连接到指定服务器: ${baseUrl}`)\n        console.log(`🔗 [${WINDOW_ID}] 任务-服务器绑定: 确保WebSocket与任务执行服务器一致`)\n\n        // 如果指定服务器与当前锁定不同，需要更新锁定\n        if (!currentLock || currentLock.server !== baseUrl) {\n          this.manager.lockServerForWindow(baseUrl)\n          console.log(`🔒 [${WINDOW_ID}] 更新服务器锁定: ${baseUrl}`)\n        }\n      } else if (currentLock && currentLock.server) {\n        // 如果已有锁定的服务器，继续使用\n        baseUrl = currentLock.server\n        console.log(`🔒 [${WINDOW_ID}] 使用已锁定的WebSocket服务器: ${baseUrl}`)\n        console.log(`🪟 [${WINDOW_ID}] 窗口隔离: 使用当前窗口独立锁定的服务器`)\n        this._logServerConsistency('使用已锁定的WebSocket服务器')\n      } else {\n        // 首次连接或重连时，选择最优服务器并锁定\n        try {\n          baseUrl = await loadBalancer.getOptimalServer()\n          if (!baseUrl) {\n            throw new Error('负载均衡器未返回有效的服务器URL')\n          }\n          this.manager.lockServerForWindow(baseUrl)\n          console.log(`🔒 [${WINDOW_ID}] 锁定WebSocket服务器: ${baseUrl}`)\n          console.log(`🕐 [${WINDOW_ID}] 锁定时间: ${new Date(this.manager.getWindowServerLock().timestamp).toLocaleTimeString()}`)\n          console.log(`🪟 [${WINDOW_ID}] 窗口隔离: 为当前窗口独立锁定服务器`)\n          this._logServerConsistency('锁定新的WebSocket服务器')\n        } catch (loadBalancerError) {\n          console.error(`❌ [${WINDOW_ID}] 负载均衡器获取服务器失败:`, loadBalancerError)\n          throw new Error(`无法获取可用的ComfyUI服务器: ${loadBalancerError.message}`)\n        }\n      }\n\n      // 🔧 检查现有连接是否与目标服务器一致\n      if (this.manager.wsConnection && this.manager.wsConnection.readyState === WebSocket.OPEN) {\n        const currentWsServer = this.manager.currentWebSocketServer || this.manager.getWindowServerLock()?.server\n        if (currentWsServer === baseUrl) {\n          console.log(`✅ [${WINDOW_ID}] WebSocket已连接到正确服务器: ${baseUrl}`)\n          return true\n        } else {\n          console.log(`🔄 [${WINDOW_ID}] WebSocket服务器不匹配，需要重连`)\n          console.log(`   当前连接: ${currentWsServer}`)\n          console.log(`   目标服务器: ${baseUrl}`)\n          // 关闭现有连接，建立新连接\n          this.manager.wsConnection.close(1000, '切换到正确的服务器')\n          this.manager.wsConnection = null\n          this.manager.isWsConnected = false\n        }\n      }\n\n      console.log(`🔌 [${WINDOW_ID}] 连接WebSocket: ${baseUrl}`)\n\n      // 🔧 构建WebSocket URL - 使用增强的唯一clientId\n      let wsUrl\n      if (baseUrl.startsWith('https://')) {\n        wsUrl = baseUrl.replace('https://', 'wss://') + '/ws?clientId=' + WINDOW_CLIENT_ID\n      } else {\n        wsUrl = baseUrl.replace('http://', 'ws://') + '/ws?clientId=' + WINDOW_CLIENT_ID\n      }\n\n      console.log(`🔗 [${WINDOW_ID}] WebSocket URL: ${wsUrl}`)\n      console.log(`🔑 [${WINDOW_ID}] 使用增强clientId: ${WINDOW_CLIENT_ID}`)\n\n      // 简单的HTTP连接测试\n      try {\n        const testResponse = await fetch(`${baseUrl}/api/queue`, {\n          method: 'GET',\n          signal: AbortSignal.timeout(5000)\n        })\n        if (!testResponse.ok) {\n          throw new Error(`服务器响应错误: ${testResponse.status}`)\n        }\n      } catch (httpError) {\n        throw new Error(`ComfyUI服务器不可达: ${httpError.message}`)\n      }\n\n      // 🔧 记录即将连接的服务器，用于后续验证\n      this.manager.currentWebSocketServer = baseUrl\n      this.manager.wsConnection = new WebSocket(wsUrl)\n\n      return new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('WebSocket 连接超时'))\n        }, 10000)\n\n        this.manager.wsConnection.onopen = () => {\n          this.manager.isWsConnected = true\n          clearTimeout(timeout)\n          this._showNotification(`[${WINDOW_ID}] WebSocket连接成功`, 'success')\n          this._logServerConsistency('WebSocket连接成功')\n          resolve(true)\n        }\n\n        this.manager.wsConnection.onclose = (event) => {\n          console.log(`🔌 [${WINDOW_ID}] WebSocket 连接关闭: 代码=${event.code}`)\n          this.manager.isWsConnected = false\n          clearTimeout(timeout)\n          this._showNotification(`[${WINDOW_ID}] WebSocket连接已断开`, 'warning')\n\n          // 🔧 关键修复：WebSocket断开时不立即解锁服务器\n          // 只有在没有待处理任务时才考虑解锁\n          if (this.manager.windowTasks.size === 0) {\n            console.log(`🔓 [${WINDOW_ID}] 没有待处理任务，可以解锁服务器`)\n            this.manager.unlockServerForWindow()\n            this._logServerConsistency('WebSocket断开-解锁服务器')\n          } else {\n            console.log(`🔒 [${WINDOW_ID}] 有 ${this.manager.windowTasks.size} 个待处理任务，保持服务器锁定`)\n            console.log(`📋 [${WINDOW_ID}] 待处理任务: [${Array.from(this.manager.windowTasks.keys()).join(', ')}]`)\n            this._logServerConsistency('WebSocket断开-保持锁定')\n          }\n\n          // 🔧 重连策略 - 确保重连到正确的服务器\n          if (this.manager.windowTasks.size > 0) {\n            console.log(`🔄 [${WINDOW_ID}] 检测到待处理任务，重连到锁定服务器...`)\n            const lockedServer = this.manager.getWindowServerLock()?.server\n            if (lockedServer) {\n              console.log(`🎯 [${WINDOW_ID}] 重连目标服务器: ${lockedServer}`)\n              setTimeout(() => {\n                // 🔧 关键修复：重连时指定服务器，确保任务-服务器绑定一致性\n                this.initializeWebSocket(lockedServer).catch(error => {\n                  console.error(`❌ [${WINDOW_ID}] 重连到锁定服务器失败:`, error)\n                  console.log(`⚠️ [${WINDOW_ID}] 重连失败，但保持服务器锁定以便手动重试`)\n                  console.log(`⏳ [${WINDOW_ID}] 任务将继续等待，可手动重连或等待超时`)\n                })\n              }, 2000) // 缩短重连间隔\n            } else {\n              console.error(`❌ [${WINDOW_ID}] 有待处理任务但没有锁定服务器，无法重连`)\n            }\n          } else {\n            console.log(`ℹ️ [${WINDOW_ID}] 没有待处理任务，不进行自动重连`)\n          }\n        }\n\n        this.manager.wsConnection.onerror = (error) => {\n          clearTimeout(timeout)\n          this._showNotification(`[${WINDOW_ID}] WebSocket连接错误`, 'error')\n\n          // 🔧 关键修复：连接错误时不立即解锁服务器\n          // 保持锁定以便重连到同一服务器\n          console.log(`⚠️ [${WINDOW_ID}] WebSocket连接错误，但保持服务器锁定以便重连`)\n          console.log(`🔒 [${WINDOW_ID}] 当前锁定服务器: ${this.manager.getWindowServerLock()?.server}`)\n          console.log(`📊 [${WINDOW_ID}] 待处理任务数: ${this.manager.windowTasks.size}`)\n\n          reject(error)\n        }\n\n        this.manager.wsConnection.onmessage = (event) => {\n          try {\n            // 🔥 官方标准消息处理 - 完全重构版本（基于 websockets_api_example.py 第34-45行）\n            const message = event.data\n\n            // 官方标准：处理二进制消息（预览图像）\n            if (message instanceof ArrayBuffer || message instanceof Blob) {\n              // 官方注释：previews are binary data - continue\n              return\n            }\n\n            // 官方标准：只处理字符串消息\n            if (typeof message === 'string') {\n              try {\n                const parsedMessage = JSON.parse(message)\n\n                // 调用重构后的消息处理函数\n                this.manager.handleWebSocketMessage(parsedMessage)\n              } catch (parseError) {\n                console.error('❌ [OFFICIAL] JSON解析失败:', parseError.message)\n              }\n            }\n\n          } catch (error) {\n            console.error('❌ [OFFICIAL] WebSocket消息处理失败:', error)\n          }\n        }\n      })\n    } catch (error) {\n      console.error('❌ 初始化 WebSocket 失败:', error)\n\n      // 🔧 根据错误类型决定是否清除服务器锁定\n      if (error.message.includes('负载均衡器') || error.message.includes('无法获取可用的ComfyUI服务器')) {\n        // 如果是负载均衡器错误，清除服务器锁定\n        this.manager.currentWebSocketServer = null\n        this.manager.clearWindowServerLock()\n        console.log('🔓 负载均衡器错误，清除服务器锁定')\n      } else if (error.message.includes('ComfyUI服务器不可达') || error.message.includes('WebSocket 连接超时')) {\n        // 如果是连接错误但服务器可能恢复，保持锁定以便重试\n        console.log('🔒 连接错误但保持服务器锁定以便重试')\n      } else {\n        // 其他未知错误，清除锁定\n        this.manager.currentWebSocketServer = null\n        this.manager.clearWindowServerLock()\n        console.log('🔓 未知错误，清除服务器锁定')\n      }\n\n      throw error\n    }\n  }\n\n  // 辅助方法\n  _logServerConsistency(action, promptId = null) {\n    const timestamp = new Date().toISOString()\n    console.log(`🔍 [SERVER_TRACK] ${timestamp} - ${action}`)\n    console.log(`🔍 [SERVER_TRACK] 当前WebSocket服务器: ${this.manager.currentWebSocketServer}`)\n    console.log(`🔍 [SERVER_TRACK] WebSocket连接状态: ${this.manager.wsConnection?.readyState} (1=OPEN)`)\n    console.log(`🔍 [SERVER_TRACK] isWsConnected: ${this.manager.isWsConnected}`)\n    if (promptId) {\n      console.log(`🔍 [PROMPT_ID_TRACK] 当前prompt_id: ${promptId}`)\n    }\n    console.log(`🔍 [SERVER_TRACK] 待处理任务数: ${this.manager.windowTasks.size}`)\n    console.log('🔍 [SERVER_TRACK] =====================================')\n  }\n\n  _showNotification(message, type = 'info') {\n    const timestamp = new Date().toLocaleTimeString()\n    const typeEmoji = {\n      'success': '✅',\n      'error': '❌',\n      'warning': '⚠️',\n      'info': 'ℹ️'\n    }\n\n    console.log(`${typeEmoji[type] || 'ℹ️'} [${timestamp}] ${message}`)\n\n    // 触发自定义事件供Vue组件监听\n    if (typeof window !== 'undefined') {\n      window.dispatchEvent(new CustomEvent('comfyui-status', {\n        detail: { message, type, timestamp }\n      }))\n    }\n  }\n}\n\n// 创建连接管理器实例\nconst webSocketConnection = new WebSocketConnection(webSocketManager)\n\n// 将连接方法添加到主管理器\nwebSocketManager.initializeWebSocket = webSocketConnection.initializeWebSocket.bind(webSocketConnection)\n\nexport default webSocketConnection\nexport { webSocketConnection }\n"
        }
    ]
}