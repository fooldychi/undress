{
    "sourceFile": "client/src/services/websocketManager.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 42,
            "patches": [
                {
                    "date": 1753463557474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753463586423,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -506,4 +506,131 @@\n       this.reconnectTimer = null\n       console.log(`🧹 [${this.windowId}] 清除重连定时器`)\n     }\n   }\n+\n+  /**\n+   * 🔧 断开连接\n+   */\n+  disconnect() {\n+    this.stopHealthCheck()\n+    this.clearReconnectTimer()\n+\n+    if (this.connection) {\n+      this.connection.close(1000, '主动断开连接')\n+      this.connection = null\n+    }\n+\n+    this.state = WS_STATE.DISCONNECTED\n+    this.currentServer = null\n+    this.emit('disconnected', { windowId: this.windowId })\n+    console.log(`🔌 [${this.windowId}] WebSocket已断开连接`)\n+  }\n+\n+  /**\n+   * 🔧 强制重连到指定服务器\n+   */\n+  async forceReconnect(serverUrl = null) {\n+    console.log(`🔄 [${this.windowId}] 强制重连到服务器: ${serverUrl || '自动选择'}`)\n+\n+    // 断开现有连接\n+    this.disconnect()\n+\n+    // 重置重连计数\n+    this.reconnectAttempts = 0\n+\n+    // 连接到指定服务器\n+    return await this.connect(serverUrl)\n+  }\n+\n+  /**\n+   * 🔧 确保WebSocket连接\n+   */\n+  async ensureConnection(serverUrl = null) {\n+    // 如果指定了服务器且与当前不同，需要重新连接\n+    if (serverUrl && this.lockedServer && serverUrl !== this.lockedServer) {\n+      console.log(`🔄 [${this.windowId}] 服务器不一致，重新连接`)\n+      console.log(`   当前锁定: ${this.lockedServer}`)\n+      console.log(`   目标服务器: ${serverUrl}`)\n+      return await this.forceReconnect(serverUrl)\n+    }\n+\n+    // 如果已连接且服务器一致，直接返回\n+    if (this.state === WS_STATE.CONNECTED && this.connection?.readyState === WebSocket.OPEN) {\n+      console.log(`✅ [${this.windowId}] WebSocket已连接`)\n+      this.processMessageQueue() // 处理待发送消息\n+      return true\n+    }\n+\n+    // 需要建立新连接\n+    console.log(`🔄 [${this.windowId}] 建立新的WebSocket连接`)\n+    return await this.connect(serverUrl)\n+  }\n+\n+  /**\n+   * 🔧 获取连接状态\n+   */\n+  getStatus() {\n+    return {\n+      windowId: this.windowId,\n+      clientId: this.clientId,\n+      state: this.state,\n+      isConnected: this.state === WS_STATE.CONNECTED,\n+      currentServer: this.currentServer,\n+      lockedServer: this.lockedServer,\n+      lockTimestamp: this.lockTimestamp,\n+      lockDuration: this.lockTimestamp ? Date.now() - this.lockTimestamp : null,\n+      reconnectAttempts: this.reconnectAttempts,\n+      connectionState: this.connection?.readyState || 'CLOSED',\n+      messageQueueLength: this.messageQueue.length,\n+      lastMessageTime: this.lastMessageTime\n+    }\n+  }\n+\n+  /**\n+   * 🔧 调试信息\n+   */\n+  debug() {\n+    const status = this.getStatus()\n+    console.log(`🔍 [${this.windowId}] ===== WebSocket管理器状态 =====`)\n+    console.log(`🪟 窗口ID: ${status.windowId}`)\n+    console.log(`🔑 客户端ID: ${status.clientId}`)\n+    console.log(`🔗 连接状态: ${status.state}`)\n+    console.log(`📡 当前服务器: ${status.currentServer || '无'}`)\n+    console.log(`🔒 锁定服务器: ${status.lockedServer || '无'}`)\n+    console.log(`🕐 锁定时间: ${status.lockTimestamp ? new Date(status.lockTimestamp).toLocaleString() : '无'}`)\n+    console.log(`⏱️ 锁定持续: ${status.lockDuration ? Math.round(status.lockDuration / 1000) + '秒' : '无'}`)\n+    console.log(`🔄 重连次数: ${status.reconnectAttempts}`)\n+    console.log(`📤 消息队列: ${status.messageQueueLength} 条`)\n+    console.log(`📨 最后消息: ${status.lastMessageTime ? new Date(status.lastMessageTime).toLocaleString() : '无'}`)\n+    console.log(`🔍 [${this.windowId}] ===== 状态信息结束 =====`)\n+\n+    return status\n+  }\n+\n+  /**\n+   * 🔧 重置管理器状态\n+   */\n+  reset() {\n+    console.log(`🔄 [${this.windowId}] 重置WebSocket管理器`)\n+\n+    this.disconnect()\n+    this.unlockServer()\n+    this.messageQueue = []\n+    this.reconnectAttempts = 0\n+    this.lastMessageTime = null\n+\n+    console.log(`✅ [${this.windowId}] WebSocket管理器已重置`)\n+  }\n+}\n+\n+// 创建全局实例\n+const webSocketManager = new WebSocketManager()\n+\n+// 暴露调试函数到全局\n+if (typeof window !== 'undefined') {\n+  window.webSocketManager = webSocketManager\n+  window.debugWebSocket = () => webSocketManager.debug()\n+  window.resetWebSocket = () => webSocketManager.reset()\n+}\n+\n+export default webSocketManager\n"
                },
                {
                    "date": 1753504726338,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,636 +1,313 @@\n-/**\n- * 🔥 WebSocket连接管理器 - 独立的WebSocket服务\n- *\n- * 核心功能：\n- * 1. WebSocket连接生命周期管理\n- * 2. 多窗口隔离机制\n- * 3. 服务器锁定与一致性保证\n- * 4. 消息路由与事件分发\n- * 5. 自动重连与健康检查\n- *\n- * 架构优势：\n- * - 解耦WebSocket管理与业务逻辑\n- * - 支持多种服务复用同一WebSocket连接\n- * - 提供统一的连接管理策略\n- * - 便于测试和维护\n- */\n+// 🔧 WebSocket管理器 - 独立的连接池和消息分发系统\n+// 支持多窗口隔离、消息处理器注册、服务器锁定等功能\n \n-import loadBalancer from './loadBalancer.js'\n-\n-// WebSocket连接状态枚举\n-export const WS_STATE = {\n-  DISCONNECTED: 'disconnected',\n-  CONNECTING: 'connecting',\n-  CONNECTED: 'connected',\n-  RECONNECTING: 'reconnecting',\n-  FAILED: 'failed'\n-}\n-\n-// 🔧 生成窗口唯一标识符\n-function generateWindowId() {\n-  return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n-}\n-\n-// 🔧 生成增强的客户端ID\n-function generateUniqueClientId() {\n-  const baseId = 'abc1373d4ad648a3a81d0587fbe5534b'\n+// 🔧 生成唯一客户端ID的函数（避免循环依赖）\n+function generateClientId() {\n   const timestamp = Date.now()\n-  const random = Math.random().toString(36).substr(2, 9)\n-  const windowId = generateWindowId()\n-  return `${baseId}_${timestamp}_${random}_${windowId}`\n+  const random = Math.random().toString(36).substring(2, 8)\n+  const windowId = typeof window !== 'undefined' ?\n+    (window.WINDOW_ID || 'unknown') : 'server'\n+  return `${windowId}_${timestamp}_${random}`\n }\n \n+// 🔧 WebSocket连接管理器类\n class WebSocketManager {\n   constructor() {\n-    // 窗口标识\n-    this.windowId = generateWindowId()\n-    this.clientId = generateUniqueClientId()\n+    // 连接池：windowId -> { connection, server, clientId, isConnected }\n+    this.connections = new Map()\n \n-    // 连接管理\n-    this.connection = null\n-    this.state = WS_STATE.DISCONNECTED\n-    this.currentServer = null\n+    // 消息处理器注册表：messageType -> handler[]\n+    this.messageHandlers = new Map()\n \n-    // 服务器锁定机制（窗口级别）\n-    this.lockedServer = null\n-    this.lockTimestamp = null\n+    // 窗口级别的服务器锁定：windowId -> { server, timestamp, tasks }\n+    this.serverLocks = new Map()\n \n-    // 事件管理\n-    this.eventHandlers = new Map()\n-    this.messageQueue = []\n+    // 解锁检查定时器：windowId -> timerId\n+    this.unlockTimers = new Map()\n \n-    // 重连管理\n-    this.reconnectAttempts = 0\n-    this.maxReconnectAttempts = 5\n-    this.reconnectDelay = 2000\n-    this.reconnectTimer = null\n+    console.log('🔧 WebSocket管理器已初始化')\n+  }\n \n-    // 健康检查\n-    this.healthCheckInterval = null\n-    this.lastHeartbeat = null\n-    this.lastMessageTime = null\n+  // 🔧 注册消息处理器\n+  registerHandler(messageType, handler, windowId = null) {\n+    if (!this.messageHandlers.has(messageType)) {\n+      this.messageHandlers.set(messageType, [])\n+    }\n \n-    console.log(`🔌 WebSocketManager 初始化完成`)\n-    console.log(`🪟 窗口ID: ${this.windowId}`)\n-    console.log(`🔑 客户端ID: ${this.clientId}`)\n+    const handlerInfo = { handler, windowId }\n+    this.messageHandlers.get(messageType).push(handlerInfo)\n \n-    // 设置窗口关闭清理\n-    this.setupWindowCleanup()\n+    console.log(`📝 注册消息处理器: ${messageType} (窗口: ${windowId || 'global'})`)\n   }\n \n-  /**\n-   * 🔧 设置窗口关闭时的清理机制\n-   */\n-  setupWindowCleanup() {\n-    window.addEventListener('beforeunload', () => {\n-      console.log(`🚪 [${this.windowId}] 窗口即将关闭，执行WebSocket清理...`)\n-      this.disconnect()\n-      this.unlockServer()\n-    })\n-\n-    // 页面可见性变化处理\n-    document.addEventListener('visibilitychange', () => {\n-      if (document.hidden) {\n-        console.log(`👁️ [${this.windowId}] 窗口隐藏`)\n-      } else {\n-        console.log(`👁️ [${this.windowId}] 窗口重新可见`)\n-        this.checkConnectionHealth()\n+  // 🔧 移除消息处理器\n+  unregisterHandler(messageType, handler) {\n+    const handlers = this.messageHandlers.get(messageType)\n+    if (handlers) {\n+      const index = handlers.findIndex(h => h.handler === handler)\n+      if (index !== -1) {\n+        handlers.splice(index, 1)\n+        console.log(`🗑️ 移除消息处理器: ${messageType}`)\n       }\n-    })\n+    }\n   }\n \n-  /**\n-   * 🔧 连接到指定服务器\n-   */\n-  async connect(serverUrl = null) {\n-    if (this.state === WS_STATE.CONNECTING) {\n-      console.log(`🔄 [${this.windowId}] WebSocket正在连接中，跳过重复连接`)\n-      return false\n-    }\n-\n+  // 🔧 连接到指定服务器\n+  async connect(windowId, server, clientId = null) {\n     try {\n-      this.state = WS_STATE.CONNECTING\n+      // 生成或使用提供的clientId\n+      const finalClientId = clientId || generateClientId()\n \n-      // 确定目标服务器\n-      const targetServer = serverUrl || await this.getTargetServer()\n-      if (!targetServer) {\n-        throw new Error('无法获取可用的服务器')\n+      // 构建WebSocket URL\n+      let wsUrl\n+      if (server.startsWith('https://')) {\n+        wsUrl = server.replace('https://', 'wss://') + '/ws?clientId=' + finalClientId\n+      } else {\n+        wsUrl = server.replace('http://', 'ws://') + '/ws?clientId=' + finalClientId\n       }\n \n-      // 锁定服务器\n-      this.lockServer(targetServer)\n+      console.log(`🔌 [${windowId}] 连接WebSocket: ${wsUrl}`)\n \n-      // 建立WebSocket连接\n-      await this.establishConnection(targetServer)\n+      // 关闭现有连接\n+      await this.disconnect(windowId)\n \n-      this.state = WS_STATE.CONNECTED\n-      this.reconnectAttempts = 0\n-      this.startHealthCheck()\n+      // 创建新连接\n+      const ws = new WebSocket(wsUrl)\n \n-      console.log(`✅ [${this.windowId}] WebSocket连接成功: ${targetServer}`)\n-      this.emit('connected', { server: targetServer, windowId: this.windowId })\n+      // 设置连接信息\n+      const connectionInfo = {\n+        connection: ws,\n+        server: server,\n+        clientId: finalClientId,\n+        isConnected: false,\n+        windowId: windowId,\n+        connectedAt: Date.now()\n+      }\n \n-      return true\n+      this.connections.set(windowId, connectionInfo)\n \n-    } catch (error) {\n-      this.state = WS_STATE.FAILED\n-      console.error(`❌ [${this.windowId}] WebSocket连接失败:`, error)\n-      this.emit('error', { error, windowId: this.windowId })\n+      return new Promise((resolve, reject) => {\n+        const timeout = setTimeout(() => {\n+          reject(new Error('WebSocket连接超时'))\n+        }, 10000)\n \n-      // 启动重连\n-      this.scheduleReconnect()\n-      return false\n-    }\n-  }\n+        ws.onopen = () => {\n+          connectionInfo.isConnected = true\n+          clearTimeout(timeout)\n+          console.log(`✅ [${windowId}] WebSocket连接成功`)\n+          resolve(connectionInfo)\n+        }\n \n-  /**\n-   * 🔧 建立WebSocket连接\n-   */\n-  async establishConnection(serverUrl) {\n-    return new Promise((resolve, reject) => {\n-      const wsUrl = this.buildWebSocketUrl(serverUrl)\n-      console.log(`🔗 [${this.windowId}] 建立WebSocket连接: ${wsUrl}`)\n+        ws.onmessage = (event) => {\n+          this.handleMessage(windowId, event.data)\n+        }\n \n-      // 先进行HTTP连接测试\n-      this.testHttpConnection(serverUrl)\n-        .then(() => {\n-          this.connection = new WebSocket(wsUrl)\n-          this.currentServer = serverUrl\n+        ws.onclose = (event) => {\n+          connectionInfo.isConnected = false\n+          console.log(`🔌 [${windowId}] WebSocket连接关闭:`, event.code, event.reason)\n+        }\n \n-          const timeout = setTimeout(() => {\n-            reject(new Error('WebSocket连接超时'))\n-          }, 10000)\n+        ws.onerror = (error) => {\n+          connectionInfo.isConnected = false\n+          clearTimeout(timeout)\n+          console.error(`❌ [${windowId}] WebSocket连接错误:`, error)\n+          reject(error)\n+        }\n+      })\n \n-          this.connection.onopen = () => {\n-            clearTimeout(timeout)\n-            console.log(`🎉 [${this.windowId}] WebSocket连接已建立`)\n-            resolve()\n-          }\n-\n-          this.connection.onclose = (event) => {\n-            clearTimeout(timeout)\n-            this.handleConnectionClose(event)\n-          }\n-\n-          this.connection.onerror = (error) => {\n-            clearTimeout(timeout)\n-            console.error(`❌ [${this.windowId}] WebSocket连接错误:`, error)\n-            reject(error)\n-          }\n-\n-          this.connection.onmessage = (event) => {\n-            this.handleMessage(event)\n-          }\n-        })\n-        .catch(reject)\n-    })\n+    } catch (error) {\n+      console.error(`❌ [${windowId}] WebSocket连接失败:`, error)\n+      throw error\n+    }\n   }\n \n-  /**\n-   * 🔧 HTTP连接测试\n-   */\n-  async testHttpConnection(serverUrl) {\n-    try {\n-      const response = await fetch(`${serverUrl}/api/queue`, {\n-        method: 'GET',\n-        signal: AbortSignal.timeout(5000)\n-      })\n-      if (!response.ok) {\n-        throw new Error(`服务器响应错误: ${response.status}`)\n+  // 🔧 断开连接\n+  async disconnect(windowId) {\n+    const connectionInfo = this.connections.get(windowId)\n+    if (connectionInfo && connectionInfo.connection) {\n+      try {\n+        connectionInfo.connection.close()\n+        console.log(`🔌 [${windowId}] WebSocket连接已断开`)\n+      } catch (error) {\n+        console.warn(`⚠️ [${windowId}] 断开WebSocket连接时出错:`, error)\n       }\n-      console.log(`✅ [${this.windowId}] HTTP连接测试通过: ${serverUrl}`)\n-    } catch (error) {\n-      throw new Error(`ComfyUI服务器不可达: ${error.message}`)\n     }\n+    this.connections.delete(windowId)\n   }\n \n-  /**\n-   * 🔧 构建WebSocket URL\n-   */\n-  buildWebSocketUrl(serverUrl) {\n-    let wsUrl\n-    if (serverUrl.startsWith('https://')) {\n-      wsUrl = serverUrl.replace('https://', 'wss://')\n-    } else {\n-      wsUrl = serverUrl.replace('http://', 'ws://')\n-    }\n-    return `${wsUrl}/ws?clientId=${this.clientId}`\n+  // 🔧 获取连接信息\n+  getConnection(windowId) {\n+    return this.connections.get(windowId)?.connection || null\n   }\n \n-  /**\n-   * 🔧 消息处理\n-   */\n-  handleMessage(event) {\n-    try {\n-      this.lastMessageTime = Date.now()\n-      const message = event.data\n-\n-      // 处理二进制消息\n-      if (message instanceof ArrayBuffer || message instanceof Blob) {\n-        this.emit('binary', { data: message, windowId: this.windowId })\n-        return\n-      }\n-\n-      // 处理文本消息\n-      if (typeof message === 'string') {\n-        const parsedMessage = JSON.parse(message)\n-\n-        // 添加窗口标识\n-        const enrichedMessage = {\n-          ...parsedMessage,\n-          windowId: this.windowId,\n-          timestamp: Date.now()\n-        }\n-\n-        this.emit('message', enrichedMessage)\n-\n-        // 根据消息类型分发\n-        if (parsedMessage.type) {\n-          this.emit(`message:${parsedMessage.type}`, enrichedMessage)\n-        }\n-      }\n-\n-    } catch (error) {\n-      console.error(`❌ [${this.windowId}] WebSocket消息处理失败:`, error)\n-      this.emit('error', { error, windowId: this.windowId })\n-    }\n+  // 🔧 检查连接状态\n+  isConnected(windowId) {\n+    const connectionInfo = this.connections.get(windowId)\n+    return connectionInfo?.isConnected &&\n+           connectionInfo.connection?.readyState === WebSocket.OPEN\n   }\n \n-  /**\n-   * 🔧 连接关闭处理\n-   */\n-  handleConnectionClose(event) {\n-    console.log(`🔌 [${this.windowId}] WebSocket连接关闭: 代码=${event.code}`)\n-    this.state = WS_STATE.DISCONNECTED\n-    this.stopHealthCheck()\n-\n-    this.emit('disconnected', {\n-      code: event.code,\n-      reason: event.reason,\n-      windowId: this.windowId\n-    })\n-\n-    // 根据关闭原因决定是否重连\n-    if (event.code !== 1000) { // 非正常关闭\n-      this.scheduleReconnect()\n-    }\n+  // 🔧 获取连接的服务器\n+  getConnectedServer(windowId) {\n+    return this.connections.get(windowId)?.server || null\n   }\n \n-  /**\n-   * 🔧 发送消息\n-   */\n-  send(data) {\n-    if (this.state !== WS_STATE.CONNECTED || !this.connection) {\n-      console.warn(`⚠️ [${this.windowId}] WebSocket未连接，消息加入队列`)\n-      this.messageQueue.push(data)\n-      return false\n-    }\n-\n+  // 🔧 消息分发处理\n+  handleMessage(windowId, data) {\n     try {\n-      const message = typeof data === 'string' ? data : JSON.stringify(data)\n-      this.connection.send(message)\n-      return true\n-    } catch (error) {\n-      console.error(`❌ [${this.windowId}] WebSocket发送消息失败:`, error)\n-      return false\n-    }\n-  }\n+      const message = JSON.parse(data)\n+      const { type } = message\n \n-  /**\n-   * 🔧 处理消息队列\n-   */\n-  processMessageQueue() {\n-    if (this.messageQueue.length > 0 && this.state === WS_STATE.CONNECTED) {\n-      console.log(`📤 [${this.windowId}] 处理消息队列: ${this.messageQueue.length} 条消息`)\n-\n-      while (this.messageQueue.length > 0) {\n-        const message = this.messageQueue.shift()\n-        if (!this.send(message)) {\n-          // 发送失败，重新加入队列\n-          this.messageQueue.unshift(message)\n-          break\n-        }\n+      // 静默处理crystools.monitor消息\n+      if (type === 'crystools.monitor') {\n+        return\n       }\n-    }\n-  }\n \n-  /**\n-   * 🔧 事件监听\n-   */\n-  on(event, handler) {\n-    if (!this.eventHandlers.has(event)) {\n-      this.eventHandlers.set(event, new Set())\n-    }\n-    this.eventHandlers.get(event).add(handler)\n-    console.log(`📡 [${this.windowId}] 注册事件监听器: ${event}`)\n-  }\n+      console.log(`📨 [${windowId}] 收到消息: ${type}`)\n \n-  /**\n-   * 🔧 移除事件监听\n-   */\n-  off(event, handler) {\n-    if (this.eventHandlers.has(event)) {\n-      this.eventHandlers.get(event).delete(handler)\n-      console.log(`📡 [${this.windowId}] 移除事件监听器: ${event}`)\n-    }\n-  }\n+      // 分发到注册的处理器\n+      const handlers = this.messageHandlers.get(type) || []\n \n-  /**\n-   * 🔧 触发事件\n-   */\n-  emit(event, data) {\n-    if (this.eventHandlers.has(event)) {\n-      this.eventHandlers.get(event).forEach(handler => {\n+      handlers.forEach(({ handler, windowId: handlerWindowId }) => {\n+        // 如果处理器指定了窗口ID，只处理对应窗口的消息\n+        if (handlerWindowId && handlerWindowId !== windowId) {\n+          return\n+        }\n+\n         try {\n-          handler(data)\n+          handler(windowId, message)\n         } catch (error) {\n-          console.error(`❌ [${this.windowId}] 事件处理器错误 [${event}]:`, error)\n+          console.error(`❌ [${windowId}] 消息处理器执行失败:`, error)\n         }\n       })\n+\n+    } catch (error) {\n+      console.error(`❌ [${windowId}] 消息解析失败:`, error)\n     }\n   }\n \n-  /**\n-   * 🔧 服务器锁定\n-   */\n-  lockServer(serverUrl) {\n-    this.lockedServer = serverUrl\n-    this.lockTimestamp = Date.now()\n-    console.log(`🔒 [${this.windowId}] 锁定服务器: ${serverUrl}`)\n-    console.log(`🕐 [${this.windowId}] 锁定时间: ${new Date(this.lockTimestamp).toLocaleTimeString()}`)\n+  // 🔧 服务器锁定管理\n+  lockServer(windowId, server, taskCount = 0) {\n+    const timestamp = Date.now()\n+    this.serverLocks.set(windowId, {\n+      server,\n+      timestamp,\n+      windowId,\n+      taskCount\n+    })\n \n-    this.emit('server:locked', {\n-      server: serverUrl,\n-      timestamp: this.lockTimestamp,\n-      windowId: this.windowId\n-    })\n+    console.log(`🔒 [${windowId}] 锁定服务器: ${server}`)\n+    this.scheduleUnlockCheck(windowId)\n   }\n \n-  /**\n-   * 🔧 解锁服务器\n-   */\n-  unlockServer() {\n-    if (this.lockedServer) {\n-      console.log(`🔓 [${this.windowId}] 解锁服务器: ${this.lockedServer}`)\n-      const unlockedServer = this.lockedServer\n-      this.lockedServer = null\n-      this.lockTimestamp = null\n-\n-      this.emit('server:unlocked', {\n-        server: unlockedServer,\n-        windowId: this.windowId\n-      })\n+  // 🔧 解锁服务器\n+  unlockServer(windowId) {\n+    const lock = this.serverLocks.get(windowId)\n+    if (lock) {\n+      this.serverLocks.delete(windowId)\n+      console.log(`🔓 [${windowId}] 解锁服务器: ${lock.server}`)\n     }\n+    this.clearUnlockTimer(windowId)\n   }\n \n-  /**\n-   * 🔧 获取目标服务器\n-   */\n-  async getTargetServer() {\n-    // 如果有锁定的服务器，优先使用\n-    if (this.lockedServer) {\n-      console.log(`🔒 [${this.windowId}] 使用锁定的服务器: ${this.lockedServer}`)\n-      return this.lockedServer\n-    }\n-\n-    // 从负载均衡器获取最优服务器\n-    try {\n-      const optimalServer = await loadBalancer.getOptimalServer()\n-      console.log(`🎯 [${this.windowId}] 负载均衡选择服务器: ${optimalServer}`)\n-      return optimalServer\n-    } catch (error) {\n-      console.error(`❌ [${this.windowId}] 获取服务器失败:`, error)\n-      return null\n-    }\n+  // 🔧 获取服务器锁定信息\n+  getServerLock(windowId) {\n+    return this.serverLocks.get(windowId) || null\n   }\n \n-  /**\n-   * 🔧 启动健康检查\n-   */\n-  startHealthCheck() {\n-    this.stopHealthCheck() // 清理之前的检查\n+  // 🔧 调度解锁检查\n+  scheduleUnlockCheck(windowId) {\n+    this.clearUnlockTimer(windowId)\n \n-    this.healthCheckInterval = setInterval(() => {\n-      this.performHealthCheck()\n+    const timer = setInterval(() => {\n+      this.checkUnlockCondition(windowId)\n     }, 30000) // 每30秒检查一次\n \n-    console.log(`💓 [${this.windowId}] 启动健康检查`)\n+    this.unlockTimers.set(windowId, timer)\n+    console.log(`⏰ [${windowId}] 已调度解锁检查`)\n   }\n \n-  /**\n-   * 🔧 停止健康检查\n-   */\n-  stopHealthCheck() {\n-    if (this.healthCheckInterval) {\n-      clearInterval(this.healthCheckInterval)\n-      this.healthCheckInterval = null\n-      console.log(`💓 [${this.windowId}] 停止健康检查`)\n+  // 🔧 清理解锁定时器\n+  clearUnlockTimer(windowId) {\n+    const timer = this.unlockTimers.get(windowId)\n+    if (timer) {\n+      clearInterval(timer)\n+      this.unlockTimers.delete(windowId)\n+      console.log(`🧹 [${windowId}] 已清理解锁定时器`)\n     }\n   }\n \n-  /**\n-   * 🔧 执行健康检查\n-   */\n-  performHealthCheck() {\n-    const now = Date.now()\n-\n-    // 检查连接状态\n-    if (this.connection && this.connection.readyState !== WebSocket.OPEN) {\n-      console.warn(`⚠️ [${this.windowId}] 健康检查: WebSocket连接异常`)\n-      this.scheduleReconnect()\n-      return\n+  // 🔧 检查解锁条件（需要外部提供任务计数）\n+  checkUnlockCondition(windowId, taskCount = 0) {\n+    const lock = this.getServerLock(windowId)\n+    if (!lock) {\n+      this.clearUnlockTimer(windowId)\n+      return false\n     }\n \n-    // 检查消息活跃度\n-    if (this.lastMessageTime && (now - this.lastMessageTime) > 120000) { // 2分钟无消息\n-      console.warn(`⚠️ [${this.windowId}] 健康检查: 长时间无消息`)\n+    if (taskCount === 0) {\n+      console.log(`🔓 [${windowId}] 所有任务完成，自动解锁服务器`)\n+      this.unlockServer(windowId)\n+      return true\n     }\n \n-    console.log(`💓 [${this.windowId}] 健康检查通过`)\n+    console.log(`🔒 [${windowId}] 仍有 ${taskCount} 个任务，保持锁定`)\n+    return false\n   }\n \n-  /**\n-   * 🔧 检查连接健康状态\n-   */\n-  checkConnectionHealth() {\n-    if (this.state === WS_STATE.CONNECTED && this.connection) {\n-      if (this.connection.readyState !== WebSocket.OPEN) {\n-        console.warn(`⚠️ [${this.windowId}] 连接状态异常，尝试重连`)\n-        this.scheduleReconnect()\n+  // 🔧 获取所有连接状态\n+  getAllConnectionStatus() {\n+    const status = {}\n+    this.connections.forEach((info, windowId) => {\n+      status[windowId] = {\n+        isConnected: info.isConnected,\n+        server: info.server,\n+        clientId: info.clientId,\n+        connectedAt: info.connectedAt,\n+        lock: this.getServerLock(windowId)\n       }\n-    }\n+    })\n+    return status\n   }\n \n-  /**\n-   * 🔧 调度重连\n-   */\n-  scheduleReconnect() {\n-    if (this.reconnectTimer) {\n-      return // 已经在重连中\n-    }\n+  // 🔧 清理所有连接\n+  async cleanup() {\n+    console.log('🧹 清理所有WebSocket连接')\n \n-    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n-      console.error(`❌ [${this.windowId}] 重连次数超限，停止重连`)\n-      this.state = WS_STATE.FAILED\n-      this.emit('reconnect:failed', { windowId: this.windowId })\n-      return\n-    }\n+    // 清理所有定时器\n+    this.unlockTimers.forEach((timer, windowId) => {\n+      clearInterval(timer)\n+    })\n+    this.unlockTimers.clear()\n \n-    this.state = WS_STATE.RECONNECTING\n-    this.reconnectAttempts++\n+    // 断开所有连接\n+    const disconnectPromises = Array.from(this.connections.keys()).map(windowId =>\n+      this.disconnect(windowId)\n+    )\n \n-    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1) // 指数退避\n+    await Promise.all(disconnectPromises)\n \n-    console.log(`🔄 [${this.windowId}] 调度重连 (第${this.reconnectAttempts}次，${delay}ms后)`)\n+    // 清理所有数据\n+    this.connections.clear()\n+    this.serverLocks.clear()\n+    this.messageHandlers.clear()\n \n-    this.reconnectTimer = setTimeout(async () => {\n-      this.reconnectTimer = null\n-\n-      try {\n-        await this.connect(this.lockedServer)\n-        console.log(`✅ [${this.windowId}] 重连成功`)\n-        this.emit('reconnect:success', { windowId: this.windowId })\n-      } catch (error) {\n-        console.error(`❌ [${this.windowId}] 重连失败:`, error)\n-        this.scheduleReconnect() // 继续尝试重连\n-      }\n-    }, delay)\n+    console.log('✅ WebSocket管理器清理完成')\n   }\n+}\n \n-  /**\n-   * 🔧 清除重连定时器\n-   */\n-  clearReconnectTimer() {\n-    if (this.reconnectTimer) {\n-      clearTimeout(this.reconnectTimer)\n-      this.reconnectTimer = null\n-      console.log(`🧹 [${this.windowId}] 清除重连定时器`)\n-    }\n-  }\n+// 🔧 创建全局WebSocket管理器实例\n+const websocketManager = new WebSocketManager()\n \n-  /**\n-   * 🔧 断开连接\n-   */\n-  disconnect() {\n-    this.stopHealthCheck()\n-    this.clearReconnectTimer()\n-\n-    if (this.connection) {\n-      this.connection.close(1000, '主动断开连接')\n-      this.connection = null\n-    }\n-\n-    this.state = WS_STATE.DISCONNECTED\n-    this.currentServer = null\n-    this.emit('disconnected', { windowId: this.windowId })\n-    console.log(`🔌 [${this.windowId}] WebSocket已断开连接`)\n-  }\n-\n-  /**\n-   * 🔧 强制重连到指定服务器\n-   */\n-  async forceReconnect(serverUrl = null) {\n-    console.log(`🔄 [${this.windowId}] 强制重连到服务器: ${serverUrl || '自动选择'}`)\n-\n-    // 断开现有连接\n-    this.disconnect()\n-\n-    // 重置重连计数\n-    this.reconnectAttempts = 0\n-\n-    // 连接到指定服务器\n-    return await this.connect(serverUrl)\n-  }\n-\n-  /**\n-   * 🔧 确保WebSocket连接\n-   */\n-  async ensureConnection(serverUrl = null) {\n-    // 如果指定了服务器且与当前不同，需要重新连接\n-    if (serverUrl && this.lockedServer && serverUrl !== this.lockedServer) {\n-      console.log(`🔄 [${this.windowId}] 服务器不一致，重新连接`)\n-      console.log(`   当前锁定: ${this.lockedServer}`)\n-      console.log(`   目标服务器: ${serverUrl}`)\n-      return await this.forceReconnect(serverUrl)\n-    }\n-\n-    // 如果已连接且服务器一致，直接返回\n-    if (this.state === WS_STATE.CONNECTED && this.connection?.readyState === WebSocket.OPEN) {\n-      console.log(`✅ [${this.windowId}] WebSocket已连接`)\n-      this.processMessageQueue() // 处理待发送消息\n-      return true\n-    }\n-\n-    // 需要建立新连接\n-    console.log(`🔄 [${this.windowId}] 建立新的WebSocket连接`)\n-    return await this.connect(serverUrl)\n-  }\n-\n-  /**\n-   * 🔧 获取连接状态\n-   */\n-  getStatus() {\n-    return {\n-      windowId: this.windowId,\n-      clientId: this.clientId,\n-      state: this.state,\n-      isConnected: this.state === WS_STATE.CONNECTED,\n-      currentServer: this.currentServer,\n-      lockedServer: this.lockedServer,\n-      lockTimestamp: this.lockTimestamp,\n-      lockDuration: this.lockTimestamp ? Date.now() - this.lockTimestamp : null,\n-      reconnectAttempts: this.reconnectAttempts,\n-      connectionState: this.connection?.readyState || 'CLOSED',\n-      messageQueueLength: this.messageQueue.length,\n-      lastMessageTime: this.lastMessageTime\n-    }\n-  }\n-\n-  /**\n-   * 🔧 调试信息\n-   */\n-  debug() {\n-    const status = this.getStatus()\n-    console.log(`🔍 [${this.windowId}] ===== WebSocket管理器状态 =====`)\n-    console.log(`🪟 窗口ID: ${status.windowId}`)\n-    console.log(`🔑 客户端ID: ${status.clientId}`)\n-    console.log(`🔗 连接状态: ${status.state}`)\n-    console.log(`📡 当前服务器: ${status.currentServer || '无'}`)\n-    console.log(`🔒 锁定服务器: ${status.lockedServer || '无'}`)\n-    console.log(`🕐 锁定时间: ${status.lockTimestamp ? new Date(status.lockTimestamp).toLocaleString() : '无'}`)\n-    console.log(`⏱️ 锁定持续: ${status.lockDuration ? Math.round(status.lockDuration / 1000) + '秒' : '无'}`)\n-    console.log(`🔄 重连次数: ${status.reconnectAttempts}`)\n-    console.log(`📤 消息队列: ${status.messageQueueLength} 条`)\n-    console.log(`📨 最后消息: ${status.lastMessageTime ? new Date(status.lastMessageTime).toLocaleString() : '无'}`)\n-    console.log(`🔍 [${this.windowId}] ===== 状态信息结束 =====`)\n-\n-    return status\n-  }\n-\n-  /**\n-   * 🔧 重置管理器状态\n-   */\n-  reset() {\n-    console.log(`🔄 [${this.windowId}] 重置WebSocket管理器`)\n-\n-    this.disconnect()\n-    this.unlockServer()\n-    this.messageQueue = []\n-    this.reconnectAttempts = 0\n-    this.lastMessageTime = null\n-\n-    console.log(`✅ [${this.windowId}] WebSocket管理器已重置`)\n-  }\n+// 🔧 导出管理器实例和相关工具\n+export {\n+  websocketManager,\n+  WebSocketManager\n }\n \n-// 创建全局实例\n-const webSocketManager = new WebSocketManager()\n-\n-// 暴露调试函数到全局\n+// 🔧 在窗口卸载时清理资源\n if (typeof window !== 'undefined') {\n-  window.webSocketManager = webSocketManager\n-  window.debugWebSocket = () => webSocketManager.debug()\n-  window.resetWebSocket = () => webSocketManager.reset()\n+  window.addEventListener('beforeunload', () => {\n+    websocketManager.cleanup()\n+  })\n }\n-\n-export default webSocketManager\n"
                },
                {
                    "date": 1753504742879,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,8 +70,21 @@\n \n       // 关闭现有连接\n       await this.disconnect(windowId)\n \n+      // 简单的HTTP连接测试\n+      try {\n+        const testResponse = await fetch(`${server}/api/queue`, {\n+          method: 'GET',\n+          signal: AbortSignal.timeout(5000)\n+        })\n+        if (!testResponse.ok) {\n+          throw new Error(`服务器响应错误: ${testResponse.status}`)\n+        }\n+      } catch (httpError) {\n+        throw new Error(`ComfyUI服务器不可达: ${httpError.message}`)\n+      }\n+\n       // 创建新连接\n       const ws = new WebSocket(wsUrl)\n \n       // 设置连接信息\n"
                },
                {
                    "date": 1753504755349,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,8 +107,20 @@\n         ws.onopen = () => {\n           connectionInfo.isConnected = true\n           clearTimeout(timeout)\n           console.log(`✅ [${windowId}] WebSocket连接成功`)\n+\n+          // 触发自定义事件供Vue组件监听\n+          if (typeof window !== 'undefined') {\n+            window.dispatchEvent(new CustomEvent('comfyui-status', {\n+              detail: {\n+                message: `[${windowId}] WebSocket连接成功`,\n+                type: 'success',\n+                timestamp: Date.now()\n+              }\n+            }))\n+          }\n+\n           resolve(connectionInfo)\n         }\n \n         ws.onmessage = (event) => {\n"
                },
                {
                    "date": 1753504766757,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -129,8 +129,19 @@\n \n         ws.onclose = (event) => {\n           connectionInfo.isConnected = false\n           console.log(`🔌 [${windowId}] WebSocket连接关闭:`, event.code, event.reason)\n+\n+          // 触发连接关闭事件\n+          if (typeof window !== 'undefined') {\n+            window.dispatchEvent(new CustomEvent('comfyui-status', {\n+              detail: {\n+                message: `[${windowId}] WebSocket连接关闭`,\n+                type: 'warning',\n+                timestamp: Date.now()\n+              }\n+            }))\n+          }\n         }\n \n         ws.onerror = (error) => {\n           connectionInfo.isConnected = false\n"
                },
                {
                    "date": 1753504781394,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -250,8 +250,39 @@\n   getServerLock(windowId) {\n     return this.serverLocks.get(windowId) || null\n   }\n \n+  // 🔧 强制解锁服务器\n+  forceUnlockServer(windowId) {\n+    this.unlockServer(windowId)\n+    console.log(`🔓 [${windowId}] 强制解锁服务器`)\n+  }\n+\n+  // 🔧 更新任务计数\n+  updateTaskCount(windowId, taskCount) {\n+    const lock = this.getServerLock(windowId)\n+    if (lock) {\n+      lock.taskCount = taskCount\n+      console.log(`📊 [${windowId}] 更新任务计数: ${taskCount}`)\n+    }\n+  }\n+\n+  // 🔧 重置服务器连接\n+  async resetServer(windowId, force = false) {\n+    console.log(`🔄 [${windowId}] 重置WebSocket服务器 (强制: ${force})`)\n+\n+    // 断开现有连接\n+    await this.disconnect(windowId)\n+\n+    // 清理服务器锁定\n+    if (force) {\n+      this.forceUnlockServer(windowId)\n+    }\n+\n+    console.log(`✅ [${windowId}] WebSocket服务器重置完成`)\n+    return true\n+  }\n+\n   // 🔧 调度解锁检查\n   scheduleUnlockCheck(windowId) {\n     this.clearUnlockTimer(windowId)\n \n"
                },
                {
                    "date": 1753504791197,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -368,9 +368,10 @@\n \n // 🔧 导出管理器实例和相关工具\n export {\n   websocketManager,\n-  WebSocketManager\n+  WebSocketManager,\n+  generateClientId\n }\n \n // 🔧 在窗口卸载时清理资源\n if (typeof window !== 'undefined') {\n"
                },
                {
                    "date": 1753506267468,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,381 +1,374 @@\n-// 🔧 WebSocket管理器 - 独立的连接池和消息分发系统\n-// 支持多窗口隔离、消息处理器注册、服务器锁定等功能\n+// WebSocket 管理器 - 独立模块\n+// 负责所有 WebSocket 连接管理、消息处理、重连逻辑和窗口隔离机制\n \n-// 🔧 生成唯一客户端ID的函数（避免循环依赖）\n-function generateClientId() {\n+import loadBalancer from './loadBalancer.js'\n+\n+// 🔧 窗口唯一标识符生成机制\n+function generateWindowId() {\n+  return `${Date.now()}_${Math.random().toString(36).substring(2, 11)}`\n+}\n+\n+// 🔧 为当前窗口生成唯一的clientId - 增强唯一性防止冲突\n+function generateUniqueClientId() {\n+  const baseId = 'abc1373d4ad648a3a81d0587fbe5534b' // 基础clientId\n   const timestamp = Date.now()\n-  const random = Math.random().toString(36).substring(2, 8)\n-  const windowId = typeof window !== 'undefined' ?\n-    (window.WINDOW_ID || 'unknown') : 'server'\n-  return `${windowId}_${timestamp}_${random}`\n+  const random = Math.random().toString(36).substring(2, 11)\n+  const windowId = generateWindowId()\n+\n+  // 🔧 增强唯一性：基础ID + 时间戳 + 随机数 + 窗口ID\n+  return `${baseId}_${timestamp}_${random}_${windowId}`\n }\n \n-// 🔧 WebSocket连接管理器类\n+// 🔧 窗口级别的全局变量 - 确保每个窗口都有唯一标识\n+const WINDOW_CLIENT_ID = generateUniqueClientId()\n+const WINDOW_ID = generateWindowId()\n+\n+console.log(`🪟 窗口标识: ${WINDOW_ID}`)\n+console.log(`🔑 窗口客户端ID: ${WINDOW_CLIENT_ID}`)\n+\n+/**\n+ * WebSocket 管理器类\n+ * 负责 WebSocket 连接的完整生命周期管理\n+ */\n class WebSocketManager {\n   constructor() {\n-    // 连接池：windowId -> { connection, server, clientId, isConnected }\n-    this.connections = new Map()\n+    // WebSocket 连接状态\n+    this.wsConnection = null\n+    this.isWsConnected = false\n+    this.currentWebSocketServer = null\n \n-    // 消息处理器注册表：messageType -> handler[]\n-    this.messageHandlers = new Map()\n+    // 窗口隔离的任务队列\n+    this.windowTasks = new Map() // promptId -> task\n \n-    // 窗口级别的服务器锁定：windowId -> { server, timestamp, tasks }\n-    this.serverLocks = new Map()\n+    // 窗口级别的服务器锁定机制\n+    this.WINDOW_SERVER_LOCKS = new Map() // windowId -> { server, timestamp, tasks }\n \n-    // 解锁检查定时器：windowId -> timerId\n-    this.unlockTimers = new Map()\n+    // 动态解锁检查机制\n+    this.serverUnlockTimer = null\n \n-    console.log('🔧 WebSocket管理器已初始化')\n-  }\n+    // 防抖机制：避免频繁的进度回调触发递归更新\n+    this.progressCallbackDebounce = new Map()\n \n-  // 🔧 注册消息处理器\n-  registerHandler(messageType, handler, windowId = null) {\n-    if (!this.messageHandlers.has(messageType)) {\n-      this.messageHandlers.set(messageType, [])\n+    // 官方标准任务状态枚举\n+    this.TASK_STATUS = {\n+      WAITING: 'waiting',        // 任务在队列中等待\n+      EXECUTING: 'executing',    // 任务正在执行\n+      COMPLETED: 'completed',    // 任务已完成\n+      ERROR: 'error',           // 任务执行错误\n+      INTERRUPTED: 'interrupted' // 任务被中断\n     }\n \n-    const handlerInfo = { handler, windowId }\n-    this.messageHandlers.get(messageType).push(handlerInfo)\n-\n-    console.log(`📝 注册消息处理器: ${messageType} (窗口: ${windowId || 'global'})`)\n+    // 初始化窗口事件监听\n+    this._initializeWindowEvents()\n+    this._initializeGlobalProperties()\n   }\n \n-  // 🔧 移除消息处理器\n-  unregisterHandler(messageType, handler) {\n-    const handlers = this.messageHandlers.get(messageType)\n-    if (handlers) {\n-      const index = handlers.findIndex(h => h.handler === handler)\n-      if (index !== -1) {\n-        handlers.splice(index, 1)\n-        console.log(`🗑️ 移除消息处理器: ${messageType}`)\n-      }\n-    }\n-  }\n+  // 🔧 窗口关闭时的清理机制\n+  _initializeWindowEvents() {\n+    window.addEventListener('beforeunload', () => {\n+      console.log(`🚪 [${WINDOW_ID}] 窗口即将关闭，执行清理...`)\n \n-  // 🔧 连接到指定服务器\n-  async connect(windowId, server, clientId = null) {\n-    try {\n-      // 生成或使用提供的clientId\n-      const finalClientId = clientId || generateClientId()\n-\n-      // 构建WebSocket URL\n-      let wsUrl\n-      if (server.startsWith('https://')) {\n-        wsUrl = server.replace('https://', 'wss://') + '/ws?clientId=' + finalClientId\n-      } else {\n-        wsUrl = server.replace('http://', 'ws://') + '/ws?clientId=' + finalClientId\n+      // 清理当前窗口的服务器锁定\n+      const currentLock = this.getWindowServerLock()\n+      if (currentLock) {\n+        console.log(`🔓 [${WINDOW_ID}] 窗口关闭，清理服务器锁定: ${currentLock.server}`)\n+        this.clearWindowServerLock()\n       }\n \n-      console.log(`🔌 [${windowId}] 连接WebSocket: ${wsUrl}`)\n-\n-      // 关闭现有连接\n-      await this.disconnect(windowId)\n-\n-      // 简单的HTTP连接测试\n-      try {\n-        const testResponse = await fetch(`${server}/api/queue`, {\n-          method: 'GET',\n-          signal: AbortSignal.timeout(5000)\n-        })\n-        if (!testResponse.ok) {\n-          throw new Error(`服务器响应错误: ${testResponse.status}`)\n-        }\n-      } catch (httpError) {\n-        throw new Error(`ComfyUI服务器不可达: ${httpError.message}`)\n+      // 清理当前窗口的任务\n+      if (this.windowTasks.size > 0) {\n+        console.log(`🗑️ [${WINDOW_ID}] 窗口关闭，清理 ${this.windowTasks.size} 个任务`)\n+        this.windowTasks.clear()\n       }\n \n-      // 创建新连接\n-      const ws = new WebSocket(wsUrl)\n-\n-      // 设置连接信息\n-      const connectionInfo = {\n-        connection: ws,\n-        server: server,\n-        clientId: finalClientId,\n-        isConnected: false,\n-        windowId: windowId,\n-        connectedAt: Date.now()\n+      // 关闭WebSocket连接\n+      if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) {\n+        console.log(`🔌 [${WINDOW_ID}] 窗口关闭，断开WebSocket连接`)\n+        this.wsConnection.close()\n       }\n+    })\n \n-      this.connections.set(windowId, connectionInfo)\n+    // 🔧 页面可见性变化时的处理\n+    document.addEventListener('visibilitychange', () => {\n+      if (document.hidden) {\n+        console.log(`👁️ [${WINDOW_ID}] 窗口隐藏`)\n+      } else {\n+        console.log(`👁️ [${WINDOW_ID}] 窗口重新可见`)\n \n-      return new Promise((resolve, reject) => {\n-        const timeout = setTimeout(() => {\n-          reject(new Error('WebSocket连接超时'))\n-        }, 10000)\n-\n-        ws.onopen = () => {\n-          connectionInfo.isConnected = true\n-          clearTimeout(timeout)\n-          console.log(`✅ [${windowId}] WebSocket连接成功`)\n-\n-          // 触发自定义事件供Vue组件监听\n-          if (typeof window !== 'undefined') {\n-            window.dispatchEvent(new CustomEvent('comfyui-status', {\n-              detail: {\n-                message: `[${windowId}] WebSocket连接成功`,\n-                type: 'success',\n-                timestamp: Date.now()\n-              }\n-            }))\n-          }\n-\n-          resolve(connectionInfo)\n+        // 检查服务器锁定状态\n+        const currentLock = this.getWindowServerLock()\n+        if (currentLock) {\n+          console.log(`🔒 [${WINDOW_ID}] 窗口重新可见，服务器锁定状态: ${currentLock.server}`)\n         }\n \n-        ws.onmessage = (event) => {\n-          this.handleMessage(windowId, event.data)\n+        // 检查任务状态\n+        if (this.windowTasks.size > 0) {\n+          console.log(`📊 [${WINDOW_ID}] 窗口重新可见，当前任务数: ${this.windowTasks.size}`)\n         }\n+      }\n+    })\n+  }\n \n-        ws.onclose = (event) => {\n-          connectionInfo.isConnected = false\n-          console.log(`🔌 [${windowId}] WebSocket连接关闭:`, event.code, event.reason)\n-\n-          // 触发连接关闭事件\n-          if (typeof window !== 'undefined') {\n-            window.dispatchEvent(new CustomEvent('comfyui-status', {\n-              detail: {\n-                message: `[${windowId}] WebSocket连接关闭`,\n-                type: 'warning',\n-                timestamp: Date.now()\n-              }\n-            }))\n-          }\n+  // 🔧 初始化全局属性以保持向后兼容\n+  _initializeGlobalProperties() {\n+    // 🔧 兼容性：动态获取当前窗口的锁定服务器\n+    Object.defineProperty(window, 'windowLockedServer', {\n+      get: () => {\n+        const lock = this.getWindowServerLock()\n+        return lock ? lock.server : null\n+      },\n+      set: (value) => {\n+        if (value) {\n+          this.setWindowServerLock(value)\n+        } else {\n+          this.clearWindowServerLock()\n         }\n+      }\n+    })\n \n-        ws.onerror = (error) => {\n-          connectionInfo.isConnected = false\n-          clearTimeout(timeout)\n-          console.error(`❌ [${windowId}] WebSocket连接错误:`, error)\n-          reject(error)\n-        }\n-      })\n+    Object.defineProperty(window, 'windowLockTimestamp', {\n+      get: () => {\n+        const lock = this.getWindowServerLock()\n+        return lock ? lock.timestamp : null\n+      }\n+    })\n \n-    } catch (error) {\n-      console.error(`❌ [${windowId}] WebSocket连接失败:`, error)\n-      throw error\n-    }\n-  }\n+    // 🔧 保留原有的全局变量名但使用窗口级别的值（动态获取）\n+    Object.defineProperty(window, 'currentWebSocketServer', {\n+      get: () => {\n+        return window.windowLockedServer\n+      },\n+      set: (value) => {\n+        window.windowLockedServer = value\n+      }\n+    })\n \n-  // 🔧 断开连接\n-  async disconnect(windowId) {\n-    const connectionInfo = this.connections.get(windowId)\n-    if (connectionInfo && connectionInfo.connection) {\n-      try {\n-        connectionInfo.connection.close()\n-        console.log(`🔌 [${windowId}] WebSocket连接已断开`)\n-      } catch (error) {\n-        console.warn(`⚠️ [${windowId}] 断开WebSocket连接时出错:`, error)\n+    Object.defineProperty(window, 'serverLockTimestamp', {\n+      get: () => {\n+        return window.windowLockTimestamp\n       }\n-    }\n-    this.connections.delete(windowId)\n-  }\n+    })\n \n-  // 🔧 获取连接信息\n-  getConnection(windowId) {\n-    return this.connections.get(windowId)?.connection || null\n+    // 🔧 为了向后兼容，保留 pendingTasks 引用但指向窗口任务队列\n+    window.pendingTasks = this.windowTasks\n   }\n \n-  // 🔧 检查连接状态\n-  isConnected(windowId) {\n-    const connectionInfo = this.connections.get(windowId)\n-    return connectionInfo?.isConnected &&\n-           connectionInfo.connection?.readyState === WebSocket.OPEN\n+  // 🔧 获取当前窗口的服务器锁定信息\n+  getWindowServerLock() {\n+    return this.WINDOW_SERVER_LOCKS.get(WINDOW_ID) || null\n   }\n \n-  // 🔧 获取连接的服务器\n-  getConnectedServer(windowId) {\n-    return this.connections.get(windowId)?.server || null\n-  }\n-\n-  // 🔧 消息分发处理\n-  handleMessage(windowId, data) {\n-    try {\n-      const message = JSON.parse(data)\n-      const { type } = message\n-\n-      // 静默处理crystools.monitor消息\n-      if (type === 'crystools.monitor') {\n-        return\n-      }\n-\n-      console.log(`📨 [${windowId}] 收到消息: ${type}`)\n-\n-      // 分发到注册的处理器\n-      const handlers = this.messageHandlers.get(type) || []\n-\n-      handlers.forEach(({ handler, windowId: handlerWindowId }) => {\n-        // 如果处理器指定了窗口ID，只处理对应窗口的消息\n-        if (handlerWindowId && handlerWindowId !== windowId) {\n-          return\n-        }\n-\n-        try {\n-          handler(windowId, message)\n-        } catch (error) {\n-          console.error(`❌ [${windowId}] 消息处理器执行失败:`, error)\n-        }\n-      })\n-\n-    } catch (error) {\n-      console.error(`❌ [${windowId}] 消息解析失败:`, error)\n-    }\n-  }\n-\n-  // 🔧 服务器锁定管理\n-  lockServer(windowId, server, taskCount = 0) {\n-    const timestamp = Date.now()\n-    this.serverLocks.set(windowId, {\n+  // 🔧 设置当前窗口的服务器锁定信息\n+  setWindowServerLock(server, timestamp = Date.now()) {\n+    this.WINDOW_SERVER_LOCKS.set(WINDOW_ID, {\n       server,\n       timestamp,\n-      windowId,\n-      taskCount\n+      windowId: WINDOW_ID,\n+      clientId: WINDOW_CLIENT_ID\n     })\n-\n-    console.log(`🔒 [${windowId}] 锁定服务器: ${server}`)\n-    this.scheduleUnlockCheck(windowId)\n+    console.log(`🔒 [${WINDOW_ID}] 设置窗口服务器锁定: ${server}`)\n   }\n \n-  // 🔧 解锁服务器\n-  unlockServer(windowId) {\n-    const lock = this.serverLocks.get(windowId)\n+  // 🔧 清除当前窗口的服务器锁定信息\n+  clearWindowServerLock() {\n+    const lock = this.WINDOW_SERVER_LOCKS.get(WINDOW_ID)\n     if (lock) {\n-      this.serverLocks.delete(windowId)\n-      console.log(`🔓 [${windowId}] 解锁服务器: ${lock.server}`)\n+      this.WINDOW_SERVER_LOCKS.delete(WINDOW_ID)\n+      console.log(`🔓 [${WINDOW_ID}] 清除窗口服务器锁定: ${lock.server}`)\n     }\n-    this.clearUnlockTimer(windowId)\n   }\n \n-  // 🔧 获取服务器锁定信息\n-  getServerLock(windowId) {\n-    return this.serverLocks.get(windowId) || null\n+  // 🔧 动态服务器锁定管理（基于任务状态的智能锁定）\n+  lockServerForWindow(serverUrl) {\n+    const timestamp = Date.now()\n+    this.setWindowServerLock(serverUrl, timestamp)\n+\n+    console.log(`🔒 [${WINDOW_ID}] 锁定服务器: ${serverUrl}`)\n+    console.log(`🕐 [${WINDOW_ID}] 锁定时间: ${new Date(timestamp).toLocaleTimeString()}`)\n+    console.log(`🎯 [${WINDOW_ID}] 锁定模式: 任务驱动动态锁定（无固定超时）`)\n+    console.log(`🪟 [${WINDOW_ID}] 窗口隔离: 独立锁定，不影响其他窗口`)\n+\n+    // 🔧 实现动态锁定机制：在任务完成前不解锁服务器\n+    this.scheduleServerUnlockCheck()\n   }\n \n-  // 🔧 强制解锁服务器\n-  forceUnlockServer(windowId) {\n-    this.unlockServer(windowId)\n-    console.log(`🔓 [${windowId}] 强制解锁服务器`)\n+  unlockServerForWindow() {\n+    const currentLock = this.getWindowServerLock()\n+    if (currentLock) {\n+      const lockDuration = Date.now() - currentLock.timestamp\n+      console.log(`🔓 [${WINDOW_ID}] 解锁服务器: ${currentLock.server}`)\n+      console.log(`⏱️ [${WINDOW_ID}] 锁定持续时间: ${Math.round(lockDuration / 1000)}秒`)\n+      console.log(`📊 [${WINDOW_ID}] 解锁时任务数: ${this.windowTasks.size}`)\n+      console.log(`🪟 [${WINDOW_ID}] 窗口隔离: 仅解锁当前窗口，不影响其他窗口`)\n+\n+      this.clearWindowServerLock()\n+\n+      // 清理解锁检查定时器\n+      this.clearServerUnlockTimer()\n+    }\n   }\n \n-  // 🔧 更新任务计数\n-  updateTaskCount(windowId, taskCount) {\n-    const lock = this.getServerLock(windowId)\n-    if (lock) {\n-      lock.taskCount = taskCount\n-      console.log(`📊 [${windowId}] 更新任务计数: ${taskCount}`)\n+  // 🔧 强制解锁服务器（用于异常情况处理）\n+  forceUnlockServerForWindow() {\n+    const currentLock = this.getWindowServerLock()\n+    if (currentLock) {\n+      console.log(`🚨 [${WINDOW_ID}] 强制解锁服务器: ${currentLock.server}`)\n+      console.log(`⚠️ [${WINDOW_ID}] 当前仍有 ${this.windowTasks.size} 个待处理任务`)\n+      console.log(`🪟 [${WINDOW_ID}] 窗口隔离: 强制解锁仅影响当前窗口`)\n+      this.unlockServerForWindow()\n+      return true\n     }\n+    return false\n   }\n \n-  // 🔧 重置服务器连接\n-  async resetServer(windowId, force = false) {\n-    console.log(`🔄 [${windowId}] 重置WebSocket服务器 (强制: ${force})`)\n+  // 🔧 窗口级别的任务管理函数 - 完全隔离版本\n+  registerWindowTask(promptId, task) {\n+    let currentLock = this.getWindowServerLock()\n \n-    // 断开现有连接\n-    await this.disconnect(windowId)\n+    // 🔧 智能验证：如果服务器未锁定，自动锁定到当前API服务器\n+    if (!currentLock || !currentLock.server) {\n+      console.warn(`⚠️ [${WINDOW_ID}] 注册任务时服务器未锁定，尝试自动锁定...`)\n+      try {\n+        // 使用当前任务的执行服务器或默认API服务器\n+        const serverToLock = task.executionServer || this._getDefaultServerUrl()\n+        this.lockServerForWindow(serverToLock)\n+        currentLock = this.getWindowServerLock()\n+        console.log(`🔒 [${WINDOW_ID}] 自动锁定服务器: ${serverToLock}`)\n+      } catch (lockError) {\n+        console.error(`❌ [${WINDOW_ID}] 自动锁定失败: ${lockError.message}`)\n+        // 继续执行，但记录警告\n+        console.warn(`⚠️ [${WINDOW_ID}] 任务 ${promptId} 将在无锁定状态下注册`)\n+      }\n+    }\n \n-    // 清理服务器锁定\n-    if (force) {\n-      this.forceUnlockServer(windowId)\n+    // 🔧 智能绑定服务器：优先使用锁定服务器，否则使用任务自带的服务器\n+    if (currentLock && currentLock.server) {\n+      task.executionServer = currentLock.server\n+    } else if (!task.executionServer) {\n+      // 如果都没有，使用默认配置\n+      task.executionServer = this._getDefaultServerUrl()\n+      console.warn(`⚠️ [${WINDOW_ID}] 使用默认服务器绑定任务: ${task.executionServer}`)\n     }\n \n-    console.log(`✅ [${windowId}] WebSocket服务器重置完成`)\n-    return true\n-  }\n+    task.windowId = WINDOW_ID\n+    task.clientId = WINDOW_CLIENT_ID\n+    task.registeredAt = Date.now()\n+    task.lockInfo = currentLock ? { ...currentLock } : null // 保存锁定信息快照\n \n-  // 🔧 调度解锁检查\n-  scheduleUnlockCheck(windowId) {\n-    this.clearUnlockTimer(windowId)\n+    this.windowTasks.set(promptId, task)\n \n-    const timer = setInterval(() => {\n-      this.checkUnlockCondition(windowId)\n-    }, 30000) // 每30秒检查一次\n+    console.log(`📝 [${WINDOW_ID}] 任务已注册: ${promptId}, 绑定服务器: ${task.executionServer}`)\n+    console.log(`📊 [${WINDOW_ID}] 当前窗口任务数: ${this.windowTasks.size}`)\n+    console.log(`🔒 [${WINDOW_ID}] 任务锁定信息:`, task.lockInfo)\n \n-    this.unlockTimers.set(windowId, timer)\n-    console.log(`⏰ [${windowId}] 已调度解锁检查`)\n+    // 🔧 锁定续期：检测到新任务时自动续期锁定状态\n+    if (currentLock) {\n+      console.log(`🔄 [${WINDOW_ID}] 检测到新任务，续期服务器锁定状态`)\n+      // 重新调度解锁检查\n+      this.scheduleServerUnlockCheck()\n+    }\n   }\n \n-  // 🔧 清理解锁定时器\n-  clearUnlockTimer(windowId) {\n-    const timer = this.unlockTimers.get(windowId)\n-    if (timer) {\n-      clearInterval(timer)\n-      this.unlockTimers.delete(windowId)\n-      console.log(`🧹 [${windowId}] 已清理解锁定时器`)\n+  getWindowTask(promptId) {\n+    const task = this.windowTasks.get(promptId)\n+    if (task) {\n+      // 🔧 简化检测：如果任务存在就返回，不严格检查窗口归属\n+      // 这样可以避免因窗口ID不匹配导致的任务丢失\n+      if (task.windowId !== WINDOW_ID) {\n+        console.log(`🔍 [${WINDOW_ID}] 使用其他窗口的任务: ${promptId} (原窗口: ${task.windowId})`)\n+      }\n+      return task\n     }\n+\n+    return null\n   }\n \n-  // 🔧 检查解锁条件（需要外部提供任务计数）\n-  checkUnlockCondition(windowId, taskCount = 0) {\n-    const lock = this.getServerLock(windowId)\n-    if (!lock) {\n-      this.clearUnlockTimer(windowId)\n-      return false\n-    }\n+  removeWindowTask(promptId) {\n+    const task = this.windowTasks.get(promptId)\n+    if (task && task.windowId === WINDOW_ID) {\n+      this.windowTasks.delete(promptId)\n+      console.log(`🗑️ [${WINDOW_ID}] 任务已移除: ${promptId}`)\n+      console.log(`📊 [${WINDOW_ID}] 剩余窗口任务数: ${this.windowTasks.size}`)\n \n-    if (taskCount === 0) {\n-      console.log(`🔓 [${windowId}] 所有任务完成，自动解锁服务器`)\n-      this.unlockServer(windowId)\n+      // 🔧 任务移除后立即检查是否可以解锁服务器\n+      const currentLock = this.getWindowServerLock()\n+      if (this.windowTasks.size === 0 && currentLock) {\n+        console.log(`🔓 [${WINDOW_ID}] 最后一个任务完成，立即解锁服务器`)\n+        this.unlockServerForWindow()\n+      } else if (this.windowTasks.size > 0) {\n+        console.log(`🔒 [${WINDOW_ID}] 仍有任务运行，保持服务器锁定`)\n+      }\n+\n       return true\n     }\n-\n-    console.log(`🔒 [${windowId}] 仍有 ${taskCount} 个任务，保持锁定`)\n     return false\n   }\n \n-  // 🔧 获取所有连接状态\n-  getAllConnectionStatus() {\n-    const status = {}\n-    this.connections.forEach((info, windowId) => {\n-      status[windowId] = {\n-        isConnected: info.isConnected,\n-        server: info.server,\n-        clientId: info.clientId,\n-        connectedAt: info.connectedAt,\n-        lock: this.getServerLock(windowId)\n+  // 🔧 新增：根据任务ID获取绑定的服务器地址\n+  getTaskBoundServer(promptId) {\n+    const task = this.getWindowTask(promptId)\n+    if (task && task.executionServer) {\n+      console.log(`🎯 [${WINDOW_ID}] 任务 ${promptId} 绑定服务器: ${task.executionServer}`)\n+      return task.executionServer\n+    }\n+    console.warn(`⚠️ [${WINDOW_ID}] 任务 ${promptId} 未找到绑定服务器`)\n+    return null\n+  }\n+\n+  // 🔧 窗口间通信机制（用于调试和监控）\n+  broadcastTaskStatus(promptId, status) {\n+    try {\n+      const message = {\n+        type: 'task_status',\n+        windowId: WINDOW_ID,\n+        clientId: WINDOW_CLIENT_ID,\n+        promptId: promptId,\n+        status: status,\n+        timestamp: Date.now()\n       }\n-    })\n-    return status\n+\n+      localStorage.setItem(`comfyui_task_${promptId}`, JSON.stringify(message))\n+      console.log(`📡 [${WINDOW_ID}] 广播任务状态: ${promptId} -> ${status}`)\n+    } catch (error) {\n+      console.warn(`⚠️ [${WINDOW_ID}] 广播任务状态失败:`, error)\n+    }\n   }\n \n-  // 🔧 清理所有连接\n-  async cleanup() {\n-    console.log('🧹 清理所有WebSocket连接')\n+  // 🔧 原子性任务状态更新函数 - 窗口隔离版本\n+  updateTaskStatus(promptId, newStatus, additionalData = {}) {\n+    // 🔧 只处理属于当前窗口的任务\n+    const task = this.getWindowTask(promptId)\n+    if (!task) {\n+      console.warn(`⚠️ [${WINDOW_ID}] 尝试更新不存在或不属于当前窗口的任务状态: ${promptId}`)\n+      return false\n+    }\n \n-    // 清理所有定时器\n-    this.unlockTimers.forEach((timer, windowId) => {\n-      clearInterval(timer)\n-    })\n-    this.unlockTimers.clear()\n+    const oldStatus = task.status\n+    task.status = newStatus\n+    task.lastStatusUpdate = Date.now()\n \n-    // 断开所有连接\n-    const disconnectPromises = Array.from(this.connections.keys()).map(windowId =>\n-      this.disconnect(windowId)\n-    )\n+    // 合并额外数据\n+    Object.assign(task, additionalData)\n \n-    await Promise.all(disconnectPromises)\n+    console.log(`🔄 [${WINDOW_ID}] 任务状态变更: ${promptId} ${oldStatus} → ${newStatus}`)\n \n-    // 清理所有数据\n-    this.connections.clear()\n-    this.serverLocks.clear()\n-    this.messageHandlers.clear()\n+    // 🔧 广播任务状态变更\n+    this.broadcastTaskStatus(promptId, newStatus)\n \n-    console.log('✅ WebSocket管理器清理完成')\n+    return true\n   }\n+\n+  // 🔧 获取默认服务器URL的辅助方法\n+  _getDefaultServerUrl() {\n+    // 这里需要从配置中获取，暂时返回一个默认值\n+    // 在实际使用时会通过依赖注入或配置传入\n+    return 'http://localhost:8188'\n+  }\n }\n \n-// 🔧 创建全局WebSocket管理器实例\n-const websocketManager = new WebSocketManager()\n+// 创建全局实例\n+const webSocketManager = new WebSocketManager()\n \n-// 🔧 导出管理器实例和相关工具\n-export {\n-  websocketManager,\n-  WebSocketManager,\n-  generateClientId\n-}\n-\n-// 🔧 在窗口卸载时清理资源\n-if (typeof window !== 'undefined') {\n-  window.addEventListener('beforeunload', () => {\n-    websocketManager.cleanup()\n-  })\n-}\n+// 导出实例和相关常量\n+export default webSocketManager\n+export { WINDOW_ID, WINDOW_CLIENT_ID }\n"
                },
                {
                    "date": 1753506336423,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -314,51 +314,8 @@\n     console.warn(`⚠️ [${WINDOW_ID}] 任务 ${promptId} 未找到绑定服务器`)\n     return null\n   }\n \n-  // 🔧 窗口间通信机制（用于调试和监控）\n-  broadcastTaskStatus(promptId, status) {\n-    try {\n-      const message = {\n-        type: 'task_status',\n-        windowId: WINDOW_ID,\n-        clientId: WINDOW_CLIENT_ID,\n-        promptId: promptId,\n-        status: status,\n-        timestamp: Date.now()\n-      }\n-\n-      localStorage.setItem(`comfyui_task_${promptId}`, JSON.stringify(message))\n-      console.log(`📡 [${WINDOW_ID}] 广播任务状态: ${promptId} -> ${status}`)\n-    } catch (error) {\n-      console.warn(`⚠️ [${WINDOW_ID}] 广播任务状态失败:`, error)\n-    }\n-  }\n-\n-  // 🔧 原子性任务状态更新函数 - 窗口隔离版本\n-  updateTaskStatus(promptId, newStatus, additionalData = {}) {\n-    // 🔧 只处理属于当前窗口的任务\n-    const task = this.getWindowTask(promptId)\n-    if (!task) {\n-      console.warn(`⚠️ [${WINDOW_ID}] 尝试更新不存在或不属于当前窗口的任务状态: ${promptId}`)\n-      return false\n-    }\n-\n-    const oldStatus = task.status\n-    task.status = newStatus\n-    task.lastStatusUpdate = Date.now()\n-\n-    // 合并额外数据\n-    Object.assign(task, additionalData)\n-\n-    console.log(`🔄 [${WINDOW_ID}] 任务状态变更: ${promptId} ${oldStatus} → ${newStatus}`)\n-\n-    // 🔧 广播任务状态变更\n-    this.broadcastTaskStatus(promptId, newStatus)\n-\n-    return true\n-  }\n-\n   // 🔧 获取默认服务器URL的辅助方法\n   _getDefaultServerUrl() {\n     // 这里需要从配置中获取，暂时返回一个默认值\n     // 在实际使用时会通过依赖注入或配置传入\n"
                },
                {
                    "date": 1753506503049,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -320,8 +320,122 @@\n     // 这里需要从配置中获取，暂时返回一个默认值\n     // 在实际使用时会通过依赖注入或配置传入\n     return 'http://localhost:8188'\n   }\n+\n+  // 🔧 窗口间通信机制（用于调试和监控）\n+  broadcastTaskStatus(promptId, status) {\n+    try {\n+      const message = {\n+        type: 'task_status',\n+        windowId: WINDOW_ID,\n+        clientId: WINDOW_CLIENT_ID,\n+        promptId: promptId,\n+        status: status,\n+        timestamp: Date.now()\n+      }\n+\n+      localStorage.setItem(`comfyui_task_${promptId}`, JSON.stringify(message))\n+      console.log(`📡 [${WINDOW_ID}] 广播任务状态: ${promptId} -> ${status}`)\n+    } catch (error) {\n+      console.warn(`⚠️ [${WINDOW_ID}] 广播任务状态失败:`, error)\n+    }\n+  }\n+\n+  // 🔧 原子性任务状态更新函数 - 窗口隔离版本\n+  updateTaskStatus(promptId, newStatus, additionalData = {}) {\n+    // 🔧 只处理属于当前窗口的任务\n+    const task = this.getWindowTask(promptId)\n+    if (!task) {\n+      console.warn(`⚠️ [${WINDOW_ID}] 尝试更新不存在或不属于当前窗口的任务状态: ${promptId}`)\n+      return false\n+    }\n+\n+    const oldStatus = task.status\n+    task.status = newStatus\n+    task.lastStatusUpdate = Date.now()\n+\n+    // 合并额外数据\n+    Object.assign(task, additionalData)\n+\n+    console.log(`🔄 [${WINDOW_ID}] 任务状态变更: ${promptId} ${oldStatus} → ${newStatus}`)\n+\n+    // 🔧 广播任务状态变更\n+    this.broadcastTaskStatus(promptId, newStatus)\n+\n+    return true\n+  }\n+\n+  // 🔧 动态解锁检查机制\n+  // 🔧 调度服务器解锁检查（定期检查任务状态）\n+  scheduleServerUnlockCheck() {\n+    // 清理之前的定时器\n+    this.clearServerUnlockTimer()\n+\n+    // 设置定期检查（每30秒检查一次）\n+    this.serverUnlockTimer = setInterval(() => {\n+      this.checkServerUnlockCondition()\n+    }, 30000)\n+\n+    console.log(`⏰ [${WINDOW_ID}] 已调度动态解锁检查（每30秒检查一次）`)\n+  }\n+\n+  // 🔧 清理解锁检查定时器\n+  clearServerUnlockTimer() {\n+    if (this.serverUnlockTimer) {\n+      clearInterval(this.serverUnlockTimer)\n+      this.serverUnlockTimer = null\n+      console.log(`🧹 [${WINDOW_ID}] 已清理解锁检查定时器`)\n+    }\n+  }\n+\n+  // 🔧 检查是否可以解锁服务器的函数（增强版本）\n+  checkServerUnlockCondition() {\n+    const currentLock = this.getWindowServerLock()\n+    if (!currentLock) {\n+      // 服务器未锁定，清理定时器\n+      this.clearServerUnlockTimer()\n+      return false\n+    }\n+\n+    const taskCount = this.windowTasks.size\n+    const lockDuration = Date.now() - currentLock.timestamp\n+\n+    console.log(`🔍 [${WINDOW_ID}] 解锁条件检查:`)\n+    console.log(`   - 待处理任务数: ${taskCount}`)\n+    console.log(`   - 锁定持续时间: ${Math.round(lockDuration / 1000)}秒`)\n+    console.log(`   - 锁定服务器: ${currentLock.server}`)\n+\n+    if (taskCount === 0) {\n+      console.log(`🔓 [${WINDOW_ID}] 所有任务已完成，自动解锁服务器`)\n+      this.unlockServerForWindow()\n+      return true\n+    } else {\n+      console.log(`🔒 [${WINDOW_ID}] 仍有 ${taskCount} 个待处理任务，保持服务器锁定`)\n+\n+      // 列出待处理任务\n+      const taskIds = Array.from(this.windowTasks.keys())\n+      console.log(`📋 [${WINDOW_ID}] 待处理任务: [${taskIds.join(', ')}]`)\n+\n+      // 检查是否有长时间运行的任务\n+      const longRunningTasks = []\n+      this.windowTasks.forEach((task, promptId) => {\n+        const taskDuration = Date.now() - (task.registeredAt || currentLock.timestamp)\n+        if (taskDuration > 10 * 60 * 1000) { // 超过10分钟\n+          longRunningTasks.push({ promptId, duration: Math.round(taskDuration / 1000) })\n+        }\n+      })\n+\n+      if (longRunningTasks.length > 0) {\n+        console.log(`⚠️ [${WINDOW_ID}] 检测到长时间运行的任务:`)\n+        longRunningTasks.forEach(({ promptId, duration }) => {\n+          console.log(`   - ${promptId}: ${duration}秒`)\n+        })\n+      }\n+    }\n+\n+    return false\n+  }\n }\n \n // 创建全局实例\n const webSocketManager = new WebSocketManager()\n"
                },
                {
                    "date": 1753506710142,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -434,12 +434,205 @@\n     }\n \n     return false\n   }\n+\n+  // 🔧 新增：确保WebSocket连接与任务执行服务器一致性\n+  async ensureWebSocketServerConsistency(taskServer) {\n+    try {\n+      console.log(`🔍 [${WINDOW_ID}] 检查WebSocket服务器一致性...`)\n+      console.log(`🎯 [${WINDOW_ID}] 任务执行服务器: ${taskServer}`)\n+\n+      const currentLock = this.getWindowServerLock()\n+      const lockedServer = currentLock?.server\n+      const wsServer = this.currentWebSocketServer\n+\n+      console.log(`🔒 [${WINDOW_ID}] 当前锁定服务器: ${lockedServer}`)\n+      console.log(`🔗 [${WINDOW_ID}] WebSocket连接服务器: ${wsServer}`)\n+\n+      // 检查所有服务器是否一致\n+      const serversMatch = taskServer === lockedServer && taskServer === wsServer\n+\n+      if (serversMatch && this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) {\n+        console.log(`✅ [${WINDOW_ID}] 服务器一致性验证通过`)\n+        return true\n+      }\n+\n+      // 服务器不一致，需要重新建立连接\n+      console.log(`🔄 [${WINDOW_ID}] 服务器不一致，重新建立WebSocket连接`)\n+      console.log(`   任务服务器: ${taskServer}`)\n+      console.log(`   锁定服务器: ${lockedServer}`)\n+      console.log(`   WebSocket服务器: ${wsServer}`)\n+\n+      // 关闭现有连接\n+      if (this.wsConnection) {\n+        this.wsConnection.close(1000, '服务器不一致，重新连接')\n+        this.wsConnection = null\n+        this.isWsConnected = false\n+      }\n+\n+      // 重新初始化WebSocket连接到正确的服务器\n+      await this.initializeWebSocket(taskServer)\n+\n+      console.log(`✅ [${WINDOW_ID}] WebSocket重新连接到正确服务器: ${taskServer}`)\n+      return true\n+\n+    } catch (error) {\n+      console.error(`❌ [${WINDOW_ID}] WebSocket服务器一致性检查失败:`, error)\n+      throw error\n+    }\n+  }\n+\n+  // 🔧 新增：确保WebSocket连接 - 重构版本（支持任务-服务器绑定一致性）\n+  async ensureWebSocketConnection(taskServer = null) {\n+    console.log(`🔌 [${WINDOW_ID}] 确保WebSocket连接`)\n+\n+    if (taskServer) {\n+      console.log(`🎯 [${WINDOW_ID}] 指定任务服务器: ${taskServer}`)\n+\n+      // 🔧 关键修复：如果指定了任务服务器，确保WebSocket连接到正确服务器\n+      await this.ensureWebSocketServerConsistency(taskServer)\n+      return true\n+    }\n+\n+    // 如果已连接，检查服务器一致性\n+    if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN && this.isWsConnected) {\n+      console.log(`✅ [${WINDOW_ID}] WebSocket已连接`)\n+\n+      // 尝试锁定服务器，但失败不影响继续使用\n+      const currentLock = this.getWindowServerLock()\n+      if (!currentLock) {\n+        try {\n+          // 这里需要外部提供 getApiBaseUrl 函数\n+          console.log(`🔒 [${WINDOW_ID}] 需要补充锁定服务器，但缺少 getApiBaseUrl 函数`)\n+        } catch (error) {\n+          console.warn(`⚠️ [${WINDOW_ID}] 服务器锁定失败，但继续使用连接:`, error.message)\n+        }\n+      } else {\n+        console.log(`🔒 [${WINDOW_ID}] 服务器已锁定: ${currentLock.server}`)\n+\n+        // 🔧 验证WebSocket连接与锁定服务器的一致性\n+        const wsServer = this.currentWebSocketServer\n+        if (wsServer && wsServer !== currentLock.server) {\n+          console.log(`🔄 [${WINDOW_ID}] WebSocket服务器与锁定服务器不一致，重新连接`)\n+          console.log(`   WebSocket服务器: ${wsServer}`)\n+          console.log(`   锁定服务器: ${currentLock.server}`)\n+\n+          // 重新连接到锁定的服务器\n+          await this.initializeWebSocket(currentLock.server)\n+        }\n+      }\n+      return true\n+    }\n+\n+    // 需要建立新连接\n+    console.log(`🔄 [${WINDOW_ID}] 建立新的WebSocket连接`)\n+\n+    try {\n+      await this.initializeWebSocket()\n+\n+      // 给连接一些时间稳定\n+      await new Promise(resolve => setTimeout(resolve, 500))\n+\n+      if (!this.isWsConnected) {\n+        console.warn(`⚠️ [${WINDOW_ID}] WebSocket连接状态异常，但尝试继续`)\n+      }\n+\n+      console.log(`✅ [${WINDOW_ID}] WebSocket连接完成`)\n+      return true\n+\n+    } catch (error) {\n+      console.warn(`⚠️ [${WINDOW_ID}] WebSocket连接失败，但不阻止操作:`, error.message)\n+      // 🔧 关键改进：不抛出错误，允许降级使用\n+      return false\n+    }\n+  }\n+\n+  // 🔧 新增：手动重置WebSocket服务器锁定的功能\n+  resetWebSocketServer(force = false) {\n+    const currentLock = this.getWindowServerLock()\n+    console.log('🔄 手动重置WebSocket服务器锁定')\n+    console.log('🔓 清除服务器锁定:', currentLock?.server || '无')\n+\n+    if (!force && this.windowTasks.size > 0) {\n+      console.log(`⚠️ 有 ${this.windowTasks.size} 个待处理任务，建议等待完成后再重置`)\n+      console.log('💡 如需强制重置，请调用: resetWebSocketServer(true)')\n+      return false\n+    }\n+\n+    // 清除服务器锁定\n+    this.unlockServerForWindow()\n+\n+    // 关闭现有WebSocket连接\n+    if (this.wsConnection) {\n+      console.log('🔌 关闭现有WebSocket连接')\n+      this.wsConnection.close(1000, '手动重置服务器')\n+      this.wsConnection = null\n+      this.isWsConnected = false\n+    }\n+\n+    // 清理所有待处理任务（如果强制重置）\n+    if (force && this.windowTasks.size > 0) {\n+      console.log(`🧹 强制清理 ${this.windowTasks.size} 个待处理任务`)\n+      const taskIds = Array.from(this.windowTasks.keys())\n+      for (const promptId of taskIds) {\n+        const task = this.windowTasks.get(promptId)\n+        if (task && task.onError) {\n+          task.onError('WebSocket服务器已强制重置')\n+        }\n+        this.windowTasks.delete(promptId)\n+      }\n+    }\n+\n+    console.log('✅ WebSocket服务器重置完成')\n+    return true\n+  }\n+\n+  // 🔧 新增：获取当前WebSocket服务器状态的函数（窗口隔离版本）\n+  getWebSocketServerStatus() {\n+    return {\n+      windowId: WINDOW_ID,\n+      clientId: WINDOW_CLIENT_ID,\n+      isConnected: this.isWsConnected,\n+      lockedServer: this.getWindowServerLock()?.server,\n+      lockTimestamp: this.getWindowServerLock()?.timestamp,\n+      lockDuration: this.getWindowServerLock()?.timestamp ? Date.now() - this.getWindowServerLock().timestamp : null,\n+      pendingTasksCount: this.windowTasks.size,\n+      connectionState: this.wsConnection?.readyState || 'CLOSED'\n+    }\n+  }\n }\n \n+// 监听其他窗口的任务状态（用于调试）\n+if (typeof window !== 'undefined') {\n+  window.addEventListener('storage', (e) => {\n+    if (e.key && e.key.startsWith('comfyui_task_')) {\n+      try {\n+        const message = JSON.parse(e.newValue)\n+        if (message.windowId !== WINDOW_ID) {\n+          console.log(`📡 [${WINDOW_ID}] 收到其他窗口任务状态: ${message.promptId} -> ${message.status} (来自窗口: ${message.windowId})`)\n+        }\n+      } catch (error) {\n+        // 忽略解析错误\n+      }\n+    }\n+  })\n+}\n+\n // 创建全局实例\n const webSocketManager = new WebSocketManager()\n \n+// 🔧 暴露核心管理函数到全局，用于故障恢复\n+if (typeof window !== 'undefined') {\n+  window.resetWebSocketServer = webSocketManager.resetWebSocketServer.bind(webSocketManager)\n+  window.getWebSocketServerStatus = webSocketManager.getWebSocketServerStatus.bind(webSocketManager)\n+  window.pendingTasks = webSocketManager.windowTasks // 🔧 暴露窗口级别的任务队列\n+\n+  // 🔧 动态锁定管理函数\n+  window.forceUnlockServerForWindow = webSocketManager.forceUnlockServerForWindow.bind(webSocketManager)\n+\n+  console.log(`🔧 [${WINDOW_ID}] 核心管理函数已暴露到全局`)\n+}\n+\n // 导出实例和相关常量\n export default webSocketManager\n export { WINDOW_ID, WINDOW_CLIENT_ID }\n"
                },
                {
                    "date": 1753509561038,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,8 +62,174 @@\n     this._initializeWindowEvents()\n     this._initializeGlobalProperties()\n   }\n \n+  // ==================== WebSocket 连接管理方法 ====================\n+\n+  // 🔧 初始化 WebSocket 连接 - 重构版本（解决多服务器消息路由错乱）\n+  async initializeWebSocket(targetServer = null) {\n+    try {\n+      // 🔧 关键修复：支持指定目标服务器，确保任务-服务器绑定一致性\n+      let baseUrl\n+      const currentLock = this.getWindowServerLock()\n+\n+      if (targetServer) {\n+        // 如果指定了目标服务器，直接使用\n+        baseUrl = targetServer\n+        console.log(`🎯 [${WINDOW_ID}] 使用指定的目标服务器: ${baseUrl}`)\n+      } else if (currentLock && currentLock.server) {\n+        // 如果当前窗口已锁定服务器，使用锁定的服务器\n+        baseUrl = currentLock.server\n+        console.log(`🔒 [${WINDOW_ID}] 使用窗口锁定的服务器: ${baseUrl}`)\n+      } else {\n+        // 否则从负载均衡器获取可用服务器\n+        try {\n+          baseUrl = await loadBalancer.getAvailableServer()\n+          if (!baseUrl) {\n+            throw new Error('负载均衡器返回空服务器')\n+          }\n+          console.log(`⚖️ [${WINDOW_ID}] 从负载均衡器获取服务器: ${baseUrl}`)\n+        } catch (lbError) {\n+          console.error('❌ 负载均衡器错误:', lbError.message)\n+          throw new Error(`无法获取可用的ComfyUI服务器: ${lbError.message}`)\n+        }\n+      }\n+\n+      // 🔧 检查现有连接是否与目标服务器一致\n+      if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) {\n+        const currentWsServer = this.currentWebSocketServer || this.getWindowServerLock()?.server\n+        if (currentWsServer === baseUrl) {\n+          console.log(`✅ [${WINDOW_ID}] WebSocket已连接到正确服务器: ${baseUrl}`)\n+          return true\n+        } else {\n+          console.log(`🔄 [${WINDOW_ID}] WebSocket服务器不匹配，需要重连`)\n+          console.log(`   当前连接: ${currentWsServer}`)\n+          console.log(`   目标服务器: ${baseUrl}`)\n+          // 关闭现有连接，建立新连接\n+          this.wsConnection.close(1000, '切换到正确的服务器')\n+          this.wsConnection = null\n+          this.isWsConnected = false\n+        }\n+      }\n+\n+      console.log(`🔌 [${WINDOW_ID}] 连接WebSocket: ${baseUrl}`)\n+\n+      // 🔧 构建WebSocket URL - 使用增强的唯一clientId\n+      let wsUrl\n+      if (baseUrl.startsWith('https://')) {\n+        wsUrl = baseUrl.replace('https://', 'wss://') + '/ws?clientId=' + WINDOW_CLIENT_ID\n+      } else {\n+        wsUrl = baseUrl.replace('http://', 'ws://') + '/ws?clientId=' + WINDOW_CLIENT_ID\n+      }\n+\n+      console.log(`🔗 [${WINDOW_ID}] WebSocket URL: ${wsUrl}`)\n+      console.log(`🔑 [${WINDOW_ID}] 使用增强clientId: ${WINDOW_CLIENT_ID}`)\n+\n+      // 简单的HTTP连接测试\n+      try {\n+        const testResponse = await fetch(`${baseUrl}/api/queue`, {\n+          method: 'GET',\n+          signal: AbortSignal.timeout(5000)\n+        })\n+        if (!testResponse.ok) {\n+          throw new Error(`服务器响应错误: ${testResponse.status}`)\n+        }\n+      } catch (httpError) {\n+        throw new Error(`ComfyUI服务器不可达: ${httpError.message}`)\n+      }\n+\n+      // 🔧 记录即将连接的服务器，用于后续验证\n+      this.currentWebSocketServer = baseUrl\n+      this.wsConnection = new WebSocket(wsUrl)\n+\n+      return new Promise((resolve, reject) => {\n+        const timeout = setTimeout(() => {\n+          reject(new Error('WebSocket 连接超时'))\n+        }, 10000)\n+\n+        this.wsConnection.onopen = () => {\n+          this.isWsConnected = true\n+          clearTimeout(timeout)\n+          this._showNotification(`[${WINDOW_ID}] WebSocket连接成功`, 'success')\n+          this._logServerConsistency('WebSocket连接成功')\n+          resolve(true)\n+        }\n+\n+        this.wsConnection.onerror = (error) => {\n+          this.isWsConnected = false\n+          clearTimeout(timeout)\n+          console.error('❌ WebSocket连接错误:', error)\n+          reject(new Error('WebSocket连接失败'))\n+        }\n+\n+        this.wsConnection.onclose = (event) => {\n+          this.isWsConnected = false\n+          console.log(`🔌 [${WINDOW_ID}] WebSocket连接关闭: ${event.code} - ${event.reason}`)\n+\n+          // 🔧 如果不是正常关闭，尝试重连\n+          if (event.code !== 1000 && event.code !== 1001) {\n+            console.log(`🔄 [${WINDOW_ID}] 非正常关闭，准备重连...`)\n+            setTimeout(() => {\n+              if (!this.isWsConnected) {\n+                console.log(`🔄 [${WINDOW_ID}] 执行WebSocket重连`)\n+                this.initializeWebSocket(baseUrl).catch(error => {\n+                  console.error('❌ WebSocket重连失败:', error)\n+                })\n+              }\n+            }, 3000)\n+          }\n+        }\n+\n+        this.wsConnection.onmessage = (event) => {\n+          try {\n+            const message = event.data\n+\n+            // 🔧 增强消息过滤：只处理当前窗口的消息\n+            if (typeof message === 'object' && message.windowId && message.windowId !== WINDOW_ID) {\n+              console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的消息: ${message.windowId}`)\n+              return\n+            }\n+\n+            // 官方标准：只处理字符串消息\n+            if (typeof message === 'string') {\n+              try {\n+                const parsedMessage = JSON.parse(message)\n+\n+                // 调用重构后的消息处理函数\n+                this.handleWebSocketMessage(parsedMessage)\n+              } catch (parseError) {\n+                console.error('❌ [OFFICIAL] JSON解析失败:', parseError.message)\n+              }\n+            }\n+\n+          } catch (error) {\n+            console.error('❌ [OFFICIAL] WebSocket消息处理失败:', error)\n+          }\n+        }\n+      })\n+    } catch (error) {\n+      console.error('❌ 初始化 WebSocket 失败:', error)\n+\n+      // 🔧 根据错误类型决定是否清除服务器锁定\n+      if (error.message.includes('负载均衡器') || error.message.includes('无法获取可用的ComfyUI服务器')) {\n+        // 如果是负载均衡器错误，清除服务器锁定\n+        this.currentWebSocketServer = null\n+        this.clearWindowServerLock()\n+        console.log('🔓 负载均衡器错误，清除服务器锁定')\n+      } else if (error.message.includes('ComfyUI服务器不可达') || error.message.includes('WebSocket 连接超时')) {\n+        // 如果是连接错误但服务器可能恢复，保持锁定以便重试\n+        console.log('🔒 连接错误但保持服务器锁定以便重试')\n+      } else {\n+        // 其他未知错误，清除锁定\n+        this.currentWebSocketServer = null\n+        this.clearWindowServerLock()\n+        console.log('🔓 未知错误，清除服务器锁定')\n+      }\n+\n+      throw error\n+    }\n+  }\n+\n   // 🔧 窗口关闭时的清理机制\n   _initializeWindowEvents() {\n     window.addEventListener('beforeunload', () => {\n       console.log(`🚪 [${WINDOW_ID}] 窗口即将关闭，执行清理...`)\n"
                },
                {
                    "date": 1753509611155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,174 +62,8 @@\n     this._initializeWindowEvents()\n     this._initializeGlobalProperties()\n   }\n \n-  // ==================== WebSocket 连接管理方法 ====================\n-\n-  // 🔧 初始化 WebSocket 连接 - 重构版本（解决多服务器消息路由错乱）\n-  async initializeWebSocket(targetServer = null) {\n-    try {\n-      // 🔧 关键修复：支持指定目标服务器，确保任务-服务器绑定一致性\n-      let baseUrl\n-      const currentLock = this.getWindowServerLock()\n-\n-      if (targetServer) {\n-        // 如果指定了目标服务器，直接使用\n-        baseUrl = targetServer\n-        console.log(`🎯 [${WINDOW_ID}] 使用指定的目标服务器: ${baseUrl}`)\n-      } else if (currentLock && currentLock.server) {\n-        // 如果当前窗口已锁定服务器，使用锁定的服务器\n-        baseUrl = currentLock.server\n-        console.log(`🔒 [${WINDOW_ID}] 使用窗口锁定的服务器: ${baseUrl}`)\n-      } else {\n-        // 否则从负载均衡器获取可用服务器\n-        try {\n-          baseUrl = await loadBalancer.getAvailableServer()\n-          if (!baseUrl) {\n-            throw new Error('负载均衡器返回空服务器')\n-          }\n-          console.log(`⚖️ [${WINDOW_ID}] 从负载均衡器获取服务器: ${baseUrl}`)\n-        } catch (lbError) {\n-          console.error('❌ 负载均衡器错误:', lbError.message)\n-          throw new Error(`无法获取可用的ComfyUI服务器: ${lbError.message}`)\n-        }\n-      }\n-\n-      // 🔧 检查现有连接是否与目标服务器一致\n-      if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) {\n-        const currentWsServer = this.currentWebSocketServer || this.getWindowServerLock()?.server\n-        if (currentWsServer === baseUrl) {\n-          console.log(`✅ [${WINDOW_ID}] WebSocket已连接到正确服务器: ${baseUrl}`)\n-          return true\n-        } else {\n-          console.log(`🔄 [${WINDOW_ID}] WebSocket服务器不匹配，需要重连`)\n-          console.log(`   当前连接: ${currentWsServer}`)\n-          console.log(`   目标服务器: ${baseUrl}`)\n-          // 关闭现有连接，建立新连接\n-          this.wsConnection.close(1000, '切换到正确的服务器')\n-          this.wsConnection = null\n-          this.isWsConnected = false\n-        }\n-      }\n-\n-      console.log(`🔌 [${WINDOW_ID}] 连接WebSocket: ${baseUrl}`)\n-\n-      // 🔧 构建WebSocket URL - 使用增强的唯一clientId\n-      let wsUrl\n-      if (baseUrl.startsWith('https://')) {\n-        wsUrl = baseUrl.replace('https://', 'wss://') + '/ws?clientId=' + WINDOW_CLIENT_ID\n-      } else {\n-        wsUrl = baseUrl.replace('http://', 'ws://') + '/ws?clientId=' + WINDOW_CLIENT_ID\n-      }\n-\n-      console.log(`🔗 [${WINDOW_ID}] WebSocket URL: ${wsUrl}`)\n-      console.log(`🔑 [${WINDOW_ID}] 使用增强clientId: ${WINDOW_CLIENT_ID}`)\n-\n-      // 简单的HTTP连接测试\n-      try {\n-        const testResponse = await fetch(`${baseUrl}/api/queue`, {\n-          method: 'GET',\n-          signal: AbortSignal.timeout(5000)\n-        })\n-        if (!testResponse.ok) {\n-          throw new Error(`服务器响应错误: ${testResponse.status}`)\n-        }\n-      } catch (httpError) {\n-        throw new Error(`ComfyUI服务器不可达: ${httpError.message}`)\n-      }\n-\n-      // 🔧 记录即将连接的服务器，用于后续验证\n-      this.currentWebSocketServer = baseUrl\n-      this.wsConnection = new WebSocket(wsUrl)\n-\n-      return new Promise((resolve, reject) => {\n-        const timeout = setTimeout(() => {\n-          reject(new Error('WebSocket 连接超时'))\n-        }, 10000)\n-\n-        this.wsConnection.onopen = () => {\n-          this.isWsConnected = true\n-          clearTimeout(timeout)\n-          this._showNotification(`[${WINDOW_ID}] WebSocket连接成功`, 'success')\n-          this._logServerConsistency('WebSocket连接成功')\n-          resolve(true)\n-        }\n-\n-        this.wsConnection.onerror = (error) => {\n-          this.isWsConnected = false\n-          clearTimeout(timeout)\n-          console.error('❌ WebSocket连接错误:', error)\n-          reject(new Error('WebSocket连接失败'))\n-        }\n-\n-        this.wsConnection.onclose = (event) => {\n-          this.isWsConnected = false\n-          console.log(`🔌 [${WINDOW_ID}] WebSocket连接关闭: ${event.code} - ${event.reason}`)\n-\n-          // 🔧 如果不是正常关闭，尝试重连\n-          if (event.code !== 1000 && event.code !== 1001) {\n-            console.log(`🔄 [${WINDOW_ID}] 非正常关闭，准备重连...`)\n-            setTimeout(() => {\n-              if (!this.isWsConnected) {\n-                console.log(`🔄 [${WINDOW_ID}] 执行WebSocket重连`)\n-                this.initializeWebSocket(baseUrl).catch(error => {\n-                  console.error('❌ WebSocket重连失败:', error)\n-                })\n-              }\n-            }, 3000)\n-          }\n-        }\n-\n-        this.wsConnection.onmessage = (event) => {\n-          try {\n-            const message = event.data\n-\n-            // 🔧 增强消息过滤：只处理当前窗口的消息\n-            if (typeof message === 'object' && message.windowId && message.windowId !== WINDOW_ID) {\n-              console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的消息: ${message.windowId}`)\n-              return\n-            }\n-\n-            // 官方标准：只处理字符串消息\n-            if (typeof message === 'string') {\n-              try {\n-                const parsedMessage = JSON.parse(message)\n-\n-                // 调用重构后的消息处理函数\n-                this.handleWebSocketMessage(parsedMessage)\n-              } catch (parseError) {\n-                console.error('❌ [OFFICIAL] JSON解析失败:', parseError.message)\n-              }\n-            }\n-\n-          } catch (error) {\n-            console.error('❌ [OFFICIAL] WebSocket消息处理失败:', error)\n-          }\n-        }\n-      })\n-    } catch (error) {\n-      console.error('❌ 初始化 WebSocket 失败:', error)\n-\n-      // 🔧 根据错误类型决定是否清除服务器锁定\n-      if (error.message.includes('负载均衡器') || error.message.includes('无法获取可用的ComfyUI服务器')) {\n-        // 如果是负载均衡器错误，清除服务器锁定\n-        this.currentWebSocketServer = null\n-        this.clearWindowServerLock()\n-        console.log('🔓 负载均衡器错误，清除服务器锁定')\n-      } else if (error.message.includes('ComfyUI服务器不可达') || error.message.includes('WebSocket 连接超时')) {\n-        // 如果是连接错误但服务器可能恢复，保持锁定以便重试\n-        console.log('🔒 连接错误但保持服务器锁定以便重试')\n-      } else {\n-        // 其他未知错误，清除锁定\n-        this.currentWebSocketServer = null\n-        this.clearWindowServerLock()\n-        console.log('🔓 未知错误，清除服务器锁定')\n-      }\n-\n-      throw error\n-    }\n-  }\n-\n   // 🔧 窗口关闭时的清理机制\n   _initializeWindowEvents() {\n     window.addEventListener('beforeunload', () => {\n       console.log(`🚪 [${WINDOW_ID}] 窗口即将关闭，执行清理...`)\n@@ -765,10 +599,194 @@\n       pendingTasksCount: this.windowTasks.size,\n       connectionState: this.wsConnection?.readyState || 'CLOSED'\n     }\n   }\n-}\n \n+  // ==================== WebSocket 消息处理方法 ====================\n+\n+  // 🔥 防抖机制：避免频繁的进度回调触发递归更新\n+  safeProgressCallback(promptId, task, message, percent) {\n+    if (!task.onProgress) return\n+\n+    // 防抖：同一任务的进度回调间隔至少100ms\n+    const lastCallTime = this.progressCallbackDebounce.get(promptId) || 0\n+    const now = Date.now()\n+\n+    if (now - lastCallTime < 100) {\n+      console.log(`🚫 [${WINDOW_ID}] 进度回调防抖: ${promptId} (${percent}%)`)\n+      return\n+    }\n+\n+    this.progressCallbackDebounce.set(promptId, now)\n+\n+    try {\n+      // 🔧 使用setTimeout(0)确保回调在下一个事件循环中执行（浏览器兼容）\n+      setTimeout(() => {\n+        task.onProgress(message, percent)\n+      }, 0)\n+    } catch (error) {\n+      console.error(`❌ [${WINDOW_ID}] 进度回调执行失败: ${promptId}`, error.message)\n+    }\n+  }\n+\n+  // 🔥 主要的WebSocket消息处理函数 - 重构版本（窗口隔离版本）\n+  handleWebSocketMessage(message) {\n+    try {\n+      const { type, data } = message\n+\n+      // 🔥 简化消息过滤：如果找到任务就处理，不严格限制窗口归属\n+      if (data && data.prompt_id) {\n+        const task = this.getWindowTask(data.prompt_id)\n+        if (!task) {\n+          // 任务不存在，可能是其他窗口的消息，静默忽略\n+          return\n+        }\n+\n+        // 🔥 验证消息来源服务器一致性\n+        const currentLock = this.getWindowServerLock()\n+        if (currentLock && task.executionServer && task.executionServer !== currentLock.server) {\n+          console.warn(`⚠️ [${WINDOW_ID}] 跨服务器消息检测: 任务在 ${task.executionServer}, 当前锁定 ${currentLock.server}`)\n+          // 仍然处理消息，但记录警告以便调试\n+        }\n+\n+        // 🔥 记录消息处理日志（用于跨服务器调试）\n+        console.log(`📨 [${WINDOW_ID}] 处理消息: ${type} (prompt_id: ${data.prompt_id}, 服务器: ${task.executionServer || '未知'})`)\n+      }\n+\n+      // 🔥 记录所有消息类型用于调试\n+      if (type !== 'status') {\n+        console.log(`📨 [OFFICIAL] 收到消息: ${type}`, data)\n+      }\n+\n+      // 根据官方WebSocket API文档处理所有标准消息类型\n+      switch (type) {\n+        case 'status':\n+          // 服务器状态和队列信息\n+          this.handleStatusMessage(data)\n+          break\n+\n+        case 'execution_start':\n+          // 任务开始执行 - 官方标准状态检测\n+          this.handleExecutionStartMessage(data)\n+          break\n+\n+        case 'executing':\n+          // 节点执行状态 - 官方标准完成检测\n+          this.handleExecutingMessage(data)\n+          break\n+\n+        case 'progress':\n+          // 节点执行进度\n+          this.handleProgressMessage(data)\n+          break\n+\n+        case 'executed':\n+          // 节点执行完成\n+          this.handleExecutedMessage(data)\n+          break\n+\n+        case 'execution_cached':\n+          // 节点缓存命中\n+          this.handleExecutionCachedMessage(data)\n+          break\n+\n+        case 'execution_error':\n+          // 执行错误\n+          this.handleExecutionErrorMessage(data)\n+          break\n+\n+        case 'execution_interrupted':\n+          // 执行中断\n+          this.handleExecutionInterruptedMessage(data)\n+          break\n+\n+        default:\n+          // 记录未知消息类型用于调试\n+          console.log(`🔍 [OFFICIAL] 未知消息类型: ${type}`, data)\n+      }\n+\n+    } catch (error) {\n+      console.error('❌ [OFFICIAL] 消息处理失败:', error.message, message)\n+    }\n+  }\n+\n+  // 🔥 处理服务器状态消息 - 重构版本（窗口隔离版本）\n+  handleStatusMessage(data) {\n+    if (!data || !data.status) {\n+      return\n+    }\n+\n+    // 🔧 只记录队列变化，不处理具体任务（避免跨窗口干扰）\n+    const queueRunning = data.status.exec_info?.queue_remaining || 0\n+    if (queueRunning > 0) {\n+      console.log(`📊 [${WINDOW_ID}] 服务器队列状态: ${queueRunning} 个任务等待执行`)\n+    }\n+\n+    // 🔧 触发状态更新事件供Vue组件监听\n+    if (typeof window !== 'undefined') {\n+      window.dispatchEvent(new CustomEvent('comfyui-queue-status', {\n+        detail: {\n+          queueRemaining: queueRunning,\n+          windowId: WINDOW_ID,\n+          timestamp: Date.now()\n+        }\n+      }))\n+    }\n+  }\n+\n+  // 🔥 处理任务开始执行消息 - 重构版本（窗口隔离版本）\n+  handleExecutionStartMessage(data) {\n+    if (!data || !data.prompt_id) {\n+      return\n+    }\n+\n+    const promptId = data.prompt_id\n+\n+    // 🔧 只处理属于当前窗口的任务\n+    const task = this.getWindowTask(promptId)\n+    if (!task) {\n+      console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的执行开始消息: ${promptId}`)\n+      return\n+    }\n+\n+    console.log(`🚀 [${WINDOW_ID}] 任务开始执行: ${promptId}`)\n+\n+    // 原子性状态更新：waiting → executing\n+    this.updateTaskStatus(promptId, this.TASK_STATUS.EXECUTING, {\n+      executionStartTime: Date.now()\n+    })\n+\n+    // 🔧 使用安全进度回调\n+    this.safeProgressCallback(promptId, task, '任务开始执行', 10)\n+  }\n+\n+  // 🔥 处理节点执行进度消息 - 重构版本（窗口隔离版本）\n+  handleProgressMessage(data) {\n+    if (!data || !data.prompt_id || typeof data.value !== 'number' || typeof data.max !== 'number') {\n+      return\n+    }\n+\n+    const promptId = data.prompt_id\n+\n+    // 🔧 只处理属于当前窗口的任务\n+    const task = this.getWindowTask(promptId)\n+    if (!task || task.status !== this.TASK_STATUS.EXECUTING) {\n+      if (!task) {\n+        console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的进度消息: ${promptId}`)\n+      }\n+      return\n+    }\n+\n+    // 计算进度百分比\n+    const percent = Math.round((data.value / data.max) * 100)\n+    const nodeInfo = data.node ? ` (节点: ${data.node})` : ''\n+\n+    console.log(`📈 [${WINDOW_ID}] 任务进度: ${promptId} - ${percent}%${nodeInfo}`)\n+\n+    // 🔧 使用安全进度回调\n+    this.safeProgressCallback(promptId, task, `执行进度: ${percent}%${nodeInfo}`, Math.min(percent + 10, 90))\n+  }\n+\n // 监听其他窗口的任务状态（用于调试）\n if (typeof window !== 'undefined') {\n   window.addEventListener('storage', (e) => {\n     if (e.key && e.key.startsWith('comfyui_task_')) {\n"
                },
                {
                    "date": 1753509731590,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -785,8 +785,235 @@\n     // 🔧 使用安全进度回调\n     this.safeProgressCallback(promptId, task, `执行进度: ${percent}%${nodeInfo}`, Math.min(percent + 10, 90))\n   }\n \n+  // 🔥 处理节点执行完成消息 - 重构版本（窗口隔离版本）\n+  handleExecutedMessage(data) {\n+    if (!data || !data.prompt_id || !data.node) {\n+      return\n+    }\n+\n+    const promptId = data.prompt_id\n+\n+    // 🔧 只处理属于当前窗口的任务\n+    const task = this.getWindowTask(promptId)\n+    if (!task || task.status !== this.TASK_STATUS.EXECUTING) {\n+      if (!task) {\n+        console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的节点完成消息: ${promptId}`)\n+      }\n+      return\n+    }\n+\n+    console.log(`✅ [${WINDOW_ID}] 节点完成: ${data.node} (任务: ${promptId})`)\n+\n+    // 记录完成的节点\n+    if (!task.completedNodes) {\n+      task.completedNodes = []\n+    }\n+    task.completedNodes.push(data.node)\n+\n+    // 🔧 使用安全进度回调\n+    this.safeProgressCallback(promptId, task, `节点 ${data.node} 完成`, 60)\n+  }\n+\n+  // 🔥 处理节点执行状态消息 - 官方标准完成检测（窗口隔离版本）\n+  handleExecutingMessage(data) {\n+    if (!data || !data.prompt_id) {\n+      return\n+    }\n+\n+    const promptId = data.prompt_id\n+\n+    // 🔧 只处理属于当前窗口的任务\n+    const task = this.getWindowTask(promptId)\n+    if (!task) {\n+      console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的执行状态消息: ${promptId}`)\n+      return\n+    }\n+\n+    // 官方标准双重条件检测：data.node === null && data.prompt_id === promptId\n+    if (data.node === null && data.prompt_id === promptId) {\n+      console.log(`🎯 [${WINDOW_ID}] 任务执行完成: ${promptId}`)\n+\n+      // 原子性状态更新：executing → completed\n+      this.updateTaskStatus(promptId, this.TASK_STATUS.COMPLETED, {\n+        completionTime: Date.now()\n+      })\n+\n+      // 立即处理任务完成\n+      this.handleTaskCompletion(promptId)\n+    } else if (data.node) {\n+      // 记录正在执行的节点\n+      console.log(`🔄 [${WINDOW_ID}] 正在执行节点: ${data.node} (任务: ${promptId})`)\n+\n+      // 更新任务的当前执行节点\n+      if (task) {\n+        task.currentNode = data.node\n+        this.safeProgressCallback(promptId, task, `正在执行节点: ${data.node}`, 30)\n+      }\n+    }\n+  }\n+\n+  // 🔥 处理任务完成的核心函数 - 重构版本（窗口隔离版本）\n+  handleTaskCompletion(promptId) {\n+    try {\n+      const task = this.getWindowTask(promptId)\n+      if (!task) {\n+        console.warn(`⚠️ [${WINDOW_ID}] 任务完成处理失败: 任务不存在 ${promptId}`)\n+        return\n+      }\n+\n+      console.log(`🎉 [${WINDOW_ID}] 任务完成处理开始: ${promptId}`)\n+\n+      // 🔧 使用安全进度回调\n+      this.safeProgressCallback(promptId, task, '任务执行完成', 100)\n+\n+      // 立即清理任务\n+      this.removeWindowTask(promptId)\n+\n+      // 🔧 检查是否可以解锁服务器\n+      this.checkServerUnlockCondition()\n+\n+      // 调用成功回调\n+      if (task.onSuccess) {\n+        // 🔧 使用setTimeout(0)确保成功回调立即执行（浏览器兼容）\n+        setTimeout(() => {\n+          task.onSuccess(promptId)\n+        }, 0)\n+      }\n+\n+      console.log(`✅ [${WINDOW_ID}] 任务完成处理结束: ${promptId}`)\n+\n+    } catch (error) {\n+      console.error(`❌ [${WINDOW_ID}] 任务完成处理失败: ${promptId}`, error.message)\n+\n+      // 立即清理任务并调用错误回调\n+      this.removeWindowTask(promptId)\n+\n+      // 🔧 检查是否可以解锁服务器\n+      this.checkServerUnlockCondition()\n+\n+      if (task.onError) {\n+        // 🔧 使用setTimeout(0)确保错误回调立即执行（浏览器兼容）\n+        setTimeout(() => {\n+          task.onError(error.message)\n+        }, 0)\n+      }\n+    }\n+  }\n+\n+  // 🔥 处理节点缓存命中消息\n+  handleExecutionCachedMessage(data) {\n+    if (!data || !data.prompt_id) {\n+      return\n+    }\n+\n+    const promptId = data.prompt_id\n+    const task = this.getWindowTask(promptId)\n+    if (!task) {\n+      console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的缓存消息: ${promptId}`)\n+      return\n+    }\n+\n+    console.log(`💾 [${WINDOW_ID}] 节点缓存命中: ${promptId}`)\n+    this.safeProgressCallback(promptId, task, '使用缓存结果', 80)\n+  }\n+\n+  // 🔥 处理执行错误消息\n+  handleExecutionErrorMessage(data) {\n+    if (!data || !data.prompt_id) {\n+      return\n+    }\n+\n+    const promptId = data.prompt_id\n+    const task = this.getWindowTask(promptId)\n+    if (!task) {\n+      console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的错误消息: ${promptId}`)\n+      return\n+    }\n+\n+    console.error(`❌ [${WINDOW_ID}] 任务执行错误: ${promptId}`, data)\n+\n+    // 更新任务状态为错误\n+    this.updateTaskStatus(promptId, this.TASK_STATUS.ERROR, {\n+      errorTime: Date.now(),\n+      errorData: data\n+    })\n+\n+    // 清理任务并调用错误回调\n+    this.removeWindowTask(promptId)\n+    this.checkServerUnlockCondition()\n+\n+    if (task.onError) {\n+      setTimeout(() => {\n+        task.onError(data.exception_message || '任务执行错误')\n+      }, 0)\n+    }\n+  }\n+\n+  // 🔥 处理执行中断消息\n+  handleExecutionInterruptedMessage(data) {\n+    if (!data || !data.prompt_id) {\n+      return\n+    }\n+\n+    const promptId = data.prompt_id\n+    const task = this.getWindowTask(promptId)\n+    if (!task) {\n+      console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的中断消息: ${promptId}`)\n+      return\n+    }\n+\n+    console.warn(`⚠️ [${WINDOW_ID}] 任务执行中断: ${promptId}`)\n+\n+    // 更新任务状态为中断\n+    this.updateTaskStatus(promptId, this.TASK_STATUS.INTERRUPTED, {\n+      interruptTime: Date.now()\n+    })\n+\n+    // 清理任务并调用错误回调\n+    this.removeWindowTask(promptId)\n+    this.checkServerUnlockCondition()\n+\n+    if (task.onError) {\n+      setTimeout(() => {\n+        task.onError('任务执行被中断')\n+      }, 0)\n+    }\n+  }\n+\n+  // 🔧 辅助方法：显示通知\n+  _showNotification(message, type = 'info') {\n+    const timestamp = new Date().toLocaleTimeString()\n+    const typeEmoji = {\n+      'success': '✅',\n+      'error': '❌',\n+      'warning': '⚠️',\n+      'info': 'ℹ️'\n+    }\n+\n+    console.log(`${typeEmoji[type] || 'ℹ️'} [${timestamp}] ${message}`)\n+\n+    // 触发自定义事件供Vue组件监听\n+    if (typeof window !== 'undefined') {\n+      window.dispatchEvent(new CustomEvent('comfyui-status', {\n+        detail: { message, type, timestamp }\n+      }))\n+    }\n+  }\n+\n+  // 🔧 辅助方法：记录服务器一致性信息\n+  _logServerConsistency(context) {\n+    const currentLock = this.getWindowServerLock()\n+    const wsServer = this.currentWebSocketServer\n+\n+    console.log(`🔍 [${WINDOW_ID}] 服务器一致性检查 (${context}):`)\n+    console.log(`   - 锁定服务器: ${currentLock?.server || '无'}`)\n+    console.log(`   - WebSocket服务器: ${wsServer || '无'}`)\n+    console.log(`   - 连接状态: ${this.isWsConnected ? '已连接' : '未连接'}`)\n+  }\n+}\n+\n // 监听其他窗口的任务状态（用于调试）\n if (typeof window !== 'undefined') {\n   window.addEventListener('storage', (e) => {\n     if (e.key && e.key.startsWith('comfyui_task_')) {\n"
                },
                {
                    "date": 1753509858709,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -152,8 +152,174 @@\n     // 🔧 为了向后兼容，保留 pendingTasks 引用但指向窗口任务队列\n     window.pendingTasks = this.windowTasks\n   }\n \n+  // ==================== WebSocket 连接管理方法 ====================\n+\n+  // 🔧 初始化 WebSocket 连接 - 重构版本（解决多服务器消息路由错乱）\n+  async initializeWebSocket(targetServer = null) {\n+    try {\n+      // 🔧 关键修复：支持指定目标服务器，确保任务-服务器绑定一致性\n+      let baseUrl\n+      const currentLock = this.getWindowServerLock()\n+\n+      if (targetServer) {\n+        // 如果指定了目标服务器，直接使用\n+        baseUrl = targetServer\n+        console.log(`🎯 [${WINDOW_ID}] 使用指定的目标服务器: ${baseUrl}`)\n+      } else if (currentLock && currentLock.server) {\n+        // 如果当前窗口已锁定服务器，使用锁定的服务器\n+        baseUrl = currentLock.server\n+        console.log(`🔒 [${WINDOW_ID}] 使用窗口锁定的服务器: ${baseUrl}`)\n+      } else {\n+        // 否则从负载均衡器获取可用服务器\n+        try {\n+          baseUrl = await loadBalancer.getAvailableServer()\n+          if (!baseUrl) {\n+            throw new Error('负载均衡器返回空服务器')\n+          }\n+          console.log(`⚖️ [${WINDOW_ID}] 从负载均衡器获取服务器: ${baseUrl}`)\n+        } catch (lbError) {\n+          console.error('❌ 负载均衡器错误:', lbError.message)\n+          throw new Error(`无法获取可用的ComfyUI服务器: ${lbError.message}`)\n+        }\n+      }\n+\n+      // 🔧 检查现有连接是否与目标服务器一致\n+      if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) {\n+        const currentWsServer = this.currentWebSocketServer || this.getWindowServerLock()?.server\n+        if (currentWsServer === baseUrl) {\n+          console.log(`✅ [${WINDOW_ID}] WebSocket已连接到正确服务器: ${baseUrl}`)\n+          return true\n+        } else {\n+          console.log(`🔄 [${WINDOW_ID}] WebSocket服务器不匹配，需要重连`)\n+          console.log(`   当前连接: ${currentWsServer}`)\n+          console.log(`   目标服务器: ${baseUrl}`)\n+          // 关闭现有连接，建立新连接\n+          this.wsConnection.close(1000, '切换到正确的服务器')\n+          this.wsConnection = null\n+          this.isWsConnected = false\n+        }\n+      }\n+\n+      console.log(`🔌 [${WINDOW_ID}] 连接WebSocket: ${baseUrl}`)\n+\n+      // 🔧 构建WebSocket URL - 使用增强的唯一clientId\n+      let wsUrl\n+      if (baseUrl.startsWith('https://')) {\n+        wsUrl = baseUrl.replace('https://', 'wss://') + '/ws?clientId=' + WINDOW_CLIENT_ID\n+      } else {\n+        wsUrl = baseUrl.replace('http://', 'ws://') + '/ws?clientId=' + WINDOW_CLIENT_ID\n+      }\n+\n+      console.log(`🔗 [${WINDOW_ID}] WebSocket URL: ${wsUrl}`)\n+      console.log(`🔑 [${WINDOW_ID}] 使用增强clientId: ${WINDOW_CLIENT_ID}`)\n+\n+      // 简单的HTTP连接测试\n+      try {\n+        const testResponse = await fetch(`${baseUrl}/api/queue`, {\n+          method: 'GET',\n+          signal: AbortSignal.timeout(5000)\n+        })\n+        if (!testResponse.ok) {\n+          throw new Error(`服务器响应错误: ${testResponse.status}`)\n+        }\n+      } catch (httpError) {\n+        throw new Error(`ComfyUI服务器不可达: ${httpError.message}`)\n+      }\n+\n+      // 🔧 记录即将连接的服务器，用于后续验证\n+      this.currentWebSocketServer = baseUrl\n+      this.wsConnection = new WebSocket(wsUrl)\n+\n+      return new Promise((resolve, reject) => {\n+        const timeout = setTimeout(() => {\n+          reject(new Error('WebSocket 连接超时'))\n+        }, 10000)\n+\n+        this.wsConnection.onopen = () => {\n+          this.isWsConnected = true\n+          clearTimeout(timeout)\n+          this._showNotification(`[${WINDOW_ID}] WebSocket连接成功`, 'success')\n+          this._logServerConsistency('WebSocket连接成功')\n+          resolve(true)\n+        }\n+\n+        this.wsConnection.onerror = (error) => {\n+          this.isWsConnected = false\n+          clearTimeout(timeout)\n+          console.error('❌ WebSocket连接错误:', error)\n+          reject(new Error('WebSocket连接失败'))\n+        }\n+\n+        this.wsConnection.onclose = (event) => {\n+          this.isWsConnected = false\n+          console.log(`🔌 [${WINDOW_ID}] WebSocket连接关闭: ${event.code} - ${event.reason}`)\n+\n+          // 🔧 如果不是正常关闭，尝试重连\n+          if (event.code !== 1000 && event.code !== 1001) {\n+            console.log(`🔄 [${WINDOW_ID}] 非正常关闭，准备重连...`)\n+            setTimeout(() => {\n+              if (!this.isWsConnected) {\n+                console.log(`🔄 [${WINDOW_ID}] 执行WebSocket重连`)\n+                this.initializeWebSocket(baseUrl).catch(error => {\n+                  console.error('❌ WebSocket重连失败:', error)\n+                })\n+              }\n+            }, 3000)\n+          }\n+        }\n+\n+        this.wsConnection.onmessage = (event) => {\n+          try {\n+            const message = event.data\n+\n+            // 🔧 增强消息过滤：只处理当前窗口的消息\n+            if (typeof message === 'object' && message.windowId && message.windowId !== WINDOW_ID) {\n+              console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的消息: ${message.windowId}`)\n+              return\n+            }\n+\n+            // 官方标准：只处理字符串消息\n+            if (typeof message === 'string') {\n+              try {\n+                const parsedMessage = JSON.parse(message)\n+\n+                // 调用重构后的消息处理函数\n+                this.handleWebSocketMessage(parsedMessage)\n+              } catch (parseError) {\n+                console.error('❌ [OFFICIAL] JSON解析失败:', parseError.message)\n+              }\n+            }\n+\n+          } catch (error) {\n+            console.error('❌ [OFFICIAL] WebSocket消息处理失败:', error)\n+          }\n+        }\n+      })\n+    } catch (error) {\n+      console.error('❌ 初始化 WebSocket 失败:', error)\n+\n+      // 🔧 根据错误类型决定是否清除服务器锁定\n+      if (error.message.includes('负载均衡器') || error.message.includes('无法获取可用的ComfyUI服务器')) {\n+        // 如果是负载均衡器错误，清除服务器锁定\n+        this.currentWebSocketServer = null\n+        this.clearWindowServerLock()\n+        console.log('🔓 负载均衡器错误，清除服务器锁定')\n+      } else if (error.message.includes('ComfyUI服务器不可达') || error.message.includes('WebSocket 连接超时')) {\n+        // 如果是连接错误但服务器可能恢复，保持锁定以便重试\n+        console.log('🔒 连接错误但保持服务器锁定以便重试')\n+      } else {\n+        // 其他未知错误，清除锁定\n+        this.currentWebSocketServer = null\n+        this.clearWindowServerLock()\n+        console.log('🔓 未知错误，清除服务器锁定')\n+      }\n+\n+      throw error\n+    }\n+  }\n+\n   // 🔧 获取当前窗口的服务器锁定信息\n   getWindowServerLock() {\n     return this.WINDOW_SERVER_LOCKS.get(WINDOW_ID) || null\n   }\n"
                },
                {
                    "date": 1753511617085,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1018,10 +1018,10 @@\n       }\n     }\n   }\n \n-  // 🔥 处理任务完成的核心函数 - 重构版本（窗口隔离版本）\n-  handleTaskCompletion(promptId) {\n+  // 🔥 处理任务完成的核心函数 - 修复版本（恢复结果获取逻辑）\n+  async handleTaskCompletion(promptId) {\n     try {\n       const task = this.getWindowTask(promptId)\n       if (!task) {\n         console.warn(`⚠️ [${WINDOW_ID}] 任务完成处理失败: 任务不存在 ${promptId}`)\n@@ -1032,19 +1032,36 @@\n \n       // 🔧 使用安全进度回调\n       this.safeProgressCallback(promptId, task, '任务执行完成', 100)\n \n+      // 🔧 获取任务历史和结果（恢复重构前的逻辑）\n+      let taskResult = null\n+      try {\n+        // 动态导入 comfyui.js 中的函数\n+        const comfyuiModule = await import('./comfyui.js')\n+        const { getTaskHistory, extractTaskResults } = comfyuiModule\n+\n+        console.log(`📊 [${WINDOW_ID}] 开始获取任务结果: ${promptId}`)\n+        const history = await getTaskHistory()\n+        taskResult = await extractTaskResults(history, promptId)\n+        console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`, taskResult)\n+      } catch (error) {\n+        console.error(`❌ [${WINDOW_ID}] 任务结果获取失败: ${promptId}`, error)\n+        // 继续执行，但结果为null\n+        taskResult = null\n+      }\n+\n       // 立即清理任务\n       this.removeWindowTask(promptId)\n \n       // 🔧 检查是否可以解锁服务器\n       this.checkServerUnlockCondition()\n \n-      // 调用成功回调\n-      if (task.onSuccess) {\n+      // 调用成功回调，传递完整的任务结果（修复：使用onComplete而不是onSuccess）\n+      if (task.onComplete) {\n         // 🔧 使用setTimeout(0)确保成功回调立即执行（浏览器兼容）\n         setTimeout(() => {\n-          task.onSuccess(promptId)\n+          task.onComplete(taskResult) // ✅ 修复：传递完整的任务结果而不是只传递promptId\n         }, 0)\n       }\n \n       console.log(`✅ [${WINDOW_ID}] 任务完成处理结束: ${promptId}`)\n@@ -1057,9 +1074,10 @@\n \n       // 🔧 检查是否可以解锁服务器\n       this.checkServerUnlockCondition()\n \n-      if (task.onError) {\n+      const task = this.getWindowTask(promptId)\n+      if (task && task.onError) {\n         // 🔧 使用setTimeout(0)确保错误回调立即执行（浏览器兼容）\n         setTimeout(() => {\n           task.onError(error.message)\n         }, 0)\n"
                },
                {
                    "date": 1753511627498,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1032,36 +1032,19 @@\n \n       // 🔧 使用安全进度回调\n       this.safeProgressCallback(promptId, task, '任务执行完成', 100)\n \n-      // 🔧 获取任务历史和结果（恢复重构前的逻辑）\n-      let taskResult = null\n-      try {\n-        // 动态导入 comfyui.js 中的函数\n-        const comfyuiModule = await import('./comfyui.js')\n-        const { getTaskHistory, extractTaskResults } = comfyuiModule\n-\n-        console.log(`📊 [${WINDOW_ID}] 开始获取任务结果: ${promptId}`)\n-        const history = await getTaskHistory()\n-        taskResult = await extractTaskResults(history, promptId)\n-        console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`, taskResult)\n-      } catch (error) {\n-        console.error(`❌ [${WINDOW_ID}] 任务结果获取失败: ${promptId}`, error)\n-        // 继续执行，但结果为null\n-        taskResult = null\n-      }\n-\n       // 立即清理任务\n       this.removeWindowTask(promptId)\n \n       // 🔧 检查是否可以解锁服务器\n       this.checkServerUnlockCondition()\n \n-      // 调用成功回调，传递完整的任务结果（修复：使用onComplete而不是onSuccess）\n-      if (task.onComplete) {\n+      // 调用成功回调\n+      if (task.onSuccess) {\n         // 🔧 使用setTimeout(0)确保成功回调立即执行（浏览器兼容）\n         setTimeout(() => {\n-          task.onComplete(taskResult) // ✅ 修复：传递完整的任务结果而不是只传递promptId\n+          task.onSuccess(promptId)\n         }, 0)\n       }\n \n       console.log(`✅ [${WINDOW_ID}] 任务完成处理结束: ${promptId}`)\n@@ -1074,10 +1057,9 @@\n \n       // 🔧 检查是否可以解锁服务器\n       this.checkServerUnlockCondition()\n \n-      const task = this.getWindowTask(promptId)\n-      if (task && task.onError) {\n+      if (task.onError) {\n         // 🔧 使用setTimeout(0)确保错误回调立即执行（浏览器兼容）\n         setTimeout(() => {\n           task.onError(error.message)\n         }, 0)\n"
                },
                {
                    "date": 1753511641082,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1018,9 +1018,9 @@\n       }\n     }\n   }\n \n-  // 🔥 处理任务完成的核心函数 - 修复版本（恢复结果获取逻辑）\n+  // 🔥 处理任务完成的核心函数 - 重构版本（窗口隔离版本）\n   async handleTaskCompletion(promptId) {\n     try {\n       const task = this.getWindowTask(promptId)\n       if (!task) {\n"
                },
                {
                    "date": 1753511659775,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1018,9 +1018,9 @@\n       }\n     }\n   }\n \n-  // 🔥 处理任务完成的核心函数 - 重构版本（窗口隔离版本）\n+  // 🔥 处理任务完成的核心函数 - 修复版本（恢复结果获取逻辑）\n   async handleTaskCompletion(promptId) {\n     try {\n       const task = this.getWindowTask(promptId)\n       if (!task) {\n"
                },
                {
                    "date": 1753511673409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1018,9 +1018,9 @@\n       }\n     }\n   }\n \n-  // 🔥 处理任务完成的核心函数 - 修复版本（恢复结果获取逻辑）\n+  // 🔥 处理任务完成的核心函数 - 重构版本（窗口隔离版本）\n   async handleTaskCompletion(promptId) {\n     try {\n       const task = this.getWindowTask(promptId)\n       if (!task) {\n"
                },
                {
                    "date": 1753511696320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1019,9 +1019,9 @@\n     }\n   }\n \n   // 🔥 处理任务完成的核心函数 - 重构版本（窗口隔离版本）\n-  async handleTaskCompletion(promptId) {\n+  handleTaskCompletion(promptId) {\n     try {\n       const task = this.getWindowTask(promptId)\n       if (!task) {\n         console.warn(`⚠️ [${WINDOW_ID}] 任务完成处理失败: 任务不存在 ${promptId}`)\n@@ -1032,19 +1032,36 @@\n \n       // 🔧 使用安全进度回调\n       this.safeProgressCallback(promptId, task, '任务执行完成', 100)\n \n+      // 🔧 获取任务历史和结果（恢复重构前的逻辑）\n+      let taskResult = null\n+      try {\n+        // 动态导入 comfyui.js 中的函数\n+        const comfyuiModule = await import('./comfyui.js')\n+        const { getTaskHistory, extractTaskResults } = comfyuiModule\n+\n+        console.log(`📊 [${WINDOW_ID}] 开始获取任务结果: ${promptId}`)\n+        const history = await getTaskHistory()\n+        taskResult = await extractTaskResults(history, promptId)\n+        console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`, taskResult)\n+      } catch (error) {\n+        console.error(`❌ [${WINDOW_ID}] 任务结果获取失败: ${promptId}`, error)\n+        // 继续执行，但结果为null\n+        taskResult = null\n+      }\n+\n       // 立即清理任务\n       this.removeWindowTask(promptId)\n \n       // 🔧 检查是否可以解锁服务器\n       this.checkServerUnlockCondition()\n \n-      // 调用成功回调\n-      if (task.onSuccess) {\n+      // 调用成功回调，传递完整的任务结果（修复：使用onComplete而不是onSuccess）\n+      if (task.onComplete) {\n         // 🔧 使用setTimeout(0)确保成功回调立即执行（浏览器兼容）\n         setTimeout(() => {\n-          task.onSuccess(promptId)\n+          task.onComplete(taskResult) // ✅ 修复：传递完整的任务结果而不是只传递promptId\n         }, 0)\n       }\n \n       console.log(`✅ [${WINDOW_ID}] 任务完成处理结束: ${promptId}`)\n"
                },
                {
                    "date": 1753511716318,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1018,10 +1018,10 @@\n       }\n     }\n   }\n \n-  // 🔥 处理任务完成的核心函数 - 重构版本（窗口隔离版本）\n-  handleTaskCompletion(promptId) {\n+  // 🔥 处理任务完成的核心函数 - 修复版本（恢复结果获取逻辑）\n+  async handleTaskCompletion(promptId) {\n     try {\n       const task = this.getWindowTask(promptId)\n       if (!task) {\n         console.warn(`⚠️ [${WINDOW_ID}] 任务完成处理失败: 任务不存在 ${promptId}`)\n@@ -1032,36 +1032,19 @@\n \n       // 🔧 使用安全进度回调\n       this.safeProgressCallback(promptId, task, '任务执行完成', 100)\n \n-      // 🔧 获取任务历史和结果（恢复重构前的逻辑）\n-      let taskResult = null\n-      try {\n-        // 动态导入 comfyui.js 中的函数\n-        const comfyuiModule = await import('./comfyui.js')\n-        const { getTaskHistory, extractTaskResults } = comfyuiModule\n-\n-        console.log(`📊 [${WINDOW_ID}] 开始获取任务结果: ${promptId}`)\n-        const history = await getTaskHistory()\n-        taskResult = await extractTaskResults(history, promptId)\n-        console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`, taskResult)\n-      } catch (error) {\n-        console.error(`❌ [${WINDOW_ID}] 任务结果获取失败: ${promptId}`, error)\n-        // 继续执行，但结果为null\n-        taskResult = null\n-      }\n-\n       // 立即清理任务\n       this.removeWindowTask(promptId)\n \n       // 🔧 检查是否可以解锁服务器\n       this.checkServerUnlockCondition()\n \n-      // 调用成功回调，传递完整的任务结果（修复：使用onComplete而不是onSuccess）\n-      if (task.onComplete) {\n+      // 调用成功回调\n+      if (task.onSuccess) {\n         // 🔧 使用setTimeout(0)确保成功回调立即执行（浏览器兼容）\n         setTimeout(() => {\n-          task.onComplete(taskResult) // ✅ 修复：传递完整的任务结果而不是只传递promptId\n+          task.onSuccess(promptId)\n         }, 0)\n       }\n \n       console.log(`✅ [${WINDOW_ID}] 任务完成处理结束: ${promptId}`)\n"
                },
                {
                    "date": 1753511765264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1032,8 +1032,25 @@\n \n       // 🔧 使用安全进度回调\n       this.safeProgressCallback(promptId, task, '任务执行完成', 100)\n \n+      // 🔧 获取任务历史和结果（恢复重构前的逻辑）\n+      let taskResult = null\n+      try {\n+        // 动态导入 comfyui.js 中的函数\n+        const comfyuiModule = await import('./comfyui.js')\n+        const { getTaskHistory, extractTaskResults } = comfyuiModule\n+\n+        console.log(`📊 [${WINDOW_ID}] 开始获取任务结果: ${promptId}`)\n+        const history = await getTaskHistory()\n+        taskResult = await extractTaskResults(history, promptId)\n+        console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`, taskResult)\n+      } catch (error) {\n+        console.error(`❌ [${WINDOW_ID}] 任务结果获取失败: ${promptId}`, error)\n+        // 继续执行，但结果为null\n+        taskResult = null\n+      }\n+\n       // 立即清理任务\n       this.removeWindowTask(promptId)\n \n       // 🔧 检查是否可以解锁服务器\n"
                },
                {
                    "date": 1753511780705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1032,36 +1032,19 @@\n \n       // 🔧 使用安全进度回调\n       this.safeProgressCallback(promptId, task, '任务执行完成', 100)\n \n-      // 🔧 获取任务历史和结果（恢复重构前的逻辑）\n-      let taskResult = null\n-      try {\n-        // 动态导入 comfyui.js 中的函数\n-        const comfyuiModule = await import('./comfyui.js')\n-        const { getTaskHistory, extractTaskResults } = comfyuiModule\n-\n-        console.log(`📊 [${WINDOW_ID}] 开始获取任务结果: ${promptId}`)\n-        const history = await getTaskHistory()\n-        taskResult = await extractTaskResults(history, promptId)\n-        console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`, taskResult)\n-      } catch (error) {\n-        console.error(`❌ [${WINDOW_ID}] 任务结果获取失败: ${promptId}`, error)\n-        // 继续执行，但结果为null\n-        taskResult = null\n-      }\n-\n       // 立即清理任务\n       this.removeWindowTask(promptId)\n \n       // 🔧 检查是否可以解锁服务器\n       this.checkServerUnlockCondition()\n \n-      // 调用成功回调\n-      if (task.onSuccess) {\n+      // 调用成功回调，传递完整的任务结果（修复：使用onComplete而不是onSuccess）\n+      if (task.onComplete) {\n         // 🔧 使用setTimeout(0)确保成功回调立即执行（浏览器兼容）\n         setTimeout(() => {\n-          task.onSuccess(promptId)\n+          task.onComplete(taskResult) // ✅ 修复：传递完整的任务结果而不是只传递promptId\n         }, 0)\n       }\n \n       console.log(`✅ [${WINDOW_ID}] 任务完成处理结束: ${promptId}`)\n"
                },
                {
                    "date": 1753511814550,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1032,8 +1032,25 @@\n \n       // 🔧 使用安全进度回调\n       this.safeProgressCallback(promptId, task, '任务执行完成', 100)\n \n+      // 🔧 获取任务历史和结果（恢复重构前的逻辑）\n+      let taskResult = null\n+      try {\n+        // 动态导入 comfyui.js 中的函数\n+        const comfyuiModule = await import('./comfyui.js')\n+        const { getTaskHistory, extractTaskResults } = comfyuiModule\n+\n+        console.log(`📊 [${WINDOW_ID}] 开始获取任务结果: ${promptId}`)\n+        const history = await getTaskHistory()\n+        taskResult = await extractTaskResults(history, promptId)\n+        console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`, taskResult)\n+      } catch (error) {\n+        console.error(`❌ [${WINDOW_ID}] 任务结果获取失败: ${promptId}`, error)\n+        // 继续执行，但结果为null\n+        taskResult = null\n+      }\n+\n       // 立即清理任务\n       this.removeWindowTask(promptId)\n \n       // 🔧 检查是否可以解锁服务器\n"
                },
                {
                    "date": 1753511854062,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1032,25 +1032,8 @@\n \n       // 🔧 使用安全进度回调\n       this.safeProgressCallback(promptId, task, '任务执行完成', 100)\n \n-      // 🔧 获取任务历史和结果（恢复重构前的逻辑）\n-      let taskResult = null\n-      try {\n-        // 动态导入 comfyui.js 中的函数\n-        const comfyuiModule = await import('./comfyui.js')\n-        const { getTaskHistory, extractTaskResults } = comfyuiModule\n-\n-        console.log(`📊 [${WINDOW_ID}] 开始获取任务结果: ${promptId}`)\n-        const history = await getTaskHistory()\n-        taskResult = await extractTaskResults(history, promptId)\n-        console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`, taskResult)\n-      } catch (error) {\n-        console.error(`❌ [${WINDOW_ID}] 任务结果获取失败: ${promptId}`, error)\n-        // 继续执行，但结果为null\n-        taskResult = null\n-      }\n-\n       // 立即清理任务\n       this.removeWindowTask(promptId)\n \n       // 🔧 检查是否可以解锁服务器\n"
                },
                {
                    "date": 1753511888685,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1032,8 +1032,25 @@\n \n       // 🔧 使用安全进度回调\n       this.safeProgressCallback(promptId, task, '任务执行完成', 100)\n \n+      // 🔧 获取任务历史和结果（恢复重构前的逻辑）\n+      let taskResult = null\n+      try {\n+        // 动态导入 comfyui.js 中的函数\n+        const comfyuiModule = await import('./comfyui.js')\n+        const { getTaskHistory, extractTaskResults } = comfyuiModule\n+\n+        console.log(`📊 [${WINDOW_ID}] 开始获取任务结果: ${promptId}`)\n+        const history = await getTaskHistory()\n+        taskResult = await extractTaskResults(history, promptId)\n+        console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`, taskResult)\n+      } catch (error) {\n+        console.error(`❌ [${WINDOW_ID}] 任务结果获取失败: ${promptId}`, error)\n+        // 继续执行，但结果为null\n+        taskResult = null\n+      }\n+\n       // 立即清理任务\n       this.removeWindowTask(promptId)\n \n       // 🔧 检查是否可以解锁服务器\n@@ -1057,9 +1074,10 @@\n \n       // 🔧 检查是否可以解锁服务器\n       this.checkServerUnlockCondition()\n \n-      if (task.onError) {\n+      const task = this.getWindowTask(promptId)\n+      if (task && task.onError) {\n         // 🔧 使用setTimeout(0)确保错误回调立即执行（浏览器兼容）\n         setTimeout(() => {\n           task.onError(error.message)\n         }, 0)\n"
                },
                {
                    "date": 1753511914012,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1074,10 +1074,9 @@\n \n       // 🔧 检查是否可以解锁服务器\n       this.checkServerUnlockCondition()\n \n-      const task = this.getWindowTask(promptId)\n-      if (task && task.onError) {\n+      if (task.onError) {\n         // 🔧 使用setTimeout(0)确保错误回调立即执行（浏览器兼容）\n         setTimeout(() => {\n           task.onError(error.message)\n         }, 0)\n"
                },
                {
                    "date": 1753511995472,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1074,9 +1074,10 @@\n \n       // 🔧 检查是否可以解锁服务器\n       this.checkServerUnlockCondition()\n \n-      if (task.onError) {\n+      const task = this.getWindowTask(promptId)\n+      if (task && task.onError) {\n         // 🔧 使用setTimeout(0)确保错误回调立即执行（浏览器兼容）\n         setTimeout(() => {\n           task.onError(error.message)\n         }, 0)\n"
                },
                {
                    "date": 1753512969185,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,32 +1,21 @@\n-// WebSocket 管理器 - 独立模块\n-// 负责所有 WebSocket 连接管理、消息处理、重连逻辑和窗口隔离机制\n+// 极简版 WebSocket 管理器 - 基于官方 websockets_api_example.py\n+// 支持多用户多窗口、服务器选择、任务锁定机制\n \n import loadBalancer from './loadBalancer.js'\n \n-// 🔧 窗口唯一标识符生成机制\n-function generateWindowId() {\n+// 生成唯一标识符\n+function generateId() {\n   return `${Date.now()}_${Math.random().toString(36).substring(2, 11)}`\n }\n \n-// 🔧 为当前窗口生成唯一的clientId - 增强唯一性防止冲突\n-function generateUniqueClientId() {\n-  const baseId = 'abc1373d4ad648a3a81d0587fbe5534b' // 基础clientId\n-  const timestamp = Date.now()\n-  const random = Math.random().toString(36).substring(2, 11)\n-  const windowId = generateWindowId()\n+// 窗口唯一标识\n+const WINDOW_ID = generateId()\n+const CLIENT_ID = generateId()\n \n-  // 🔧 增强唯一性：基础ID + 时间戳 + 随机数 + 窗口ID\n-  return `${baseId}_${timestamp}_${random}_${windowId}`\n-}\n+console.log(`🪟 窗口ID: ${WINDOW_ID}`)\n+console.log(`🔑 客户端ID: ${CLIENT_ID}`)\n \n-// 🔧 窗口级别的全局变量 - 确保每个窗口都有唯一标识\n-const WINDOW_CLIENT_ID = generateUniqueClientId()\n-const WINDOW_ID = generateWindowId()\n-\n-console.log(`🪟 窗口标识: ${WINDOW_ID}`)\n-console.log(`🔑 窗口客户端ID: ${WINDOW_CLIENT_ID}`)\n-\n /**\n  * WebSocket 管理器类\n  * 负责 WebSocket 连接的完整生命周期管理\n  */\n"
                },
                {
                    "date": 1753513080992,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,1208 +15,319 @@\n console.log(`🪟 窗口ID: ${WINDOW_ID}`)\n console.log(`🔑 客户端ID: ${CLIENT_ID}`)\n \n /**\n- * WebSocket 管理器类\n- * 负责 WebSocket 连接的完整生命周期管理\n+ * 极简版 WebSocket 管理器\n+ * 基于官方 websockets_api_example.py 的核心逻辑\n  */\n-class WebSocketManager {\n+class SimpleWebSocketManager {\n   constructor() {\n-    // WebSocket 连接状态\n-    this.wsConnection = null\n-    this.isWsConnected = false\n-    this.currentWebSocketServer = null\n-\n-    // 窗口隔离的任务队列\n-    this.windowTasks = new Map() // promptId -> task\n-\n-    // 窗口级别的服务器锁定机制\n-    this.WINDOW_SERVER_LOCKS = new Map() // windowId -> { server, timestamp, tasks }\n-\n-    // 动态解锁检查机制\n-    this.serverUnlockTimer = null\n-\n-    // 防抖机制：避免频繁的进度回调触发递归更新\n-    this.progressCallbackDebounce = new Map()\n-\n-    // 官方标准任务状态枚举\n-    this.TASK_STATUS = {\n-      WAITING: 'waiting',        // 任务在队列中等待\n-      EXECUTING: 'executing',    // 任务正在执行\n-      COMPLETED: 'completed',    // 任务已完成\n-      ERROR: 'error',           // 任务执行错误\n-      INTERRUPTED: 'interrupted' // 任务被中断\n-    }\n-\n-    // 初始化窗口事件监听\n-    this._initializeWindowEvents()\n-    this._initializeGlobalProperties()\n+    // WebSocket 连接\n+    this.ws = null\n+    this.isConnected = false\n+    this.currentServer = null\n+    \n+    // 任务管理 - 只保留当前窗口的任务\n+    this.tasks = new Map() // promptId -> { onComplete, onError, onProgress, server }\n+    \n+    // 服务器锁定 - 简化为窗口级别\n+    this.lockedServer = null\n+    this.lockTimestamp = null\n+    \n+    // 初始化窗口事件\n+    this._initWindowEvents()\n   }\n \n-  // 🔧 窗口关闭时的清理机制\n-  _initializeWindowEvents() {\n+  // 窗口关闭清理\n+  _initWindowEvents() {\n     window.addEventListener('beforeunload', () => {\n-      console.log(`🚪 [${WINDOW_ID}] 窗口即将关闭，执行清理...`)\n-\n-      // 清理当前窗口的服务器锁定\n-      const currentLock = this.getWindowServerLock()\n-      if (currentLock) {\n-        console.log(`🔓 [${WINDOW_ID}] 窗口关闭，清理服务器锁定: ${currentLock.server}`)\n-        this.clearWindowServerLock()\n-      }\n-\n-      // 清理当前窗口的任务\n-      if (this.windowTasks.size > 0) {\n-        console.log(`🗑️ [${WINDOW_ID}] 窗口关闭，清理 ${this.windowTasks.size} 个任务`)\n-        this.windowTasks.clear()\n-      }\n-\n-      // 关闭WebSocket连接\n-      if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) {\n-        console.log(`🔌 [${WINDOW_ID}] 窗口关闭，断开WebSocket连接`)\n-        this.wsConnection.close()\n-      }\n+      console.log(`🚪 [${WINDOW_ID}] 窗口关闭，清理资源`)\n+      this._cleanup()\n     })\n+  }\n \n-    // 🔧 页面可见性变化时的处理\n-    document.addEventListener('visibilitychange', () => {\n-      if (document.hidden) {\n-        console.log(`👁️ [${WINDOW_ID}] 窗口隐藏`)\n-      } else {\n-        console.log(`👁️ [${WINDOW_ID}] 窗口重新可见`)\n-\n-        // 检查服务器锁定状态\n-        const currentLock = this.getWindowServerLock()\n-        if (currentLock) {\n-          console.log(`🔒 [${WINDOW_ID}] 窗口重新可见，服务器锁定状态: ${currentLock.server}`)\n-        }\n-\n-        // 检查任务状态\n-        if (this.windowTasks.size > 0) {\n-          console.log(`📊 [${WINDOW_ID}] 窗口重新可见，当前任务数: ${this.windowTasks.size}`)\n-        }\n-      }\n-    })\n+  // 清理资源\n+  _cleanup() {\n+    if (this.ws) {\n+      this.ws.close()\n+      this.ws = null\n+    }\n+    this.tasks.clear()\n+    this.lockedServer = null\n+    this.isConnected = false\n   }\n \n-  // 🔧 初始化全局属性以保持向后兼容\n-  _initializeGlobalProperties() {\n-    // 🔧 兼容性：动态获取当前窗口的锁定服务器\n-    Object.defineProperty(window, 'windowLockedServer', {\n-      get: () => {\n-        const lock = this.getWindowServerLock()\n-        return lock ? lock.server : null\n-      },\n-      set: (value) => {\n-        if (value) {\n-          this.setWindowServerLock(value)\n-        } else {\n-          this.clearWindowServerLock()\n-        }\n-      }\n-    })\n+  // 连接到指定服务器\n+  async connectToServer(serverUrl) {\n+    if (this.ws && this.isConnected && this.currentServer === serverUrl) {\n+      console.log(`✅ [${WINDOW_ID}] 已连接到服务器: ${serverUrl}`)\n+      return true\n+    }\n \n-    Object.defineProperty(window, 'windowLockTimestamp', {\n-      get: () => {\n-        const lock = this.getWindowServerLock()\n-        return lock ? lock.timestamp : null\n-      }\n-    })\n+    // 关闭现有连接\n+    if (this.ws) {\n+      this.ws.close()\n+    }\n \n-    // 🔧 保留原有的全局变量名但使用窗口级别的值（动态获取）\n-    Object.defineProperty(window, 'currentWebSocketServer', {\n-      get: () => {\n-        return window.windowLockedServer\n-      },\n-      set: (value) => {\n-        window.windowLockedServer = value\n-      }\n-    })\n-\n-    Object.defineProperty(window, 'serverLockTimestamp', {\n-      get: () => {\n-        return window.windowLockTimestamp\n-      }\n-    })\n-\n-    // 🔧 为了向后兼容，保留 pendingTasks 引用但指向窗口任务队列\n-    window.pendingTasks = this.windowTasks\n-  }\n-\n-  // ==================== WebSocket 连接管理方法 ====================\n-\n-  // 🔧 初始化 WebSocket 连接 - 重构版本（解决多服务器消息路由错乱）\n-  async initializeWebSocket(targetServer = null) {\n     try {\n-      // 🔧 关键修复：支持指定目标服务器，确保任务-服务器绑定一致性\n-      let baseUrl\n-      const currentLock = this.getWindowServerLock()\n+      const wsUrl = `${serverUrl.replace('http', 'ws')}/ws?clientId=${CLIENT_ID}`\n+      console.log(`🔌 [${WINDOW_ID}] 连接到: ${wsUrl}`)\n+      \n+      this.ws = new WebSocket(wsUrl)\n+      this.currentServer = serverUrl\n \n-      if (targetServer) {\n-        // 如果指定了目标服务器，直接使用\n-        baseUrl = targetServer\n-        console.log(`🎯 [${WINDOW_ID}] 使用指定的目标服务器: ${baseUrl}`)\n-      } else if (currentLock && currentLock.server) {\n-        // 如果当前窗口已锁定服务器，使用锁定的服务器\n-        baseUrl = currentLock.server\n-        console.log(`🔒 [${WINDOW_ID}] 使用窗口锁定的服务器: ${baseUrl}`)\n-      } else {\n-        // 否则从负载均衡器获取可用服务器\n-        try {\n-          baseUrl = await loadBalancer.getAvailableServer()\n-          if (!baseUrl) {\n-            throw new Error('负载均衡器返回空服务器')\n-          }\n-          console.log(`⚖️ [${WINDOW_ID}] 从负载均衡器获取服务器: ${baseUrl}`)\n-        } catch (lbError) {\n-          console.error('❌ 负载均衡器错误:', lbError.message)\n-          throw new Error(`无法获取可用的ComfyUI服务器: ${lbError.message}`)\n-        }\n-      }\n-\n-      // 🔧 检查现有连接是否与目标服务器一致\n-      if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) {\n-        const currentWsServer = this.currentWebSocketServer || this.getWindowServerLock()?.server\n-        if (currentWsServer === baseUrl) {\n-          console.log(`✅ [${WINDOW_ID}] WebSocket已连接到正确服务器: ${baseUrl}`)\n-          return true\n-        } else {\n-          console.log(`🔄 [${WINDOW_ID}] WebSocket服务器不匹配，需要重连`)\n-          console.log(`   当前连接: ${currentWsServer}`)\n-          console.log(`   目标服务器: ${baseUrl}`)\n-          // 关闭现有连接，建立新连接\n-          this.wsConnection.close(1000, '切换到正确的服务器')\n-          this.wsConnection = null\n-          this.isWsConnected = false\n-        }\n-      }\n-\n-      console.log(`🔌 [${WINDOW_ID}] 连接WebSocket: ${baseUrl}`)\n-\n-      // 🔧 构建WebSocket URL - 使用增强的唯一clientId\n-      let wsUrl\n-      if (baseUrl.startsWith('https://')) {\n-        wsUrl = baseUrl.replace('https://', 'wss://') + '/ws?clientId=' + WINDOW_CLIENT_ID\n-      } else {\n-        wsUrl = baseUrl.replace('http://', 'ws://') + '/ws?clientId=' + WINDOW_CLIENT_ID\n-      }\n-\n-      console.log(`🔗 [${WINDOW_ID}] WebSocket URL: ${wsUrl}`)\n-      console.log(`🔑 [${WINDOW_ID}] 使用增强clientId: ${WINDOW_CLIENT_ID}`)\n-\n-      // 简单的HTTP连接测试\n-      try {\n-        const testResponse = await fetch(`${baseUrl}/api/queue`, {\n-          method: 'GET',\n-          signal: AbortSignal.timeout(5000)\n-        })\n-        if (!testResponse.ok) {\n-          throw new Error(`服务器响应错误: ${testResponse.status}`)\n-        }\n-      } catch (httpError) {\n-        throw new Error(`ComfyUI服务器不可达: ${httpError.message}`)\n-      }\n-\n-      // 🔧 记录即将连接的服务器，用于后续验证\n-      this.currentWebSocketServer = baseUrl\n-      this.wsConnection = new WebSocket(wsUrl)\n-\n       return new Promise((resolve, reject) => {\n         const timeout = setTimeout(() => {\n-          reject(new Error('WebSocket 连接超时'))\n+          reject(new Error('连接超时'))\n         }, 10000)\n \n-        this.wsConnection.onopen = () => {\n-          this.isWsConnected = true\n+        this.ws.onopen = () => {\n+          this.isConnected = true\n           clearTimeout(timeout)\n-          this._showNotification(`[${WINDOW_ID}] WebSocket连接成功`, 'success')\n-          this._logServerConsistency('WebSocket连接成功')\n+          console.log(`✅ [${WINDOW_ID}] WebSocket连接成功: ${serverUrl}`)\n           resolve(true)\n         }\n \n-        this.wsConnection.onerror = (error) => {\n-          this.isWsConnected = false\n+        this.ws.onerror = (error) => {\n+          this.isConnected = false\n           clearTimeout(timeout)\n-          console.error('❌ WebSocket连接错误:', error)\n-          reject(new Error('WebSocket连接失败'))\n+          console.error(`❌ [${WINDOW_ID}] WebSocket连接失败:`, error)\n+          reject(error)\n         }\n \n-        this.wsConnection.onclose = (event) => {\n-          this.isWsConnected = false\n-          console.log(`🔌 [${WINDOW_ID}] WebSocket连接关闭: ${event.code} - ${event.reason}`)\n-\n-          // 🔧 如果不是正常关闭，尝试重连\n-          if (event.code !== 1000 && event.code !== 1001) {\n-            console.log(`🔄 [${WINDOW_ID}] 非正常关闭，准备重连...`)\n-            setTimeout(() => {\n-              if (!this.isWsConnected) {\n-                console.log(`🔄 [${WINDOW_ID}] 执行WebSocket重连`)\n-                this.initializeWebSocket(baseUrl).catch(error => {\n-                  console.error('❌ WebSocket重连失败:', error)\n-                })\n-              }\n-            }, 3000)\n-          }\n+        this.ws.onclose = () => {\n+          this.isConnected = false\n+          console.log(`🔌 [${WINDOW_ID}] WebSocket连接关闭`)\n         }\n \n-        this.wsConnection.onmessage = (event) => {\n+        // 核心消息处理 - 基于官方样例\n+        this.ws.onmessage = (event) => {\n           try {\n-            const message = event.data\n-\n-            // 🔧 增强消息过滤：只处理当前窗口的消息\n-            if (typeof message === 'object' && message.windowId && message.windowId !== WINDOW_ID) {\n-              console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的消息: ${message.windowId}`)\n-              return\n-            }\n-\n-            // 官方标准：只处理字符串消息\n-            if (typeof message === 'string') {\n-              try {\n-                const parsedMessage = JSON.parse(message)\n-\n-                // 调用重构后的消息处理函数\n-                this.handleWebSocketMessage(parsedMessage)\n-              } catch (parseError) {\n-                console.error('❌ [OFFICIAL] JSON解析失败:', parseError.message)\n-              }\n-            }\n-\n+            const message = JSON.parse(event.data)\n+            this._handleMessage(message)\n           } catch (error) {\n-            console.error('❌ [OFFICIAL] WebSocket消息处理失败:', error)\n+            console.error(`❌ [${WINDOW_ID}] 消息解析失败:`, error)\n           }\n         }\n       })\n     } catch (error) {\n-      console.error('❌ 初始化 WebSocket 失败:', error)\n-\n-      // 🔧 根据错误类型决定是否清除服务器锁定\n-      if (error.message.includes('负载均衡器') || error.message.includes('无法获取可用的ComfyUI服务器')) {\n-        // 如果是负载均衡器错误，清除服务器锁定\n-        this.currentWebSocketServer = null\n-        this.clearWindowServerLock()\n-        console.log('🔓 负载均衡器错误，清除服务器锁定')\n-      } else if (error.message.includes('ComfyUI服务器不可达') || error.message.includes('WebSocket 连接超时')) {\n-        // 如果是连接错误但服务器可能恢复，保持锁定以便重试\n-        console.log('🔒 连接错误但保持服务器锁定以便重试')\n-      } else {\n-        // 其他未知错误，清除锁定\n-        this.currentWebSocketServer = null\n-        this.clearWindowServerLock()\n-        console.log('🔓 未知错误，清除服务器锁定')\n-      }\n-\n+      console.error(`❌ [${WINDOW_ID}] 连接失败:`, error)\n       throw error\n     }\n   }\n \n-  // 🔧 获取当前窗口的服务器锁定信息\n-  getWindowServerLock() {\n-    return this.WINDOW_SERVER_LOCKS.get(WINDOW_ID) || null\n-  }\n+  // 消息处理 - 基于官方 websockets_api_example.py 第37-40行\n+  _handleMessage(message) {\n+    const { type, data } = message\n \n-  // 🔧 设置当前窗口的服务器锁定信息\n-  setWindowServerLock(server, timestamp = Date.now()) {\n-    this.WINDOW_SERVER_LOCKS.set(WINDOW_ID, {\n-      server,\n-      timestamp,\n-      windowId: WINDOW_ID,\n-      clientId: WINDOW_CLIENT_ID\n-    })\n-    console.log(`🔒 [${WINDOW_ID}] 设置窗口服务器锁定: ${server}`)\n-  }\n-\n-  // 🔧 清除当前窗口的服务器锁定信息\n-  clearWindowServerLock() {\n-    const lock = this.WINDOW_SERVER_LOCKS.get(WINDOW_ID)\n-    if (lock) {\n-      this.WINDOW_SERVER_LOCKS.delete(WINDOW_ID)\n-      console.log(`🔓 [${WINDOW_ID}] 清除窗口服务器锁定: ${lock.server}`)\n-    }\n-  }\n-\n-  // 🔧 动态服务器锁定管理（基于任务状态的智能锁定）\n-  lockServerForWindow(serverUrl) {\n-    const timestamp = Date.now()\n-    this.setWindowServerLock(serverUrl, timestamp)\n-\n-    console.log(`🔒 [${WINDOW_ID}] 锁定服务器: ${serverUrl}`)\n-    console.log(`🕐 [${WINDOW_ID}] 锁定时间: ${new Date(timestamp).toLocaleTimeString()}`)\n-    console.log(`🎯 [${WINDOW_ID}] 锁定模式: 任务驱动动态锁定（无固定超时）`)\n-    console.log(`🪟 [${WINDOW_ID}] 窗口隔离: 独立锁定，不影响其他窗口`)\n-\n-    // 🔧 实现动态锁定机制：在任务完成前不解锁服务器\n-    this.scheduleServerUnlockCheck()\n-  }\n-\n-  unlockServerForWindow() {\n-    const currentLock = this.getWindowServerLock()\n-    if (currentLock) {\n-      const lockDuration = Date.now() - currentLock.timestamp\n-      console.log(`🔓 [${WINDOW_ID}] 解锁服务器: ${currentLock.server}`)\n-      console.log(`⏱️ [${WINDOW_ID}] 锁定持续时间: ${Math.round(lockDuration / 1000)}秒`)\n-      console.log(`📊 [${WINDOW_ID}] 解锁时任务数: ${this.windowTasks.size}`)\n-      console.log(`🪟 [${WINDOW_ID}] 窗口隔离: 仅解锁当前窗口，不影响其他窗口`)\n-\n-      this.clearWindowServerLock()\n-\n-      // 清理解锁检查定时器\n-      this.clearServerUnlockTimer()\n-    }\n-  }\n-\n-  // 🔧 强制解锁服务器（用于异常情况处理）\n-  forceUnlockServerForWindow() {\n-    const currentLock = this.getWindowServerLock()\n-    if (currentLock) {\n-      console.log(`🚨 [${WINDOW_ID}] 强制解锁服务器: ${currentLock.server}`)\n-      console.log(`⚠️ [${WINDOW_ID}] 当前仍有 ${this.windowTasks.size} 个待处理任务`)\n-      console.log(`🪟 [${WINDOW_ID}] 窗口隔离: 强制解锁仅影响当前窗口`)\n-      this.unlockServerForWindow()\n-      return true\n-    }\n-    return false\n-  }\n-\n-  // 🔧 窗口级别的任务管理函数 - 完全隔离版本\n-  registerWindowTask(promptId, task) {\n-    let currentLock = this.getWindowServerLock()\n-\n-    // 🔧 智能验证：如果服务器未锁定，自动锁定到当前API服务器\n-    if (!currentLock || !currentLock.server) {\n-      console.warn(`⚠️ [${WINDOW_ID}] 注册任务时服务器未锁定，尝试自动锁定...`)\n-      try {\n-        // 使用当前任务的执行服务器或默认API服务器\n-        const serverToLock = task.executionServer || this._getDefaultServerUrl()\n-        this.lockServerForWindow(serverToLock)\n-        currentLock = this.getWindowServerLock()\n-        console.log(`🔒 [${WINDOW_ID}] 自动锁定服务器: ${serverToLock}`)\n-      } catch (lockError) {\n-        console.error(`❌ [${WINDOW_ID}] 自动锁定失败: ${lockError.message}`)\n-        // 继续执行，但记录警告\n-        console.warn(`⚠️ [${WINDOW_ID}] 任务 ${promptId} 将在无锁定状态下注册`)\n+    // 只处理 executing 消息，检测任务完成\n+    if (type === 'executing' && data) {\n+      const { node, prompt_id } = data\n+      \n+      // 任务完成检测：node 为 null 表示执行完成\n+      if (node === null && prompt_id) {\n+        console.log(`🎉 [${WINDOW_ID}] 任务完成: ${prompt_id}`)\n+        this._handleTaskCompletion(prompt_id)\n+      } else if (node && prompt_id) {\n+        // 任务执行中\n+        console.log(`🔄 [${WINDOW_ID}] 执行节点: ${node} (任务: ${prompt_id})`)\n+        this._handleTaskProgress(prompt_id, `执行节点: ${node}`, 50)\n       }\n     }\n \n-    // 🔧 智能绑定服务器：优先使用锁定服务器，否则使用任务自带的服务器\n-    if (currentLock && currentLock.server) {\n-      task.executionServer = currentLock.server\n-    } else if (!task.executionServer) {\n-      // 如果都没有，使用默认配置\n-      task.executionServer = this._getDefaultServerUrl()\n-      console.warn(`⚠️ [${WINDOW_ID}] 使用默认服务器绑定任务: ${task.executionServer}`)\n+    // 处理其他消息类型\n+    if (type === 'progress' && data && data.prompt_id) {\n+      this._handleTaskProgress(data.prompt_id, '处理中...', data.value || 0)\n     }\n \n-    task.windowId = WINDOW_ID\n-    task.clientId = WINDOW_CLIENT_ID\n-    task.registeredAt = Date.now()\n-    task.lockInfo = currentLock ? { ...currentLock } : null // 保存锁定信息快照\n-\n-    this.windowTasks.set(promptId, task)\n-\n-    console.log(`📝 [${WINDOW_ID}] 任务已注册: ${promptId}, 绑定服务器: ${task.executionServer}`)\n-    console.log(`📊 [${WINDOW_ID}] 当前窗口任务数: ${this.windowTasks.size}`)\n-    console.log(`🔒 [${WINDOW_ID}] 任务锁定信息:`, task.lockInfo)\n-\n-    // 🔧 锁定续期：检测到新任务时自动续期锁定状态\n-    if (currentLock) {\n-      console.log(`🔄 [${WINDOW_ID}] 检测到新任务，续期服务器锁定状态`)\n-      // 重新调度解锁检查\n-      this.scheduleServerUnlockCheck()\n+    if (type === 'execution_error' && data && data.prompt_id) {\n+      this._handleTaskError(data.prompt_id, data.exception_message || '执行错误')\n     }\n   }\n \n-  getWindowTask(promptId) {\n-    const task = this.windowTasks.get(promptId)\n-    if (task) {\n-      // 🔧 简化检测：如果任务存在就返回，不严格检查窗口归属\n-      // 这样可以避免因窗口ID不匹配导致的任务丢失\n-      if (task.windowId !== WINDOW_ID) {\n-        console.log(`🔍 [${WINDOW_ID}] 使用其他窗口的任务: ${promptId} (原窗口: ${task.windowId})`)\n-      }\n-      return task\n+  // 任务进度处理\n+  _handleTaskProgress(promptId, message, progress) {\n+    const task = this.tasks.get(promptId)\n+    if (task && task.onProgress) {\n+      task.onProgress(message, progress)\n     }\n-\n-    return null\n   }\n \n-  removeWindowTask(promptId) {\n-    const task = this.windowTasks.get(promptId)\n-    if (task && task.windowId === WINDOW_ID) {\n-      this.windowTasks.delete(promptId)\n-      console.log(`🗑️ [${WINDOW_ID}] 任务已移除: ${promptId}`)\n-      console.log(`📊 [${WINDOW_ID}] 剩余窗口任务数: ${this.windowTasks.size}`)\n-\n-      // 🔧 任务移除后立即检查是否可以解锁服务器\n-      const currentLock = this.getWindowServerLock()\n-      if (this.windowTasks.size === 0 && currentLock) {\n-        console.log(`🔓 [${WINDOW_ID}] 最后一个任务完成，立即解锁服务器`)\n-        this.unlockServerForWindow()\n-      } else if (this.windowTasks.size > 0) {\n-        console.log(`🔒 [${WINDOW_ID}] 仍有任务运行，保持服务器锁定`)\n-      }\n-\n-      return true\n+  // 任务完成处理 - 基于官方样例第47-56行\n+  async _handleTaskCompletion(promptId) {\n+    const task = this.tasks.get(promptId)\n+    if (!task) {\n+      console.warn(`⚠️ [${WINDOW_ID}] 任务不存在: ${promptId}`)\n+      return\n     }\n-    return false\n-  }\n \n-  // 🔧 新增：根据任务ID获取绑定的服务器地址\n-  getTaskBoundServer(promptId) {\n-    const task = this.getWindowTask(promptId)\n-    if (task && task.executionServer) {\n-      console.log(`🎯 [${WINDOW_ID}] 任务 ${promptId} 绑定服务器: ${task.executionServer}`)\n-      return task.executionServer\n-    }\n-    console.warn(`⚠️ [${WINDOW_ID}] 任务 ${promptId} 未找到绑定服务器`)\n-    return null\n-  }\n-\n-  // 🔧 获取默认服务器URL的辅助方法\n-  _getDefaultServerUrl() {\n-    // 这里需要从配置中获取，暂时返回一个默认值\n-    // 在实际使用时会通过依赖注入或配置传入\n-    return 'http://localhost:8188'\n-  }\n-\n-  // 🔧 窗口间通信机制（用于调试和监控）\n-  broadcastTaskStatus(promptId, status) {\n     try {\n-      const message = {\n-        type: 'task_status',\n-        windowId: WINDOW_ID,\n-        clientId: WINDOW_CLIENT_ID,\n-        promptId: promptId,\n-        status: status,\n-        timestamp: Date.now()\n+      // 获取任务历史 - 基于官方样例第47行\n+      const history = await this._getHistory(promptId)\n+      \n+      // 提取结果 - 基于官方样例第48-56行\n+      const result = this._extractResults(history, promptId)\n+      \n+      console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`)\n+      \n+      // 调用完成回调\n+      if (task.onComplete) {\n+        task.onComplete(result)\n       }\n-\n-      localStorage.setItem(`comfyui_task_${promptId}`, JSON.stringify(message))\n-      console.log(`📡 [${WINDOW_ID}] 广播任务状态: ${promptId} -> ${status}`)\n     } catch (error) {\n-      console.warn(`⚠️ [${WINDOW_ID}] 广播任务状态失败:`, error)\n+      console.error(`❌ [${WINDOW_ID}] 任务结果获取失败: ${promptId}`, error)\n+      if (task.onError) {\n+        task.onError(error)\n+      }\n+    } finally {\n+      // 清理任务\n+      this.tasks.delete(promptId)\n+      \n+      // 检查是否需要解锁服务器\n+      this._checkUnlock()\n     }\n   }\n \n-  // 🔧 原子性任务状态更新函数 - 窗口隔离版本\n-  updateTaskStatus(promptId, newStatus, additionalData = {}) {\n-    // 🔧 只处理属于当前窗口的任务\n-    const task = this.getWindowTask(promptId)\n-    if (!task) {\n-      console.warn(`⚠️ [${WINDOW_ID}] 尝试更新不存在或不属于当前窗口的任务状态: ${promptId}`)\n-      return false\n+  // 任务错误处理\n+  _handleTaskError(promptId, errorMessage) {\n+    const task = this.tasks.get(promptId)\n+    if (task && task.onError) {\n+      task.onError(new Error(errorMessage))\n     }\n-\n-    const oldStatus = task.status\n-    task.status = newStatus\n-    task.lastStatusUpdate = Date.now()\n-\n-    // 合并额外数据\n-    Object.assign(task, additionalData)\n-\n-    console.log(`🔄 [${WINDOW_ID}] 任务状态变更: ${promptId} ${oldStatus} → ${newStatus}`)\n-\n-    // 🔧 广播任务状态变更\n-    this.broadcastTaskStatus(promptId, newStatus)\n-\n-    return true\n+    this.tasks.delete(promptId)\n+    this._checkUnlock()\n   }\n \n-  // 🔧 动态解锁检查机制\n-  // 🔧 调度服务器解锁检查（定期检查任务状态）\n-  scheduleServerUnlockCheck() {\n-    // 清理之前的定时器\n-    this.clearServerUnlockTimer()\n-\n-    // 设置定期检查（每30秒检查一次）\n-    this.serverUnlockTimer = setInterval(() => {\n-      this.checkServerUnlockCondition()\n-    }, 30000)\n-\n-    console.log(`⏰ [${WINDOW_ID}] 已调度动态解锁检查（每30秒检查一次）`)\n-  }\n-\n-  // 🔧 清理解锁检查定时器\n-  clearServerUnlockTimer() {\n-    if (this.serverUnlockTimer) {\n-      clearInterval(this.serverUnlockTimer)\n-      this.serverUnlockTimer = null\n-      console.log(`🧹 [${WINDOW_ID}] 已清理解锁检查定时器`)\n+  // 获取任务历史 - 基于官方样例第25-27行\n+  async _getHistory(promptId) {\n+    const response = await fetch(`${this.currentServer}/api/history/${promptId}`)\n+    if (!response.ok) {\n+      throw new Error(`获取历史失败: ${response.status}`)\n     }\n+    return await response.json()\n   }\n \n-  // 🔧 检查是否可以解锁服务器的函数（增强版本）\n-  checkServerUnlockCondition() {\n-    const currentLock = this.getWindowServerLock()\n-    if (!currentLock) {\n-      // 服务器未锁定，清理定时器\n-      this.clearServerUnlockTimer()\n-      return false\n+  // 提取结果 - 基于官方样例第48-56行\n+  _extractResults(history, promptId) {\n+    const taskData = history[promptId]\n+    if (!taskData || !taskData.outputs) {\n+      throw new Error(`任务 ${promptId} 没有输出数据`)\n     }\n \n-    const taskCount = this.windowTasks.size\n-    const lockDuration = Date.now() - currentLock.timestamp\n-\n-    console.log(`🔍 [${WINDOW_ID}] 解锁条件检查:`)\n-    console.log(`   - 待处理任务数: ${taskCount}`)\n-    console.log(`   - 锁定持续时间: ${Math.round(lockDuration / 1000)}秒`)\n-    console.log(`   - 锁定服务器: ${currentLock.server}`)\n-\n-    if (taskCount === 0) {\n-      console.log(`🔓 [${WINDOW_ID}] 所有任务已完成，自动解锁服务器`)\n-      this.unlockServerForWindow()\n-      return true\n-    } else {\n-      console.log(`🔒 [${WINDOW_ID}] 仍有 ${taskCount} 个待处理任务，保持服务器锁定`)\n-\n-      // 列出待处理任务\n-      const taskIds = Array.from(this.windowTasks.keys())\n-      console.log(`📋 [${WINDOW_ID}] 待处理任务: [${taskIds.join(', ')}]`)\n-\n-      // 检查是否有长时间运行的任务\n-      const longRunningTasks = []\n-      this.windowTasks.forEach((task, promptId) => {\n-        const taskDuration = Date.now() - (task.registeredAt || currentLock.timestamp)\n-        if (taskDuration > 10 * 60 * 1000) { // 超过10分钟\n-          longRunningTasks.push({ promptId, duration: Math.round(taskDuration / 1000) })\n-        }\n-      })\n-\n-      if (longRunningTasks.length > 0) {\n-        console.log(`⚠️ [${WINDOW_ID}] 检测到长时间运行的任务:`)\n-        longRunningTasks.forEach(({ promptId, duration }) => {\n-          console.log(`   - ${promptId}: ${duration}秒`)\n-        })\n+    const results = {}\n+    for (const nodeId in taskData.outputs) {\n+      const nodeOutput = taskData.outputs[nodeId]\n+      if (nodeOutput.images) {\n+        results[nodeId] = nodeOutput.images\n       }\n     }\n-\n-    return false\n+    \n+    return results\n   }\n \n-  // 🔧 新增：确保WebSocket连接与任务执行服务器一致性\n-  async ensureWebSocketServerConsistency(taskServer) {\n+  // 选择最佳服务器\n+  async _selectBestServer() {\n     try {\n-      console.log(`🔍 [${WINDOW_ID}] 检查WebSocket服务器一致性...`)\n-      console.log(`🎯 [${WINDOW_ID}] 任务执行服务器: ${taskServer}`)\n-\n-      const currentLock = this.getWindowServerLock()\n-      const lockedServer = currentLock?.server\n-      const wsServer = this.currentWebSocketServer\n-\n-      console.log(`🔒 [${WINDOW_ID}] 当前锁定服务器: ${lockedServer}`)\n-      console.log(`🔗 [${WINDOW_ID}] WebSocket连接服务器: ${wsServer}`)\n-\n-      // 检查所有服务器是否一致\n-      const serversMatch = taskServer === lockedServer && taskServer === wsServer\n-\n-      if (serversMatch && this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) {\n-        console.log(`✅ [${WINDOW_ID}] 服务器一致性验证通过`)\n-        return true\n-      }\n-\n-      // 服务器不一致，需要重新建立连接\n-      console.log(`🔄 [${WINDOW_ID}] 服务器不一致，重新建立WebSocket连接`)\n-      console.log(`   任务服务器: ${taskServer}`)\n-      console.log(`   锁定服务器: ${lockedServer}`)\n-      console.log(`   WebSocket服务器: ${wsServer}`)\n-\n-      // 关闭现有连接\n-      if (this.wsConnection) {\n-        this.wsConnection.close(1000, '服务器不一致，重新连接')\n-        this.wsConnection = null\n-        this.isWsConnected = false\n-      }\n-\n-      // 重新初始化WebSocket连接到正确的服务器\n-      await this.initializeWebSocket(taskServer)\n-\n-      console.log(`✅ [${WINDOW_ID}] WebSocket重新连接到正确服务器: ${taskServer}`)\n-      return true\n-\n+      const bestServer = await loadBalancer.getBestServer()\n+      console.log(`🎯 [${WINDOW_ID}] 选择服务器: ${bestServer}`)\n+      return bestServer\n     } catch (error) {\n-      console.error(`❌ [${WINDOW_ID}] WebSocket服务器一致性检查失败:`, error)\n+      console.error(`❌ [${WINDOW_ID}] 服务器选择失败:`, error)\n       throw error\n     }\n   }\n \n-  // 🔧 新增：确保WebSocket连接 - 重构版本（支持任务-服务器绑定一致性）\n-  async ensureWebSocketConnection(taskServer = null) {\n-    console.log(`🔌 [${WINDOW_ID}] 确保WebSocket连接`)\n-\n-    if (taskServer) {\n-      console.log(`🎯 [${WINDOW_ID}] 指定任务服务器: ${taskServer}`)\n-\n-      // 🔧 关键修复：如果指定了任务服务器，确保WebSocket连接到正确服务器\n-      await this.ensureWebSocketServerConsistency(taskServer)\n-      return true\n+  // 锁定服务器\n+  _lockServer(serverUrl) {\n+    if (!this.lockedServer) {\n+      this.lockedServer = serverUrl\n+      this.lockTimestamp = Date.now()\n+      console.log(`🔒 [${WINDOW_ID}] 锁定服务器: ${serverUrl}`)\n     }\n-\n-    // 如果已连接，检查服务器一致性\n-    if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN && this.isWsConnected) {\n-      console.log(`✅ [${WINDOW_ID}] WebSocket已连接`)\n-\n-      // 尝试锁定服务器，但失败不影响继续使用\n-      const currentLock = this.getWindowServerLock()\n-      if (!currentLock) {\n-        try {\n-          // 这里需要外部提供 getApiBaseUrl 函数\n-          console.log(`🔒 [${WINDOW_ID}] 需要补充锁定服务器，但缺少 getApiBaseUrl 函数`)\n-        } catch (error) {\n-          console.warn(`⚠️ [${WINDOW_ID}] 服务器锁定失败，但继续使用连接:`, error.message)\n-        }\n-      } else {\n-        console.log(`🔒 [${WINDOW_ID}] 服务器已锁定: ${currentLock.server}`)\n-\n-        // 🔧 验证WebSocket连接与锁定服务器的一致性\n-        const wsServer = this.currentWebSocketServer\n-        if (wsServer && wsServer !== currentLock.server) {\n-          console.log(`🔄 [${WINDOW_ID}] WebSocket服务器与锁定服务器不一致，重新连接`)\n-          console.log(`   WebSocket服务器: ${wsServer}`)\n-          console.log(`   锁定服务器: ${currentLock.server}`)\n-\n-          // 重新连接到锁定的服务器\n-          await this.initializeWebSocket(currentLock.server)\n-        }\n-      }\n-      return true\n-    }\n-\n-    // 需要建立新连接\n-    console.log(`🔄 [${WINDOW_ID}] 建立新的WebSocket连接`)\n-\n-    try {\n-      await this.initializeWebSocket()\n-\n-      // 给连接一些时间稳定\n-      await new Promise(resolve => setTimeout(resolve, 500))\n-\n-      if (!this.isWsConnected) {\n-        console.warn(`⚠️ [${WINDOW_ID}] WebSocket连接状态异常，但尝试继续`)\n-      }\n-\n-      console.log(`✅ [${WINDOW_ID}] WebSocket连接完成`)\n-      return true\n-\n-    } catch (error) {\n-      console.warn(`⚠️ [${WINDOW_ID}] WebSocket连接失败，但不阻止操作:`, error.message)\n-      // 🔧 关键改进：不抛出错误，允许降级使用\n-      return false\n-    }\n   }\n \n-  // 🔧 新增：手动重置WebSocket服务器锁定的功能\n-  resetWebSocketServer(force = false) {\n-    const currentLock = this.getWindowServerLock()\n-    console.log('🔄 手动重置WebSocket服务器锁定')\n-    console.log('🔓 清除服务器锁定:', currentLock?.server || '无')\n-\n-    if (!force && this.windowTasks.size > 0) {\n-      console.log(`⚠️ 有 ${this.windowTasks.size} 个待处理任务，建议等待完成后再重置`)\n-      console.log('💡 如需强制重置，请调用: resetWebSocketServer(true)')\n-      return false\n+  // 检查解锁条件\n+  _checkUnlock() {\n+    if (this.tasks.size === 0 && this.lockedServer) {\n+      console.log(`🔓 [${WINDOW_ID}] 解锁服务器: ${this.lockedServer}`)\n+      this.lockedServer = null\n+      this.lockTimestamp = null\n     }\n-\n-    // 清除服务器锁定\n-    this.unlockServerForWindow()\n-\n-    // 关闭现有WebSocket连接\n-    if (this.wsConnection) {\n-      console.log('🔌 关闭现有WebSocket连接')\n-      this.wsConnection.close(1000, '手动重置服务器')\n-      this.wsConnection = null\n-      this.isWsConnected = false\n-    }\n-\n-    // 清理所有待处理任务（如果强制重置）\n-    if (force && this.windowTasks.size > 0) {\n-      console.log(`🧹 强制清理 ${this.windowTasks.size} 个待处理任务`)\n-      const taskIds = Array.from(this.windowTasks.keys())\n-      for (const promptId of taskIds) {\n-        const task = this.windowTasks.get(promptId)\n-        if (task && task.onError) {\n-          task.onError('WebSocket服务器已强制重置')\n-        }\n-        this.windowTasks.delete(promptId)\n-      }\n-    }\n-\n-    console.log('✅ WebSocket服务器重置完成')\n-    return true\n   }\n \n-  // 🔧 新增：获取当前WebSocket服务器状态的函数（窗口隔离版本）\n-  getWebSocketServerStatus() {\n-    return {\n-      windowId: WINDOW_ID,\n-      clientId: WINDOW_CLIENT_ID,\n-      isConnected: this.isWsConnected,\n-      lockedServer: this.getWindowServerLock()?.server,\n-      lockTimestamp: this.getWindowServerLock()?.timestamp,\n-      lockDuration: this.getWindowServerLock()?.timestamp ? Date.now() - this.getWindowServerLock().timestamp : null,\n-      pendingTasksCount: this.windowTasks.size,\n-      connectionState: this.wsConnection?.readyState || 'CLOSED'\n-    }\n-  }\n-\n-  // ==================== WebSocket 消息处理方法 ====================\n-\n-  // 🔥 防抖机制：避免频繁的进度回调触发递归更新\n-  safeProgressCallback(promptId, task, message, percent) {\n-    if (!task.onProgress) return\n-\n-    // 防抖：同一任务的进度回调间隔至少100ms\n-    const lastCallTime = this.progressCallbackDebounce.get(promptId) || 0\n-    const now = Date.now()\n-\n-    if (now - lastCallTime < 100) {\n-      console.log(`🚫 [${WINDOW_ID}] 进度回调防抖: ${promptId} (${percent}%)`)\n-      return\n-    }\n-\n-    this.progressCallbackDebounce.set(promptId, now)\n-\n+  // 提交任务 - 基于官方样例第13-17行\n+  async submitTask(workflow, promptId, callbacks = {}) {\n     try {\n-      // 🔧 使用setTimeout(0)确保回调在下一个事件循环中执行（浏览器兼容）\n-      setTimeout(() => {\n-        task.onProgress(message, percent)\n-      }, 0)\n-    } catch (error) {\n-      console.error(`❌ [${WINDOW_ID}] 进度回调执行失败: ${promptId}`, error.message)\n-    }\n-  }\n-\n-  // 🔥 主要的WebSocket消息处理函数 - 重构版本（窗口隔离版本）\n-  handleWebSocketMessage(message) {\n-    try {\n-      const { type, data } = message\n-\n-      // 🔥 简化消息过滤：如果找到任务就处理，不严格限制窗口归属\n-      if (data && data.prompt_id) {\n-        const task = this.getWindowTask(data.prompt_id)\n-        if (!task) {\n-          // 任务不存在，可能是其他窗口的消息，静默忽略\n-          return\n-        }\n-\n-        // 🔥 验证消息来源服务器一致性\n-        const currentLock = this.getWindowServerLock()\n-        if (currentLock && task.executionServer && task.executionServer !== currentLock.server) {\n-          console.warn(`⚠️ [${WINDOW_ID}] 跨服务器消息检测: 任务在 ${task.executionServer}, 当前锁定 ${currentLock.server}`)\n-          // 仍然处理消息，但记录警告以便调试\n-        }\n-\n-        // 🔥 记录消息处理日志（用于跨服务器调试）\n-        console.log(`📨 [${WINDOW_ID}] 处理消息: ${type} (prompt_id: ${data.prompt_id}, 服务器: ${task.executionServer || '未知'})`)\n+      // 选择服务器\n+      const serverUrl = this.lockedServer || await this._selectBestServer()\n+      \n+      // 连接到服务器\n+      await this.connectToServer(serverUrl)\n+      \n+      // 锁定服务器\n+      this._lockServer(serverUrl)\n+      \n+      // 注册任务\n+      this.tasks.set(promptId, {\n+        ...callbacks,\n+        server: serverUrl,\n+        startTime: Date.now()\n+      })\n+      \n+      // 提交工作流 - 基于官方样例第14-17行\n+      const requestBody = {\n+        prompt: workflow,\n+        client_id: CLIENT_ID,\n+        prompt_id: promptId\n       }\n-\n-      // 🔥 记录所有消息类型用于调试\n-      if (type !== 'status') {\n-        console.log(`📨 [OFFICIAL] 收到消息: ${type}`, data)\n+      \n+      const response = await fetch(`${serverUrl}/api/prompt`, {\n+        method: 'POST',\n+        headers: { 'Content-Type': 'application/json' },\n+        body: JSON.stringify(requestBody)\n+      })\n+      \n+      if (!response.ok) {\n+        throw new Error(`提交失败: ${response.status}`)\n       }\n-\n-      // 根据官方WebSocket API文档处理所有标准消息类型\n-      switch (type) {\n-        case 'status':\n-          // 服务器状态和队列信息\n-          this.handleStatusMessage(data)\n-          break\n-\n-        case 'execution_start':\n-          // 任务开始执行 - 官方标准状态检测\n-          this.handleExecutionStartMessage(data)\n-          break\n-\n-        case 'executing':\n-          // 节点执行状态 - 官方标准完成检测\n-          this.handleExecutingMessage(data)\n-          break\n-\n-        case 'progress':\n-          // 节点执行进度\n-          this.handleProgressMessage(data)\n-          break\n-\n-        case 'executed':\n-          // 节点执行完成\n-          this.handleExecutedMessage(data)\n-          break\n-\n-        case 'execution_cached':\n-          // 节点缓存命中\n-          this.handleExecutionCachedMessage(data)\n-          break\n-\n-        case 'execution_error':\n-          // 执行错误\n-          this.handleExecutionErrorMessage(data)\n-          break\n-\n-        case 'execution_interrupted':\n-          // 执行中断\n-          this.handleExecutionInterruptedMessage(data)\n-          break\n-\n-        default:\n-          // 记录未知消息类型用于调试\n-          console.log(`🔍 [OFFICIAL] 未知消息类型: ${type}`, data)\n-      }\n-\n+      \n+      console.log(`✅ [${WINDOW_ID}] 任务提交成功: ${promptId}`)\n+      return promptId\n+      \n     } catch (error) {\n-      console.error('❌ [OFFICIAL] 消息处理失败:', error.message, message)\n+      // 清理失败的任务\n+      this.tasks.delete(promptId)\n+      this._checkUnlock()\n+      throw error\n     }\n   }\n \n-  // 🔥 处理服务器状态消息 - 重构版本（窗口隔离版本）\n-  handleStatusMessage(data) {\n-    if (!data || !data.status) {\n-      return\n-    }\n-\n-    // 🔧 只记录队列变化，不处理具体任务（避免跨窗口干扰）\n-    const queueRunning = data.status.exec_info?.queue_remaining || 0\n-    if (queueRunning > 0) {\n-      console.log(`📊 [${WINDOW_ID}] 服务器队列状态: ${queueRunning} 个任务等待执行`)\n-    }\n-\n-    // 🔧 触发状态更新事件供Vue组件监听\n-    if (typeof window !== 'undefined') {\n-      window.dispatchEvent(new CustomEvent('comfyui-queue-status', {\n-        detail: {\n-          queueRemaining: queueRunning,\n-          windowId: WINDOW_ID,\n-          timestamp: Date.now()\n-        }\n-      }))\n-    }\n-  }\n-\n-  // 🔥 处理任务开始执行消息 - 重构版本（窗口隔离版本）\n-  handleExecutionStartMessage(data) {\n-    if (!data || !data.prompt_id) {\n-      return\n-    }\n-\n-    const promptId = data.prompt_id\n-\n-    // 🔧 只处理属于当前窗口的任务\n-    const task = this.getWindowTask(promptId)\n-    if (!task) {\n-      console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的执行开始消息: ${promptId}`)\n-      return\n-    }\n-\n-    console.log(`🚀 [${WINDOW_ID}] 任务开始执行: ${promptId}`)\n-\n-    // 原子性状态更新：waiting → executing\n-    this.updateTaskStatus(promptId, this.TASK_STATUS.EXECUTING, {\n-      executionStartTime: Date.now()\n-    })\n-\n-    // 🔧 使用安全进度回调\n-    this.safeProgressCallback(promptId, task, '任务开始执行', 10)\n-  }\n-\n-  // 🔥 处理节点执行进度消息 - 重构版本（窗口隔离版本）\n-  handleProgressMessage(data) {\n-    if (!data || !data.prompt_id || typeof data.value !== 'number' || typeof data.max !== 'number') {\n-      return\n-    }\n-\n-    const promptId = data.prompt_id\n-\n-    // 🔧 只处理属于当前窗口的任务\n-    const task = this.getWindowTask(promptId)\n-    if (!task || task.status !== this.TASK_STATUS.EXECUTING) {\n+  // 等待任务完成 - 基于官方样例第33-40行的 while True 逻辑\n+  async waitForCompletion(promptId, callbacks = {}) {\n+    return new Promise((resolve, reject) => {\n+      const task = this.tasks.get(promptId)\n       if (!task) {\n-        console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的进度消息: ${promptId}`)\n-      }\n-      return\n-    }\n-\n-    // 计算进度百分比\n-    const percent = Math.round((data.value / data.max) * 100)\n-    const nodeInfo = data.node ? ` (节点: ${data.node})` : ''\n-\n-    console.log(`📈 [${WINDOW_ID}] 任务进度: ${promptId} - ${percent}%${nodeInfo}`)\n-\n-    // 🔧 使用安全进度回调\n-    this.safeProgressCallback(promptId, task, `执行进度: ${percent}%${nodeInfo}`, Math.min(percent + 10, 90))\n-  }\n-\n-  // 🔥 处理节点执行完成消息 - 重构版本（窗口隔离版本）\n-  handleExecutedMessage(data) {\n-    if (!data || !data.prompt_id || !data.node) {\n-      return\n-    }\n-\n-    const promptId = data.prompt_id\n-\n-    // 🔧 只处理属于当前窗口的任务\n-    const task = this.getWindowTask(promptId)\n-    if (!task || task.status !== this.TASK_STATUS.EXECUTING) {\n-      if (!task) {\n-        console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的节点完成消息: ${promptId}`)\n-      }\n-      return\n-    }\n-\n-    console.log(`✅ [${WINDOW_ID}] 节点完成: ${data.node} (任务: ${promptId})`)\n-\n-    // 记录完成的节点\n-    if (!task.completedNodes) {\n-      task.completedNodes = []\n-    }\n-    task.completedNodes.push(data.node)\n-\n-    // 🔧 使用安全进度回调\n-    this.safeProgressCallback(promptId, task, `节点 ${data.node} 完成`, 60)\n-  }\n-\n-  // 🔥 处理节点执行状态消息 - 官方标准完成检测（窗口隔离版本）\n-  handleExecutingMessage(data) {\n-    if (!data || !data.prompt_id) {\n-      return\n-    }\n-\n-    const promptId = data.prompt_id\n-\n-    // 🔧 只处理属于当前窗口的任务\n-    const task = this.getWindowTask(promptId)\n-    if (!task) {\n-      console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的执行状态消息: ${promptId}`)\n-      return\n-    }\n-\n-    // 官方标准双重条件检测：data.node === null && data.prompt_id === promptId\n-    if (data.node === null && data.prompt_id === promptId) {\n-      console.log(`🎯 [${WINDOW_ID}] 任务执行完成: ${promptId}`)\n-\n-      // 原子性状态更新：executing → completed\n-      this.updateTaskStatus(promptId, this.TASK_STATUS.COMPLETED, {\n-        completionTime: Date.now()\n-      })\n-\n-      // 立即处理任务完成\n-      this.handleTaskCompletion(promptId)\n-    } else if (data.node) {\n-      // 记录正在执行的节点\n-      console.log(`🔄 [${WINDOW_ID}] 正在执行节点: ${data.node} (任务: ${promptId})`)\n-\n-      // 更新任务的当前执行节点\n-      if (task) {\n-        task.currentNode = data.node\n-        this.safeProgressCallback(promptId, task, `正在执行节点: ${data.node}`, 30)\n-      }\n-    }\n-  }\n-\n-  // 🔥 处理任务完成的核心函数 - 修复版本（恢复结果获取逻辑）\n-  async handleTaskCompletion(promptId) {\n-    try {\n-      const task = this.getWindowTask(promptId)\n-      if (!task) {\n-        console.warn(`⚠️ [${WINDOW_ID}] 任务完成处理失败: 任务不存在 ${promptId}`)\n+        reject(new Error(`任务不存在: ${promptId}`))\n         return\n       }\n-\n-      console.log(`🎉 [${WINDOW_ID}] 任务完成处理开始: ${promptId}`)\n-\n-      // 🔧 使用安全进度回调\n-      this.safeProgressCallback(promptId, task, '任务执行完成', 100)\n-\n-      // 🔧 获取任务历史和结果（恢复重构前的逻辑）\n-      let taskResult = null\n-      try {\n-        // 动态导入 comfyui.js 中的函数\n-        const comfyuiModule = await import('./comfyui.js')\n-        const { getTaskHistory, extractTaskResults } = comfyuiModule\n-\n-        console.log(`📊 [${WINDOW_ID}] 开始获取任务结果: ${promptId}`)\n-        const history = await getTaskHistory()\n-        taskResult = await extractTaskResults(history, promptId)\n-        console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`, taskResult)\n-      } catch (error) {\n-        console.error(`❌ [${WINDOW_ID}] 任务结果获取失败: ${promptId}`, error)\n-        // 继续执行，但结果为null\n-        taskResult = null\n-      }\n-\n-      // 立即清理任务\n-      this.removeWindowTask(promptId)\n-\n-      // 🔧 检查是否可以解锁服务器\n-      this.checkServerUnlockCondition()\n-\n-      // 调用成功回调，传递完整的任务结果（修复：使用onComplete而不是onSuccess）\n-      if (task.onComplete) {\n-        // 🔧 使用setTimeout(0)确保成功回调立即执行（浏览器兼容）\n-        setTimeout(() => {\n-          task.onComplete(taskResult) // ✅ 修复：传递完整的任务结果而不是只传递promptId\n-        }, 0)\n-      }\n-\n-      console.log(`✅ [${WINDOW_ID}] 任务完成处理结束: ${promptId}`)\n-\n-    } catch (error) {\n-      console.error(`❌ [${WINDOW_ID}] 任务完成处理失败: ${promptId}`, error.message)\n-\n-      // 立即清理任务并调用错误回调\n-      this.removeWindowTask(promptId)\n-\n-      // 🔧 检查是否可以解锁服务器\n-      this.checkServerUnlockCondition()\n-\n-      const task = this.getWindowTask(promptId)\n-      if (task && task.onError) {\n-        // 🔧 使用setTimeout(0)确保错误回调立即执行（浏览器兼容）\n-        setTimeout(() => {\n-          task.onError(error.message)\n-        }, 0)\n-      }\n-    }\n-  }\n-\n-  // 🔥 处理节点缓存命中消息\n-  handleExecutionCachedMessage(data) {\n-    if (!data || !data.prompt_id) {\n-      return\n-    }\n-\n-    const promptId = data.prompt_id\n-    const task = this.getWindowTask(promptId)\n-    if (!task) {\n-      console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的缓存消息: ${promptId}`)\n-      return\n-    }\n-\n-    console.log(`💾 [${WINDOW_ID}] 节点缓存命中: ${promptId}`)\n-    this.safeProgressCallback(promptId, task, '使用缓存结果', 80)\n-  }\n-\n-  // 🔥 处理执行错误消息\n-  handleExecutionErrorMessage(data) {\n-    if (!data || !data.prompt_id) {\n-      return\n-    }\n-\n-    const promptId = data.prompt_id\n-    const task = this.getWindowTask(promptId)\n-    if (!task) {\n-      console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的错误消息: ${promptId}`)\n-      return\n-    }\n-\n-    console.error(`❌ [${WINDOW_ID}] 任务执行错误: ${promptId}`, data)\n-\n-    // 更新任务状态为错误\n-    this.updateTaskStatus(promptId, this.TASK_STATUS.ERROR, {\n-      errorTime: Date.now(),\n-      errorData: data\n+      \n+      // 更新回调\n+      task.onComplete = resolve\n+      task.onError = reject\n+      task.onProgress = callbacks.onProgress || (() => {})\n+      \n+      console.log(`⏳ [${WINDOW_ID}] 等待任务完成: ${promptId}`)\n     })\n-\n-    // 清理任务并调用错误回调\n-    this.removeWindowTask(promptId)\n-    this.checkServerUnlockCondition()\n-\n-    if (task.onError) {\n-      setTimeout(() => {\n-        task.onError(data.exception_message || '任务执行错误')\n-      }, 0)\n-    }\n   }\n \n-  // 🔥 处理执行中断消息\n-  handleExecutionInterruptedMessage(data) {\n-    if (!data || !data.prompt_id) {\n-      return\n+  // 获取状态信息\n+  getStatus() {\n+    return {\n+      windowId: WINDOW_ID,\n+      clientId: CLIENT_ID,\n+      connected: this.isConnected,\n+      server: this.currentServer,\n+      lockedServer: this.lockedServer,\n+      taskCount: this.tasks.size\n     }\n-\n-    const promptId = data.prompt_id\n-    const task = this.getWindowTask(promptId)\n-    if (!task) {\n-      console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的中断消息: ${promptId}`)\n-      return\n-    }\n-\n-    console.warn(`⚠️ [${WINDOW_ID}] 任务执行中断: ${promptId}`)\n-\n-    // 更新任务状态为中断\n-    this.updateTaskStatus(promptId, this.TASK_STATUS.INTERRUPTED, {\n-      interruptTime: Date.now()\n-    })\n-\n-    // 清理任务并调用错误回调\n-    this.removeWindowTask(promptId)\n-    this.checkServerUnlockCondition()\n-\n-    if (task.onError) {\n-      setTimeout(() => {\n-        task.onError('任务执行被中断')\n-      }, 0)\n-    }\n   }\n-\n-  // 🔧 辅助方法：显示通知\n-  _showNotification(message, type = 'info') {\n-    const timestamp = new Date().toLocaleTimeString()\n-    const typeEmoji = {\n-      'success': '✅',\n-      'error': '❌',\n-      'warning': '⚠️',\n-      'info': 'ℹ️'\n-    }\n-\n-    console.log(`${typeEmoji[type] || 'ℹ️'} [${timestamp}] ${message}`)\n-\n-    // 触发自定义事件供Vue组件监听\n-    if (typeof window !== 'undefined') {\n-      window.dispatchEvent(new CustomEvent('comfyui-status', {\n-        detail: { message, type, timestamp }\n-      }))\n-    }\n-  }\n-\n-  // 🔧 辅助方法：记录服务器一致性信息\n-  _logServerConsistency(context) {\n-    const currentLock = this.getWindowServerLock()\n-    const wsServer = this.currentWebSocketServer\n-\n-    console.log(`🔍 [${WINDOW_ID}] 服务器一致性检查 (${context}):`)\n-    console.log(`   - 锁定服务器: ${currentLock?.server || '无'}`)\n-    console.log(`   - WebSocket服务器: ${wsServer || '无'}`)\n-    console.log(`   - 连接状态: ${this.isWsConnected ? '已连接' : '未连接'}`)\n-  }\n }\n-\n-// 监听其他窗口的任务状态（用于调试）\n-if (typeof window !== 'undefined') {\n-  window.addEventListener('storage', (e) => {\n-    if (e.key && e.key.startsWith('comfyui_task_')) {\n-      try {\n-        const message = JSON.parse(e.newValue)\n-        if (message.windowId !== WINDOW_ID) {\n-          console.log(`📡 [${WINDOW_ID}] 收到其他窗口任务状态: ${message.promptId} -> ${message.status} (来自窗口: ${message.windowId})`)\n-        }\n-      } catch (error) {\n-        // 忽略解析错误\n-      }\n-    }\n-  })\n-}\n-\n-// 创建全局实例\n-const webSocketManager = new WebSocketManager()\n-\n-// 🔧 暴露核心管理函数到全局，用于故障恢复\n-if (typeof window !== 'undefined') {\n-  window.resetWebSocketServer = webSocketManager.resetWebSocketServer.bind(webSocketManager)\n-  window.getWebSocketServerStatus = webSocketManager.getWebSocketServerStatus.bind(webSocketManager)\n-  window.pendingTasks = webSocketManager.windowTasks // 🔧 暴露窗口级别的任务队列\n-\n-  // 🔧 动态锁定管理函数\n-  window.forceUnlockServerForWindow = webSocketManager.forceUnlockServerForWindow.bind(webSocketManager)\n-\n-  console.log(`🔧 [${WINDOW_ID}] 核心管理函数已暴露到全局`)\n-}\n-\n-// 导出实例和相关常量\n-export default webSocketManager\n-export { WINDOW_ID, WINDOW_CLIENT_ID }\n"
                },
                {
                    "date": 1753513103231,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,16 +24,16 @@\n     // WebSocket 连接\n     this.ws = null\n     this.isConnected = false\n     this.currentServer = null\n-    \n+\n     // 任务管理 - 只保留当前窗口的任务\n     this.tasks = new Map() // promptId -> { onComplete, onError, onProgress, server }\n-    \n+\n     // 服务器锁定 - 简化为窗口级别\n     this.lockedServer = null\n     this.lockTimestamp = null\n-    \n+\n     // 初始化窗口事件\n     this._initWindowEvents()\n   }\n \n@@ -70,9 +70,9 @@\n \n     try {\n       const wsUrl = `${serverUrl.replace('http', 'ws')}/ws?clientId=${CLIENT_ID}`\n       console.log(`🔌 [${WINDOW_ID}] 连接到: ${wsUrl}`)\n-      \n+\n       this.ws = new WebSocket(wsUrl)\n       this.currentServer = serverUrl\n \n       return new Promise((resolve, reject) => {\n@@ -121,9 +121,9 @@\n \n     // 只处理 executing 消息，检测任务完成\n     if (type === 'executing' && data) {\n       const { node, prompt_id } = data\n-      \n+\n       // 任务完成检测：node 为 null 表示执行完成\n       if (node === null && prompt_id) {\n         console.log(`🎉 [${WINDOW_ID}] 任务完成: ${prompt_id}`)\n         this._handleTaskCompletion(prompt_id)\n@@ -162,14 +162,14 @@\n \n     try {\n       // 获取任务历史 - 基于官方样例第47行\n       const history = await this._getHistory(promptId)\n-      \n+\n       // 提取结果 - 基于官方样例第48-56行\n       const result = this._extractResults(history, promptId)\n-      \n+\n       console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`)\n-      \n+\n       // 调用完成回调\n       if (task.onComplete) {\n         task.onComplete(result)\n       }\n@@ -180,9 +180,9 @@\n       }\n     } finally {\n       // 清理任务\n       this.tasks.delete(promptId)\n-      \n+\n       // 检查是否需要解锁服务器\n       this._checkUnlock()\n     }\n   }\n@@ -219,9 +219,9 @@\n       if (nodeOutput.images) {\n         results[nodeId] = nodeOutput.images\n       }\n     }\n-    \n+\n     return results\n   }\n \n   // 选择最佳服务器\n@@ -258,42 +258,42 @@\n   async submitTask(workflow, promptId, callbacks = {}) {\n     try {\n       // 选择服务器\n       const serverUrl = this.lockedServer || await this._selectBestServer()\n-      \n+\n       // 连接到服务器\n       await this.connectToServer(serverUrl)\n-      \n+\n       // 锁定服务器\n       this._lockServer(serverUrl)\n-      \n+\n       // 注册任务\n       this.tasks.set(promptId, {\n         ...callbacks,\n         server: serverUrl,\n         startTime: Date.now()\n       })\n-      \n+\n       // 提交工作流 - 基于官方样例第14-17行\n       const requestBody = {\n         prompt: workflow,\n         client_id: CLIENT_ID,\n         prompt_id: promptId\n       }\n-      \n+\n       const response = await fetch(`${serverUrl}/api/prompt`, {\n         method: 'POST',\n         headers: { 'Content-Type': 'application/json' },\n         body: JSON.stringify(requestBody)\n       })\n-      \n+\n       if (!response.ok) {\n         throw new Error(`提交失败: ${response.status}`)\n       }\n-      \n+\n       console.log(`✅ [${WINDOW_ID}] 任务提交成功: ${promptId}`)\n       return promptId\n-      \n+\n     } catch (error) {\n       // 清理失败的任务\n       this.tasks.delete(promptId)\n       this._checkUnlock()\n@@ -308,14 +308,14 @@\n       if (!task) {\n         reject(new Error(`任务不存在: ${promptId}`))\n         return\n       }\n-      \n+\n       // 更新回调\n       task.onComplete = resolve\n       task.onError = reject\n       task.onProgress = callbacks.onProgress || (() => {})\n-      \n+\n       console.log(`⏳ [${WINDOW_ID}] 等待任务完成: ${promptId}`)\n     })\n   }\n \n@@ -329,5 +329,105 @@\n       lockedServer: this.lockedServer,\n       taskCount: this.tasks.size\n     }\n   }\n+\n+  // ==================== 兼容性方法 ====================\n+\n+  // 兼容原有接口\n+  async initializeWebSocket(targetServer = null) {\n+    const serverUrl = targetServer || this.lockedServer || await this._selectBestServer()\n+    return await this.connectToServer(serverUrl)\n+  }\n+\n+  async ensureWebSocketConnection(taskServer = null) {\n+    const serverUrl = taskServer || this.currentServer\n+    if (serverUrl && this.isConnected && this.currentServer === serverUrl) {\n+      return true\n+    }\n+    return await this.connectToServer(serverUrl || await this._selectBestServer())\n+  }\n+\n+  // 任务管理兼容方法\n+  registerWindowTask(promptId, task) {\n+    this.tasks.set(promptId, task)\n+    console.log(`📝 [${WINDOW_ID}] 任务已注册: ${promptId}`)\n+  }\n+\n+  getWindowTask(promptId) {\n+    return this.tasks.get(promptId)\n+  }\n+\n+  removeWindowTask(promptId) {\n+    const removed = this.tasks.delete(promptId)\n+    if (removed) {\n+      console.log(`🗑️ [${WINDOW_ID}] 任务已移除: ${promptId}`)\n+      this._checkUnlock()\n+    }\n+    return removed\n+  }\n+\n+  // 服务器锁定兼容方法\n+  lockServerForWindow(serverUrl) {\n+    this._lockServer(serverUrl)\n+  }\n+\n+  unlockServerForWindow() {\n+    console.log(`🔓 [${WINDOW_ID}] 手动解锁服务器: ${this.lockedServer}`)\n+    this.lockedServer = null\n+    this.lockTimestamp = null\n+  }\n+\n+  getWindowServerLock() {\n+    if (this.lockedServer) {\n+      return {\n+        server: this.lockedServer,\n+        timestamp: this.lockTimestamp,\n+        windowId: WINDOW_ID\n+      }\n+    }\n+    return null\n+  }\n+\n+  // 任务完成处理 - 供外部调用\n+  async handleTaskCompletion(promptId) {\n+    await this._handleTaskCompletion(promptId)\n+  }\n+\n+  // 进度回调安全包装\n+  safeProgressCallback(promptId, task, message, progress) {\n+    if (task && task.onProgress) {\n+      try {\n+        task.onProgress(message, progress)\n+      } catch (error) {\n+        console.error(`❌ [${WINDOW_ID}] 进度回调错误:`, error)\n+      }\n+    }\n+  }\n+\n+  // 获取任务绑定的服务器\n+  getTaskBoundServer(promptId) {\n+    const task = this.tasks.get(promptId)\n+    return task ? task.server : null\n+  }\n+\n+  // 检查服务器解锁条件\n+  checkServerUnlockCondition() {\n+    this._checkUnlock()\n+  }\n+\n+  // 窗口任务属性（兼容性）\n+  get windowTasks() {\n+    return this.tasks\n+  }\n+\n+  // 任务状态枚举（兼容性）\n+  get TASK_STATUS() {\n+    return {\n+      WAITING: 'waiting',\n+      EXECUTING: 'executing',\n+      COMPLETED: 'completed',\n+      ERROR: 'error',\n+      INTERRUPTED: 'interrupted'\n+    }\n+  }\n }\n"
                },
                {
                    "date": 1753513146556,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -430,4 +430,23 @@\n       INTERRUPTED: 'interrupted'\n     }\n   }\n }\n+\n+// 创建全局实例\n+const webSocketManager = new SimpleWebSocketManager()\n+\n+// 全局兼容性设置\n+if (typeof window !== 'undefined') {\n+  // 保持原有的全局变量兼容性\n+  window.pendingTasks = webSocketManager.tasks\n+\n+  // 兼容原有的全局函数\n+  window.getWindowTask = webSocketManager.getWindowTask.bind(webSocketManager)\n+  window.removeWindowTask = webSocketManager.removeWindowTask.bind(webSocketManager)\n+\n+  console.log(`🔧 [${WINDOW_ID}] 兼容性接口已设置`)\n+}\n+\n+// 导出\n+export default webSocketManager\n+export { WINDOW_ID, CLIENT_ID }\n"
                },
                {
                    "date": 1753513209404,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -329,9 +329,8 @@\n       lockedServer: this.lockedServer,\n       taskCount: this.tasks.size\n     }\n   }\n-\n   // ==================== 兼容性方法 ====================\n \n   // 兼容原有接口\n   async initializeWebSocket(targetServer = null) {\n@@ -429,8 +428,21 @@\n       ERROR: 'error',\n       INTERRUPTED: 'interrupted'\n     }\n   }\n+\n+  // 兼容性属性\n+  get wsConnection() {\n+    return this.ws\n+  }\n+\n+  get isWsConnected() {\n+    return this.isConnected\n+  }\n+\n+  get currentWebSocketServer() {\n+    return this.currentServer\n+  }\n }\n \n // 创建全局实例\n const webSocketManager = new SimpleWebSocketManager()\n@@ -448,5 +460,5 @@\n }\n \n // 导出\n export default webSocketManager\n-export { WINDOW_ID, CLIENT_ID }\n+export { WINDOW_ID, CLIENT_ID, CLIENT_ID as WINDOW_CLIENT_ID }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753515700320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -166,10 +166,17 @@\n \n       // 提取结果 - 基于官方样例第48-56行\n       const result = this._extractResults(history, promptId)\n \n-      console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`)\n+      // 🔧 关键修复：保存任务执行服务器信息到结果中\n+      if (result && task.server) {\n+        result.executionServer = task.server\n+        result.promptId = promptId\n+        console.log(`💾 [${WINDOW_ID}] 保存任务执行服务器信息: ${task.server}`)\n+      }\n \n+      console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`, result)\n+\n       // 调用完成回调\n       if (task.onComplete) {\n         task.onComplete(result)\n       }\n"
                },
                {
                    "date": 1753515791651,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -173,9 +173,9 @@\n         result.promptId = promptId\n         console.log(`💾 [${WINDOW_ID}] 保存任务执行服务器信息: ${task.server}`)\n       }\n \n-      console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`, result)\n+      console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`)\n \n       // 调用完成回调\n       if (task.onComplete) {\n         task.onComplete(result)\n"
                },
                {
                    "date": 1753515899857,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -173,9 +173,9 @@\n         result.promptId = promptId\n         console.log(`💾 [${WINDOW_ID}] 保存任务执行服务器信息: ${task.server}`)\n       }\n \n-      console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`)\n+      console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`, result)\n \n       // 调用完成回调\n       if (task.onComplete) {\n         task.onComplete(result)\n"
                },
                {
                    "date": 1753515942173,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -173,9 +173,9 @@\n         result.promptId = promptId\n         console.log(`💾 [${WINDOW_ID}] 保存任务执行服务器信息: ${task.server}`)\n       }\n \n-      console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`, result)\n+      console.log(`✅ [${WINDOW_ID}] 任务结果获取成功: ${promptId}`)\n \n       // 调用完成回调\n       if (task.onComplete) {\n         task.onComplete(result)\n@@ -212,23 +212,25 @@\n     }\n     return await response.json()\n   }\n \n-  // 提取结果 - 基于官方样例第48-56行\n+  // 提取结果 - 基于官方样例第48-56行（增强版）\n   _extractResults(history, promptId) {\n     const taskData = history[promptId]\n     if (!taskData || !taskData.outputs) {\n-      throw new Error(`任务 ${promptId} 没有输出数据`)\n+      console.warn(`⚠️ [${WINDOW_ID}] 任务 ${promptId} 没有输出数据，返回空结果`)\n+      return {}\n     }\n \n     const results = {}\n     for (const nodeId in taskData.outputs) {\n       const nodeOutput = taskData.outputs[nodeId]\n-      if (nodeOutput.images) {\n-        results[nodeId] = nodeOutput.images\n-      }\n+      // 🔧 修复：保存所有输出数据，不仅仅是图片\n+      results[nodeId] = nodeOutput\n+      console.log(`📊 [${WINDOW_ID}] 提取节点 ${nodeId} 输出:`, nodeOutput)\n     }\n \n+    console.log(`📋 [${WINDOW_ID}] 完整结果结构:`, results)\n     return results\n   }\n \n   // 选择最佳服务器\n"
                },
                {
                    "date": 1753515953308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -212,14 +212,13 @@\n     }\n     return await response.json()\n   }\n \n-  // 提取结果 - 基于官方样例第48-56行（增强版）\n+  // 提取结果 - 基于官方样例第48-56行\n   _extractResults(history, promptId) {\n     const taskData = history[promptId]\n     if (!taskData || !taskData.outputs) {\n-      console.warn(`⚠️ [${WINDOW_ID}] 任务 ${promptId} 没有输出数据，返回空结果`)\n-      return {}\n+      throw new Error(`任务 ${promptId} 没有输出数据`)\n     }\n \n     const results = {}\n     for (const nodeId in taskData.outputs) {\n"
                },
                {
                    "date": 1753515962718,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -227,9 +227,8 @@\n       results[nodeId] = nodeOutput\n       console.log(`📊 [${WINDOW_ID}] 提取节点 ${nodeId} 输出:`, nodeOutput)\n     }\n \n-    console.log(`📋 [${WINDOW_ID}] 完整结果结构:`, results)\n     return results\n   }\n \n   // 选择最佳服务器\n"
                },
                {
                    "date": 1753515974605,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -212,13 +212,14 @@\n     }\n     return await response.json()\n   }\n \n-  // 提取结果 - 基于官方样例第48-56行\n+  // 提取结果 - 基于官方样例第48-56行（增强版）\n   _extractResults(history, promptId) {\n     const taskData = history[promptId]\n     if (!taskData || !taskData.outputs) {\n-      throw new Error(`任务 ${promptId} 没有输出数据`)\n+      console.warn(`⚠️ [${WINDOW_ID}] 任务 ${promptId} 没有输出数据，返回空结果`)\n+      return {}\n     }\n \n     const results = {}\n     for (const nodeId in taskData.outputs) {\n@@ -227,8 +228,9 @@\n       results[nodeId] = nodeOutput\n       console.log(`📊 [${WINDOW_ID}] 提取节点 ${nodeId} 输出:`, nodeOutput)\n     }\n \n+    console.log(`📋 [${WINDOW_ID}] 完整结果结构:`, results)\n     return results\n   }\n \n   // 选择最佳服务器\n"
                },
                {
                    "date": 1753516538264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -467,7 +467,9 @@\n \n   console.log(`🔧 [${WINDOW_ID}] 兼容性接口已设置`)\n }\n \n+\n+\n // 导出\n export default webSocketManager\n export { WINDOW_ID, CLIENT_ID, CLIENT_ID as WINDOW_CLIENT_ID }\n\\ No newline at end of file\n"
                }
            ],
            "date": 1753463557474,
            "name": "Commit-0",
            "content": "/**\n * 🔥 WebSocket连接管理器 - 独立的WebSocket服务\n *\n * 核心功能：\n * 1. WebSocket连接生命周期管理\n * 2. 多窗口隔离机制\n * 3. 服务器锁定与一致性保证\n * 4. 消息路由与事件分发\n * 5. 自动重连与健康检查\n *\n * 架构优势：\n * - 解耦WebSocket管理与业务逻辑\n * - 支持多种服务复用同一WebSocket连接\n * - 提供统一的连接管理策略\n * - 便于测试和维护\n */\n\nimport loadBalancer from './loadBalancer.js'\n\n// WebSocket连接状态枚举\nexport const WS_STATE = {\n  DISCONNECTED: 'disconnected',\n  CONNECTING: 'connecting',\n  CONNECTED: 'connected',\n  RECONNECTING: 'reconnecting',\n  FAILED: 'failed'\n}\n\n// 🔧 生成窗口唯一标识符\nfunction generateWindowId() {\n  return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n}\n\n// 🔧 生成增强的客户端ID\nfunction generateUniqueClientId() {\n  const baseId = 'abc1373d4ad648a3a81d0587fbe5534b'\n  const timestamp = Date.now()\n  const random = Math.random().toString(36).substr(2, 9)\n  const windowId = generateWindowId()\n  return `${baseId}_${timestamp}_${random}_${windowId}`\n}\n\nclass WebSocketManager {\n  constructor() {\n    // 窗口标识\n    this.windowId = generateWindowId()\n    this.clientId = generateUniqueClientId()\n\n    // 连接管理\n    this.connection = null\n    this.state = WS_STATE.DISCONNECTED\n    this.currentServer = null\n\n    // 服务器锁定机制（窗口级别）\n    this.lockedServer = null\n    this.lockTimestamp = null\n\n    // 事件管理\n    this.eventHandlers = new Map()\n    this.messageQueue = []\n\n    // 重连管理\n    this.reconnectAttempts = 0\n    this.maxReconnectAttempts = 5\n    this.reconnectDelay = 2000\n    this.reconnectTimer = null\n\n    // 健康检查\n    this.healthCheckInterval = null\n    this.lastHeartbeat = null\n    this.lastMessageTime = null\n\n    console.log(`🔌 WebSocketManager 初始化完成`)\n    console.log(`🪟 窗口ID: ${this.windowId}`)\n    console.log(`🔑 客户端ID: ${this.clientId}`)\n\n    // 设置窗口关闭清理\n    this.setupWindowCleanup()\n  }\n\n  /**\n   * 🔧 设置窗口关闭时的清理机制\n   */\n  setupWindowCleanup() {\n    window.addEventListener('beforeunload', () => {\n      console.log(`🚪 [${this.windowId}] 窗口即将关闭，执行WebSocket清理...`)\n      this.disconnect()\n      this.unlockServer()\n    })\n\n    // 页面可见性变化处理\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden) {\n        console.log(`👁️ [${this.windowId}] 窗口隐藏`)\n      } else {\n        console.log(`👁️ [${this.windowId}] 窗口重新可见`)\n        this.checkConnectionHealth()\n      }\n    })\n  }\n\n  /**\n   * 🔧 连接到指定服务器\n   */\n  async connect(serverUrl = null) {\n    if (this.state === WS_STATE.CONNECTING) {\n      console.log(`🔄 [${this.windowId}] WebSocket正在连接中，跳过重复连接`)\n      return false\n    }\n\n    try {\n      this.state = WS_STATE.CONNECTING\n\n      // 确定目标服务器\n      const targetServer = serverUrl || await this.getTargetServer()\n      if (!targetServer) {\n        throw new Error('无法获取可用的服务器')\n      }\n\n      // 锁定服务器\n      this.lockServer(targetServer)\n\n      // 建立WebSocket连接\n      await this.establishConnection(targetServer)\n\n      this.state = WS_STATE.CONNECTED\n      this.reconnectAttempts = 0\n      this.startHealthCheck()\n\n      console.log(`✅ [${this.windowId}] WebSocket连接成功: ${targetServer}`)\n      this.emit('connected', { server: targetServer, windowId: this.windowId })\n\n      return true\n\n    } catch (error) {\n      this.state = WS_STATE.FAILED\n      console.error(`❌ [${this.windowId}] WebSocket连接失败:`, error)\n      this.emit('error', { error, windowId: this.windowId })\n\n      // 启动重连\n      this.scheduleReconnect()\n      return false\n    }\n  }\n\n  /**\n   * 🔧 建立WebSocket连接\n   */\n  async establishConnection(serverUrl) {\n    return new Promise((resolve, reject) => {\n      const wsUrl = this.buildWebSocketUrl(serverUrl)\n      console.log(`🔗 [${this.windowId}] 建立WebSocket连接: ${wsUrl}`)\n\n      // 先进行HTTP连接测试\n      this.testHttpConnection(serverUrl)\n        .then(() => {\n          this.connection = new WebSocket(wsUrl)\n          this.currentServer = serverUrl\n\n          const timeout = setTimeout(() => {\n            reject(new Error('WebSocket连接超时'))\n          }, 10000)\n\n          this.connection.onopen = () => {\n            clearTimeout(timeout)\n            console.log(`🎉 [${this.windowId}] WebSocket连接已建立`)\n            resolve()\n          }\n\n          this.connection.onclose = (event) => {\n            clearTimeout(timeout)\n            this.handleConnectionClose(event)\n          }\n\n          this.connection.onerror = (error) => {\n            clearTimeout(timeout)\n            console.error(`❌ [${this.windowId}] WebSocket连接错误:`, error)\n            reject(error)\n          }\n\n          this.connection.onmessage = (event) => {\n            this.handleMessage(event)\n          }\n        })\n        .catch(reject)\n    })\n  }\n\n  /**\n   * 🔧 HTTP连接测试\n   */\n  async testHttpConnection(serverUrl) {\n    try {\n      const response = await fetch(`${serverUrl}/api/queue`, {\n        method: 'GET',\n        signal: AbortSignal.timeout(5000)\n      })\n      if (!response.ok) {\n        throw new Error(`服务器响应错误: ${response.status}`)\n      }\n      console.log(`✅ [${this.windowId}] HTTP连接测试通过: ${serverUrl}`)\n    } catch (error) {\n      throw new Error(`ComfyUI服务器不可达: ${error.message}`)\n    }\n  }\n\n  /**\n   * 🔧 构建WebSocket URL\n   */\n  buildWebSocketUrl(serverUrl) {\n    let wsUrl\n    if (serverUrl.startsWith('https://')) {\n      wsUrl = serverUrl.replace('https://', 'wss://')\n    } else {\n      wsUrl = serverUrl.replace('http://', 'ws://')\n    }\n    return `${wsUrl}/ws?clientId=${this.clientId}`\n  }\n\n  /**\n   * 🔧 消息处理\n   */\n  handleMessage(event) {\n    try {\n      this.lastMessageTime = Date.now()\n      const message = event.data\n\n      // 处理二进制消息\n      if (message instanceof ArrayBuffer || message instanceof Blob) {\n        this.emit('binary', { data: message, windowId: this.windowId })\n        return\n      }\n\n      // 处理文本消息\n      if (typeof message === 'string') {\n        const parsedMessage = JSON.parse(message)\n\n        // 添加窗口标识\n        const enrichedMessage = {\n          ...parsedMessage,\n          windowId: this.windowId,\n          timestamp: Date.now()\n        }\n\n        this.emit('message', enrichedMessage)\n\n        // 根据消息类型分发\n        if (parsedMessage.type) {\n          this.emit(`message:${parsedMessage.type}`, enrichedMessage)\n        }\n      }\n\n    } catch (error) {\n      console.error(`❌ [${this.windowId}] WebSocket消息处理失败:`, error)\n      this.emit('error', { error, windowId: this.windowId })\n    }\n  }\n\n  /**\n   * 🔧 连接关闭处理\n   */\n  handleConnectionClose(event) {\n    console.log(`🔌 [${this.windowId}] WebSocket连接关闭: 代码=${event.code}`)\n    this.state = WS_STATE.DISCONNECTED\n    this.stopHealthCheck()\n\n    this.emit('disconnected', {\n      code: event.code,\n      reason: event.reason,\n      windowId: this.windowId\n    })\n\n    // 根据关闭原因决定是否重连\n    if (event.code !== 1000) { // 非正常关闭\n      this.scheduleReconnect()\n    }\n  }\n\n  /**\n   * 🔧 发送消息\n   */\n  send(data) {\n    if (this.state !== WS_STATE.CONNECTED || !this.connection) {\n      console.warn(`⚠️ [${this.windowId}] WebSocket未连接，消息加入队列`)\n      this.messageQueue.push(data)\n      return false\n    }\n\n    try {\n      const message = typeof data === 'string' ? data : JSON.stringify(data)\n      this.connection.send(message)\n      return true\n    } catch (error) {\n      console.error(`❌ [${this.windowId}] WebSocket发送消息失败:`, error)\n      return false\n    }\n  }\n\n  /**\n   * 🔧 处理消息队列\n   */\n  processMessageQueue() {\n    if (this.messageQueue.length > 0 && this.state === WS_STATE.CONNECTED) {\n      console.log(`📤 [${this.windowId}] 处理消息队列: ${this.messageQueue.length} 条消息`)\n\n      while (this.messageQueue.length > 0) {\n        const message = this.messageQueue.shift()\n        if (!this.send(message)) {\n          // 发送失败，重新加入队列\n          this.messageQueue.unshift(message)\n          break\n        }\n      }\n    }\n  }\n\n  /**\n   * 🔧 事件监听\n   */\n  on(event, handler) {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, new Set())\n    }\n    this.eventHandlers.get(event).add(handler)\n    console.log(`📡 [${this.windowId}] 注册事件监听器: ${event}`)\n  }\n\n  /**\n   * 🔧 移除事件监听\n   */\n  off(event, handler) {\n    if (this.eventHandlers.has(event)) {\n      this.eventHandlers.get(event).delete(handler)\n      console.log(`📡 [${this.windowId}] 移除事件监听器: ${event}`)\n    }\n  }\n\n  /**\n   * 🔧 触发事件\n   */\n  emit(event, data) {\n    if (this.eventHandlers.has(event)) {\n      this.eventHandlers.get(event).forEach(handler => {\n        try {\n          handler(data)\n        } catch (error) {\n          console.error(`❌ [${this.windowId}] 事件处理器错误 [${event}]:`, error)\n        }\n      })\n    }\n  }\n\n  /**\n   * 🔧 服务器锁定\n   */\n  lockServer(serverUrl) {\n    this.lockedServer = serverUrl\n    this.lockTimestamp = Date.now()\n    console.log(`🔒 [${this.windowId}] 锁定服务器: ${serverUrl}`)\n    console.log(`🕐 [${this.windowId}] 锁定时间: ${new Date(this.lockTimestamp).toLocaleTimeString()}`)\n\n    this.emit('server:locked', {\n      server: serverUrl,\n      timestamp: this.lockTimestamp,\n      windowId: this.windowId\n    })\n  }\n\n  /**\n   * 🔧 解锁服务器\n   */\n  unlockServer() {\n    if (this.lockedServer) {\n      console.log(`🔓 [${this.windowId}] 解锁服务器: ${this.lockedServer}`)\n      const unlockedServer = this.lockedServer\n      this.lockedServer = null\n      this.lockTimestamp = null\n\n      this.emit('server:unlocked', {\n        server: unlockedServer,\n        windowId: this.windowId\n      })\n    }\n  }\n\n  /**\n   * 🔧 获取目标服务器\n   */\n  async getTargetServer() {\n    // 如果有锁定的服务器，优先使用\n    if (this.lockedServer) {\n      console.log(`🔒 [${this.windowId}] 使用锁定的服务器: ${this.lockedServer}`)\n      return this.lockedServer\n    }\n\n    // 从负载均衡器获取最优服务器\n    try {\n      const optimalServer = await loadBalancer.getOptimalServer()\n      console.log(`🎯 [${this.windowId}] 负载均衡选择服务器: ${optimalServer}`)\n      return optimalServer\n    } catch (error) {\n      console.error(`❌ [${this.windowId}] 获取服务器失败:`, error)\n      return null\n    }\n  }\n\n  /**\n   * 🔧 启动健康检查\n   */\n  startHealthCheck() {\n    this.stopHealthCheck() // 清理之前的检查\n\n    this.healthCheckInterval = setInterval(() => {\n      this.performHealthCheck()\n    }, 30000) // 每30秒检查一次\n\n    console.log(`💓 [${this.windowId}] 启动健康检查`)\n  }\n\n  /**\n   * 🔧 停止健康检查\n   */\n  stopHealthCheck() {\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval)\n      this.healthCheckInterval = null\n      console.log(`💓 [${this.windowId}] 停止健康检查`)\n    }\n  }\n\n  /**\n   * 🔧 执行健康检查\n   */\n  performHealthCheck() {\n    const now = Date.now()\n\n    // 检查连接状态\n    if (this.connection && this.connection.readyState !== WebSocket.OPEN) {\n      console.warn(`⚠️ [${this.windowId}] 健康检查: WebSocket连接异常`)\n      this.scheduleReconnect()\n      return\n    }\n\n    // 检查消息活跃度\n    if (this.lastMessageTime && (now - this.lastMessageTime) > 120000) { // 2分钟无消息\n      console.warn(`⚠️ [${this.windowId}] 健康检查: 长时间无消息`)\n    }\n\n    console.log(`💓 [${this.windowId}] 健康检查通过`)\n  }\n\n  /**\n   * 🔧 检查连接健康状态\n   */\n  checkConnectionHealth() {\n    if (this.state === WS_STATE.CONNECTED && this.connection) {\n      if (this.connection.readyState !== WebSocket.OPEN) {\n        console.warn(`⚠️ [${this.windowId}] 连接状态异常，尝试重连`)\n        this.scheduleReconnect()\n      }\n    }\n  }\n\n  /**\n   * 🔧 调度重连\n   */\n  scheduleReconnect() {\n    if (this.reconnectTimer) {\n      return // 已经在重连中\n    }\n\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error(`❌ [${this.windowId}] 重连次数超限，停止重连`)\n      this.state = WS_STATE.FAILED\n      this.emit('reconnect:failed', { windowId: this.windowId })\n      return\n    }\n\n    this.state = WS_STATE.RECONNECTING\n    this.reconnectAttempts++\n\n    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1) // 指数退避\n\n    console.log(`🔄 [${this.windowId}] 调度重连 (第${this.reconnectAttempts}次，${delay}ms后)`)\n\n    this.reconnectTimer = setTimeout(async () => {\n      this.reconnectTimer = null\n\n      try {\n        await this.connect(this.lockedServer)\n        console.log(`✅ [${this.windowId}] 重连成功`)\n        this.emit('reconnect:success', { windowId: this.windowId })\n      } catch (error) {\n        console.error(`❌ [${this.windowId}] 重连失败:`, error)\n        this.scheduleReconnect() // 继续尝试重连\n      }\n    }, delay)\n  }\n\n  /**\n   * 🔧 清除重连定时器\n   */\n  clearReconnectTimer() {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer)\n      this.reconnectTimer = null\n      console.log(`🧹 [${this.windowId}] 清除重连定时器`)\n    }\n  }\n"
        }
    ]
}