{
    "sourceFile": "client/src/services/WebSocketManager.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1753463557474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753463586423,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -506,4 +506,131 @@\n       this.reconnectTimer = null\n       console.log(`🧹 [${this.windowId}] 清除重连定时器`)\n     }\n   }\n+\n+  /**\n+   * 🔧 断开连接\n+   */\n+  disconnect() {\n+    this.stopHealthCheck()\n+    this.clearReconnectTimer()\n+\n+    if (this.connection) {\n+      this.connection.close(1000, '主动断开连接')\n+      this.connection = null\n+    }\n+\n+    this.state = WS_STATE.DISCONNECTED\n+    this.currentServer = null\n+    this.emit('disconnected', { windowId: this.windowId })\n+    console.log(`🔌 [${this.windowId}] WebSocket已断开连接`)\n+  }\n+\n+  /**\n+   * 🔧 强制重连到指定服务器\n+   */\n+  async forceReconnect(serverUrl = null) {\n+    console.log(`🔄 [${this.windowId}] 强制重连到服务器: ${serverUrl || '自动选择'}`)\n+\n+    // 断开现有连接\n+    this.disconnect()\n+\n+    // 重置重连计数\n+    this.reconnectAttempts = 0\n+\n+    // 连接到指定服务器\n+    return await this.connect(serverUrl)\n+  }\n+\n+  /**\n+   * 🔧 确保WebSocket连接\n+   */\n+  async ensureConnection(serverUrl = null) {\n+    // 如果指定了服务器且与当前不同，需要重新连接\n+    if (serverUrl && this.lockedServer && serverUrl !== this.lockedServer) {\n+      console.log(`🔄 [${this.windowId}] 服务器不一致，重新连接`)\n+      console.log(`   当前锁定: ${this.lockedServer}`)\n+      console.log(`   目标服务器: ${serverUrl}`)\n+      return await this.forceReconnect(serverUrl)\n+    }\n+\n+    // 如果已连接且服务器一致，直接返回\n+    if (this.state === WS_STATE.CONNECTED && this.connection?.readyState === WebSocket.OPEN) {\n+      console.log(`✅ [${this.windowId}] WebSocket已连接`)\n+      this.processMessageQueue() // 处理待发送消息\n+      return true\n+    }\n+\n+    // 需要建立新连接\n+    console.log(`🔄 [${this.windowId}] 建立新的WebSocket连接`)\n+    return await this.connect(serverUrl)\n+  }\n+\n+  /**\n+   * 🔧 获取连接状态\n+   */\n+  getStatus() {\n+    return {\n+      windowId: this.windowId,\n+      clientId: this.clientId,\n+      state: this.state,\n+      isConnected: this.state === WS_STATE.CONNECTED,\n+      currentServer: this.currentServer,\n+      lockedServer: this.lockedServer,\n+      lockTimestamp: this.lockTimestamp,\n+      lockDuration: this.lockTimestamp ? Date.now() - this.lockTimestamp : null,\n+      reconnectAttempts: this.reconnectAttempts,\n+      connectionState: this.connection?.readyState || 'CLOSED',\n+      messageQueueLength: this.messageQueue.length,\n+      lastMessageTime: this.lastMessageTime\n+    }\n+  }\n+\n+  /**\n+   * 🔧 调试信息\n+   */\n+  debug() {\n+    const status = this.getStatus()\n+    console.log(`🔍 [${this.windowId}] ===== WebSocket管理器状态 =====`)\n+    console.log(`🪟 窗口ID: ${status.windowId}`)\n+    console.log(`🔑 客户端ID: ${status.clientId}`)\n+    console.log(`🔗 连接状态: ${status.state}`)\n+    console.log(`📡 当前服务器: ${status.currentServer || '无'}`)\n+    console.log(`🔒 锁定服务器: ${status.lockedServer || '无'}`)\n+    console.log(`🕐 锁定时间: ${status.lockTimestamp ? new Date(status.lockTimestamp).toLocaleString() : '无'}`)\n+    console.log(`⏱️ 锁定持续: ${status.lockDuration ? Math.round(status.lockDuration / 1000) + '秒' : '无'}`)\n+    console.log(`🔄 重连次数: ${status.reconnectAttempts}`)\n+    console.log(`📤 消息队列: ${status.messageQueueLength} 条`)\n+    console.log(`📨 最后消息: ${status.lastMessageTime ? new Date(status.lastMessageTime).toLocaleString() : '无'}`)\n+    console.log(`🔍 [${this.windowId}] ===== 状态信息结束 =====`)\n+\n+    return status\n+  }\n+\n+  /**\n+   * 🔧 重置管理器状态\n+   */\n+  reset() {\n+    console.log(`🔄 [${this.windowId}] 重置WebSocket管理器`)\n+\n+    this.disconnect()\n+    this.unlockServer()\n+    this.messageQueue = []\n+    this.reconnectAttempts = 0\n+    this.lastMessageTime = null\n+\n+    console.log(`✅ [${this.windowId}] WebSocket管理器已重置`)\n+  }\n+}\n+\n+// 创建全局实例\n+const webSocketManager = new WebSocketManager()\n+\n+// 暴露调试函数到全局\n+if (typeof window !== 'undefined') {\n+  window.webSocketManager = webSocketManager\n+  window.debugWebSocket = () => webSocketManager.debug()\n+  window.resetWebSocket = () => webSocketManager.reset()\n+}\n+\n+export default webSocketManager\n"
                }
            ],
            "date": 1753463557474,
            "name": "Commit-0",
            "content": "/**\n * 🔥 WebSocket连接管理器 - 独立的WebSocket服务\n *\n * 核心功能：\n * 1. WebSocket连接生命周期管理\n * 2. 多窗口隔离机制\n * 3. 服务器锁定与一致性保证\n * 4. 消息路由与事件分发\n * 5. 自动重连与健康检查\n *\n * 架构优势：\n * - 解耦WebSocket管理与业务逻辑\n * - 支持多种服务复用同一WebSocket连接\n * - 提供统一的连接管理策略\n * - 便于测试和维护\n */\n\nimport loadBalancer from './loadBalancer.js'\n\n// WebSocket连接状态枚举\nexport const WS_STATE = {\n  DISCONNECTED: 'disconnected',\n  CONNECTING: 'connecting',\n  CONNECTED: 'connected',\n  RECONNECTING: 'reconnecting',\n  FAILED: 'failed'\n}\n\n// 🔧 生成窗口唯一标识符\nfunction generateWindowId() {\n  return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n}\n\n// 🔧 生成增强的客户端ID\nfunction generateUniqueClientId() {\n  const baseId = 'abc1373d4ad648a3a81d0587fbe5534b'\n  const timestamp = Date.now()\n  const random = Math.random().toString(36).substr(2, 9)\n  const windowId = generateWindowId()\n  return `${baseId}_${timestamp}_${random}_${windowId}`\n}\n\nclass WebSocketManager {\n  constructor() {\n    // 窗口标识\n    this.windowId = generateWindowId()\n    this.clientId = generateUniqueClientId()\n\n    // 连接管理\n    this.connection = null\n    this.state = WS_STATE.DISCONNECTED\n    this.currentServer = null\n\n    // 服务器锁定机制（窗口级别）\n    this.lockedServer = null\n    this.lockTimestamp = null\n\n    // 事件管理\n    this.eventHandlers = new Map()\n    this.messageQueue = []\n\n    // 重连管理\n    this.reconnectAttempts = 0\n    this.maxReconnectAttempts = 5\n    this.reconnectDelay = 2000\n    this.reconnectTimer = null\n\n    // 健康检查\n    this.healthCheckInterval = null\n    this.lastHeartbeat = null\n    this.lastMessageTime = null\n\n    console.log(`🔌 WebSocketManager 初始化完成`)\n    console.log(`🪟 窗口ID: ${this.windowId}`)\n    console.log(`🔑 客户端ID: ${this.clientId}`)\n\n    // 设置窗口关闭清理\n    this.setupWindowCleanup()\n  }\n\n  /**\n   * 🔧 设置窗口关闭时的清理机制\n   */\n  setupWindowCleanup() {\n    window.addEventListener('beforeunload', () => {\n      console.log(`🚪 [${this.windowId}] 窗口即将关闭，执行WebSocket清理...`)\n      this.disconnect()\n      this.unlockServer()\n    })\n\n    // 页面可见性变化处理\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden) {\n        console.log(`👁️ [${this.windowId}] 窗口隐藏`)\n      } else {\n        console.log(`👁️ [${this.windowId}] 窗口重新可见`)\n        this.checkConnectionHealth()\n      }\n    })\n  }\n\n  /**\n   * 🔧 连接到指定服务器\n   */\n  async connect(serverUrl = null) {\n    if (this.state === WS_STATE.CONNECTING) {\n      console.log(`🔄 [${this.windowId}] WebSocket正在连接中，跳过重复连接`)\n      return false\n    }\n\n    try {\n      this.state = WS_STATE.CONNECTING\n\n      // 确定目标服务器\n      const targetServer = serverUrl || await this.getTargetServer()\n      if (!targetServer) {\n        throw new Error('无法获取可用的服务器')\n      }\n\n      // 锁定服务器\n      this.lockServer(targetServer)\n\n      // 建立WebSocket连接\n      await this.establishConnection(targetServer)\n\n      this.state = WS_STATE.CONNECTED\n      this.reconnectAttempts = 0\n      this.startHealthCheck()\n\n      console.log(`✅ [${this.windowId}] WebSocket连接成功: ${targetServer}`)\n      this.emit('connected', { server: targetServer, windowId: this.windowId })\n\n      return true\n\n    } catch (error) {\n      this.state = WS_STATE.FAILED\n      console.error(`❌ [${this.windowId}] WebSocket连接失败:`, error)\n      this.emit('error', { error, windowId: this.windowId })\n\n      // 启动重连\n      this.scheduleReconnect()\n      return false\n    }\n  }\n\n  /**\n   * 🔧 建立WebSocket连接\n   */\n  async establishConnection(serverUrl) {\n    return new Promise((resolve, reject) => {\n      const wsUrl = this.buildWebSocketUrl(serverUrl)\n      console.log(`🔗 [${this.windowId}] 建立WebSocket连接: ${wsUrl}`)\n\n      // 先进行HTTP连接测试\n      this.testHttpConnection(serverUrl)\n        .then(() => {\n          this.connection = new WebSocket(wsUrl)\n          this.currentServer = serverUrl\n\n          const timeout = setTimeout(() => {\n            reject(new Error('WebSocket连接超时'))\n          }, 10000)\n\n          this.connection.onopen = () => {\n            clearTimeout(timeout)\n            console.log(`🎉 [${this.windowId}] WebSocket连接已建立`)\n            resolve()\n          }\n\n          this.connection.onclose = (event) => {\n            clearTimeout(timeout)\n            this.handleConnectionClose(event)\n          }\n\n          this.connection.onerror = (error) => {\n            clearTimeout(timeout)\n            console.error(`❌ [${this.windowId}] WebSocket连接错误:`, error)\n            reject(error)\n          }\n\n          this.connection.onmessage = (event) => {\n            this.handleMessage(event)\n          }\n        })\n        .catch(reject)\n    })\n  }\n\n  /**\n   * 🔧 HTTP连接测试\n   */\n  async testHttpConnection(serverUrl) {\n    try {\n      const response = await fetch(`${serverUrl}/api/queue`, {\n        method: 'GET',\n        signal: AbortSignal.timeout(5000)\n      })\n      if (!response.ok) {\n        throw new Error(`服务器响应错误: ${response.status}`)\n      }\n      console.log(`✅ [${this.windowId}] HTTP连接测试通过: ${serverUrl}`)\n    } catch (error) {\n      throw new Error(`ComfyUI服务器不可达: ${error.message}`)\n    }\n  }\n\n  /**\n   * 🔧 构建WebSocket URL\n   */\n  buildWebSocketUrl(serverUrl) {\n    let wsUrl\n    if (serverUrl.startsWith('https://')) {\n      wsUrl = serverUrl.replace('https://', 'wss://')\n    } else {\n      wsUrl = serverUrl.replace('http://', 'ws://')\n    }\n    return `${wsUrl}/ws?clientId=${this.clientId}`\n  }\n\n  /**\n   * 🔧 消息处理\n   */\n  handleMessage(event) {\n    try {\n      this.lastMessageTime = Date.now()\n      const message = event.data\n\n      // 处理二进制消息\n      if (message instanceof ArrayBuffer || message instanceof Blob) {\n        this.emit('binary', { data: message, windowId: this.windowId })\n        return\n      }\n\n      // 处理文本消息\n      if (typeof message === 'string') {\n        const parsedMessage = JSON.parse(message)\n\n        // 添加窗口标识\n        const enrichedMessage = {\n          ...parsedMessage,\n          windowId: this.windowId,\n          timestamp: Date.now()\n        }\n\n        this.emit('message', enrichedMessage)\n\n        // 根据消息类型分发\n        if (parsedMessage.type) {\n          this.emit(`message:${parsedMessage.type}`, enrichedMessage)\n        }\n      }\n\n    } catch (error) {\n      console.error(`❌ [${this.windowId}] WebSocket消息处理失败:`, error)\n      this.emit('error', { error, windowId: this.windowId })\n    }\n  }\n\n  /**\n   * 🔧 连接关闭处理\n   */\n  handleConnectionClose(event) {\n    console.log(`🔌 [${this.windowId}] WebSocket连接关闭: 代码=${event.code}`)\n    this.state = WS_STATE.DISCONNECTED\n    this.stopHealthCheck()\n\n    this.emit('disconnected', {\n      code: event.code,\n      reason: event.reason,\n      windowId: this.windowId\n    })\n\n    // 根据关闭原因决定是否重连\n    if (event.code !== 1000) { // 非正常关闭\n      this.scheduleReconnect()\n    }\n  }\n\n  /**\n   * 🔧 发送消息\n   */\n  send(data) {\n    if (this.state !== WS_STATE.CONNECTED || !this.connection) {\n      console.warn(`⚠️ [${this.windowId}] WebSocket未连接，消息加入队列`)\n      this.messageQueue.push(data)\n      return false\n    }\n\n    try {\n      const message = typeof data === 'string' ? data : JSON.stringify(data)\n      this.connection.send(message)\n      return true\n    } catch (error) {\n      console.error(`❌ [${this.windowId}] WebSocket发送消息失败:`, error)\n      return false\n    }\n  }\n\n  /**\n   * 🔧 处理消息队列\n   */\n  processMessageQueue() {\n    if (this.messageQueue.length > 0 && this.state === WS_STATE.CONNECTED) {\n      console.log(`📤 [${this.windowId}] 处理消息队列: ${this.messageQueue.length} 条消息`)\n\n      while (this.messageQueue.length > 0) {\n        const message = this.messageQueue.shift()\n        if (!this.send(message)) {\n          // 发送失败，重新加入队列\n          this.messageQueue.unshift(message)\n          break\n        }\n      }\n    }\n  }\n\n  /**\n   * 🔧 事件监听\n   */\n  on(event, handler) {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, new Set())\n    }\n    this.eventHandlers.get(event).add(handler)\n    console.log(`📡 [${this.windowId}] 注册事件监听器: ${event}`)\n  }\n\n  /**\n   * 🔧 移除事件监听\n   */\n  off(event, handler) {\n    if (this.eventHandlers.has(event)) {\n      this.eventHandlers.get(event).delete(handler)\n      console.log(`📡 [${this.windowId}] 移除事件监听器: ${event}`)\n    }\n  }\n\n  /**\n   * 🔧 触发事件\n   */\n  emit(event, data) {\n    if (this.eventHandlers.has(event)) {\n      this.eventHandlers.get(event).forEach(handler => {\n        try {\n          handler(data)\n        } catch (error) {\n          console.error(`❌ [${this.windowId}] 事件处理器错误 [${event}]:`, error)\n        }\n      })\n    }\n  }\n\n  /**\n   * 🔧 服务器锁定\n   */\n  lockServer(serverUrl) {\n    this.lockedServer = serverUrl\n    this.lockTimestamp = Date.now()\n    console.log(`🔒 [${this.windowId}] 锁定服务器: ${serverUrl}`)\n    console.log(`🕐 [${this.windowId}] 锁定时间: ${new Date(this.lockTimestamp).toLocaleTimeString()}`)\n\n    this.emit('server:locked', {\n      server: serverUrl,\n      timestamp: this.lockTimestamp,\n      windowId: this.windowId\n    })\n  }\n\n  /**\n   * 🔧 解锁服务器\n   */\n  unlockServer() {\n    if (this.lockedServer) {\n      console.log(`🔓 [${this.windowId}] 解锁服务器: ${this.lockedServer}`)\n      const unlockedServer = this.lockedServer\n      this.lockedServer = null\n      this.lockTimestamp = null\n\n      this.emit('server:unlocked', {\n        server: unlockedServer,\n        windowId: this.windowId\n      })\n    }\n  }\n\n  /**\n   * 🔧 获取目标服务器\n   */\n  async getTargetServer() {\n    // 如果有锁定的服务器，优先使用\n    if (this.lockedServer) {\n      console.log(`🔒 [${this.windowId}] 使用锁定的服务器: ${this.lockedServer}`)\n      return this.lockedServer\n    }\n\n    // 从负载均衡器获取最优服务器\n    try {\n      const optimalServer = await loadBalancer.getOptimalServer()\n      console.log(`🎯 [${this.windowId}] 负载均衡选择服务器: ${optimalServer}`)\n      return optimalServer\n    } catch (error) {\n      console.error(`❌ [${this.windowId}] 获取服务器失败:`, error)\n      return null\n    }\n  }\n\n  /**\n   * 🔧 启动健康检查\n   */\n  startHealthCheck() {\n    this.stopHealthCheck() // 清理之前的检查\n\n    this.healthCheckInterval = setInterval(() => {\n      this.performHealthCheck()\n    }, 30000) // 每30秒检查一次\n\n    console.log(`💓 [${this.windowId}] 启动健康检查`)\n  }\n\n  /**\n   * 🔧 停止健康检查\n   */\n  stopHealthCheck() {\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval)\n      this.healthCheckInterval = null\n      console.log(`💓 [${this.windowId}] 停止健康检查`)\n    }\n  }\n\n  /**\n   * 🔧 执行健康检查\n   */\n  performHealthCheck() {\n    const now = Date.now()\n\n    // 检查连接状态\n    if (this.connection && this.connection.readyState !== WebSocket.OPEN) {\n      console.warn(`⚠️ [${this.windowId}] 健康检查: WebSocket连接异常`)\n      this.scheduleReconnect()\n      return\n    }\n\n    // 检查消息活跃度\n    if (this.lastMessageTime && (now - this.lastMessageTime) > 120000) { // 2分钟无消息\n      console.warn(`⚠️ [${this.windowId}] 健康检查: 长时间无消息`)\n    }\n\n    console.log(`💓 [${this.windowId}] 健康检查通过`)\n  }\n\n  /**\n   * 🔧 检查连接健康状态\n   */\n  checkConnectionHealth() {\n    if (this.state === WS_STATE.CONNECTED && this.connection) {\n      if (this.connection.readyState !== WebSocket.OPEN) {\n        console.warn(`⚠️ [${this.windowId}] 连接状态异常，尝试重连`)\n        this.scheduleReconnect()\n      }\n    }\n  }\n\n  /**\n   * 🔧 调度重连\n   */\n  scheduleReconnect() {\n    if (this.reconnectTimer) {\n      return // 已经在重连中\n    }\n\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error(`❌ [${this.windowId}] 重连次数超限，停止重连`)\n      this.state = WS_STATE.FAILED\n      this.emit('reconnect:failed', { windowId: this.windowId })\n      return\n    }\n\n    this.state = WS_STATE.RECONNECTING\n    this.reconnectAttempts++\n\n    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1) // 指数退避\n\n    console.log(`🔄 [${this.windowId}] 调度重连 (第${this.reconnectAttempts}次，${delay}ms后)`)\n\n    this.reconnectTimer = setTimeout(async () => {\n      this.reconnectTimer = null\n\n      try {\n        await this.connect(this.lockedServer)\n        console.log(`✅ [${this.windowId}] 重连成功`)\n        this.emit('reconnect:success', { windowId: this.windowId })\n      } catch (error) {\n        console.error(`❌ [${this.windowId}] 重连失败:`, error)\n        this.scheduleReconnect() // 继续尝试重连\n      }\n    }, delay)\n  }\n\n  /**\n   * 🔧 清除重连定时器\n   */\n  clearReconnectTimer() {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer)\n      this.reconnectTimer = null\n      console.log(`🧹 [${this.windowId}] 清除重连定时器`)\n    }\n  }\n"
        }
    ]
}