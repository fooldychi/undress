{
    "sourceFile": "client/src/services/WebSocketManager.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1753463557474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753463586423,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -506,4 +506,131 @@\n       this.reconnectTimer = null\n       console.log(`ğŸ§¹ [${this.windowId}] æ¸…é™¤é‡è¿å®šæ—¶å™¨`)\n     }\n   }\n+\n+  /**\n+   * ğŸ”§ æ–­å¼€è¿æ¥\n+   */\n+  disconnect() {\n+    this.stopHealthCheck()\n+    this.clearReconnectTimer()\n+\n+    if (this.connection) {\n+      this.connection.close(1000, 'ä¸»åŠ¨æ–­å¼€è¿æ¥')\n+      this.connection = null\n+    }\n+\n+    this.state = WS_STATE.DISCONNECTED\n+    this.currentServer = null\n+    this.emit('disconnected', { windowId: this.windowId })\n+    console.log(`ğŸ”Œ [${this.windowId}] WebSocketå·²æ–­å¼€è¿æ¥`)\n+  }\n+\n+  /**\n+   * ğŸ”§ å¼ºåˆ¶é‡è¿åˆ°æŒ‡å®šæœåŠ¡å™¨\n+   */\n+  async forceReconnect(serverUrl = null) {\n+    console.log(`ğŸ”„ [${this.windowId}] å¼ºåˆ¶é‡è¿åˆ°æœåŠ¡å™¨: ${serverUrl || 'è‡ªåŠ¨é€‰æ‹©'}`)\n+\n+    // æ–­å¼€ç°æœ‰è¿æ¥\n+    this.disconnect()\n+\n+    // é‡ç½®é‡è¿è®¡æ•°\n+    this.reconnectAttempts = 0\n+\n+    // è¿æ¥åˆ°æŒ‡å®šæœåŠ¡å™¨\n+    return await this.connect(serverUrl)\n+  }\n+\n+  /**\n+   * ğŸ”§ ç¡®ä¿WebSocketè¿æ¥\n+   */\n+  async ensureConnection(serverUrl = null) {\n+    // å¦‚æœæŒ‡å®šäº†æœåŠ¡å™¨ä¸”ä¸å½“å‰ä¸åŒï¼Œéœ€è¦é‡æ–°è¿æ¥\n+    if (serverUrl && this.lockedServer && serverUrl !== this.lockedServer) {\n+      console.log(`ğŸ”„ [${this.windowId}] æœåŠ¡å™¨ä¸ä¸€è‡´ï¼Œé‡æ–°è¿æ¥`)\n+      console.log(`   å½“å‰é”å®š: ${this.lockedServer}`)\n+      console.log(`   ç›®æ ‡æœåŠ¡å™¨: ${serverUrl}`)\n+      return await this.forceReconnect(serverUrl)\n+    }\n+\n+    // å¦‚æœå·²è¿æ¥ä¸”æœåŠ¡å™¨ä¸€è‡´ï¼Œç›´æ¥è¿”å›\n+    if (this.state === WS_STATE.CONNECTED && this.connection?.readyState === WebSocket.OPEN) {\n+      console.log(`âœ… [${this.windowId}] WebSocketå·²è¿æ¥`)\n+      this.processMessageQueue() // å¤„ç†å¾…å‘é€æ¶ˆæ¯\n+      return true\n+    }\n+\n+    // éœ€è¦å»ºç«‹æ–°è¿æ¥\n+    console.log(`ğŸ”„ [${this.windowId}] å»ºç«‹æ–°çš„WebSocketè¿æ¥`)\n+    return await this.connect(serverUrl)\n+  }\n+\n+  /**\n+   * ğŸ”§ è·å–è¿æ¥çŠ¶æ€\n+   */\n+  getStatus() {\n+    return {\n+      windowId: this.windowId,\n+      clientId: this.clientId,\n+      state: this.state,\n+      isConnected: this.state === WS_STATE.CONNECTED,\n+      currentServer: this.currentServer,\n+      lockedServer: this.lockedServer,\n+      lockTimestamp: this.lockTimestamp,\n+      lockDuration: this.lockTimestamp ? Date.now() - this.lockTimestamp : null,\n+      reconnectAttempts: this.reconnectAttempts,\n+      connectionState: this.connection?.readyState || 'CLOSED',\n+      messageQueueLength: this.messageQueue.length,\n+      lastMessageTime: this.lastMessageTime\n+    }\n+  }\n+\n+  /**\n+   * ğŸ”§ è°ƒè¯•ä¿¡æ¯\n+   */\n+  debug() {\n+    const status = this.getStatus()\n+    console.log(`ğŸ” [${this.windowId}] ===== WebSocketç®¡ç†å™¨çŠ¶æ€ =====`)\n+    console.log(`ğŸªŸ çª—å£ID: ${status.windowId}`)\n+    console.log(`ğŸ”‘ å®¢æˆ·ç«¯ID: ${status.clientId}`)\n+    console.log(`ğŸ”— è¿æ¥çŠ¶æ€: ${status.state}`)\n+    console.log(`ğŸ“¡ å½“å‰æœåŠ¡å™¨: ${status.currentServer || 'æ— '}`)\n+    console.log(`ğŸ”’ é”å®šæœåŠ¡å™¨: ${status.lockedServer || 'æ— '}`)\n+    console.log(`ğŸ• é”å®šæ—¶é—´: ${status.lockTimestamp ? new Date(status.lockTimestamp).toLocaleString() : 'æ— '}`)\n+    console.log(`â±ï¸ é”å®šæŒç»­: ${status.lockDuration ? Math.round(status.lockDuration / 1000) + 'ç§’' : 'æ— '}`)\n+    console.log(`ğŸ”„ é‡è¿æ¬¡æ•°: ${status.reconnectAttempts}`)\n+    console.log(`ğŸ“¤ æ¶ˆæ¯é˜Ÿåˆ—: ${status.messageQueueLength} æ¡`)\n+    console.log(`ğŸ“¨ æœ€åæ¶ˆæ¯: ${status.lastMessageTime ? new Date(status.lastMessageTime).toLocaleString() : 'æ— '}`)\n+    console.log(`ğŸ” [${this.windowId}] ===== çŠ¶æ€ä¿¡æ¯ç»“æŸ =====`)\n+\n+    return status\n+  }\n+\n+  /**\n+   * ğŸ”§ é‡ç½®ç®¡ç†å™¨çŠ¶æ€\n+   */\n+  reset() {\n+    console.log(`ğŸ”„ [${this.windowId}] é‡ç½®WebSocketç®¡ç†å™¨`)\n+\n+    this.disconnect()\n+    this.unlockServer()\n+    this.messageQueue = []\n+    this.reconnectAttempts = 0\n+    this.lastMessageTime = null\n+\n+    console.log(`âœ… [${this.windowId}] WebSocketç®¡ç†å™¨å·²é‡ç½®`)\n+  }\n+}\n+\n+// åˆ›å»ºå…¨å±€å®ä¾‹\n+const webSocketManager = new WebSocketManager()\n+\n+// æš´éœ²è°ƒè¯•å‡½æ•°åˆ°å…¨å±€\n+if (typeof window !== 'undefined') {\n+  window.webSocketManager = webSocketManager\n+  window.debugWebSocket = () => webSocketManager.debug()\n+  window.resetWebSocket = () => webSocketManager.reset()\n+}\n+\n+export default webSocketManager\n"
                }
            ],
            "date": 1753463557474,
            "name": "Commit-0",
            "content": "/**\n * ğŸ”¥ WebSocketè¿æ¥ç®¡ç†å™¨ - ç‹¬ç«‹çš„WebSocketæœåŠ¡\n *\n * æ ¸å¿ƒåŠŸèƒ½ï¼š\n * 1. WebSocketè¿æ¥ç”Ÿå‘½å‘¨æœŸç®¡ç†\n * 2. å¤šçª—å£éš”ç¦»æœºåˆ¶\n * 3. æœåŠ¡å™¨é”å®šä¸ä¸€è‡´æ€§ä¿è¯\n * 4. æ¶ˆæ¯è·¯ç”±ä¸äº‹ä»¶åˆ†å‘\n * 5. è‡ªåŠ¨é‡è¿ä¸å¥åº·æ£€æŸ¥\n *\n * æ¶æ„ä¼˜åŠ¿ï¼š\n * - è§£è€¦WebSocketç®¡ç†ä¸ä¸šåŠ¡é€»è¾‘\n * - æ”¯æŒå¤šç§æœåŠ¡å¤ç”¨åŒä¸€WebSocketè¿æ¥\n * - æä¾›ç»Ÿä¸€çš„è¿æ¥ç®¡ç†ç­–ç•¥\n * - ä¾¿äºæµ‹è¯•å’Œç»´æŠ¤\n */\n\nimport loadBalancer from './loadBalancer.js'\n\n// WebSocketè¿æ¥çŠ¶æ€æšä¸¾\nexport const WS_STATE = {\n  DISCONNECTED: 'disconnected',\n  CONNECTING: 'connecting',\n  CONNECTED: 'connected',\n  RECONNECTING: 'reconnecting',\n  FAILED: 'failed'\n}\n\n// ğŸ”§ ç”Ÿæˆçª—å£å”¯ä¸€æ ‡è¯†ç¬¦\nfunction generateWindowId() {\n  return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n}\n\n// ğŸ”§ ç”Ÿæˆå¢å¼ºçš„å®¢æˆ·ç«¯ID\nfunction generateUniqueClientId() {\n  const baseId = 'abc1373d4ad648a3a81d0587fbe5534b'\n  const timestamp = Date.now()\n  const random = Math.random().toString(36).substr(2, 9)\n  const windowId = generateWindowId()\n  return `${baseId}_${timestamp}_${random}_${windowId}`\n}\n\nclass WebSocketManager {\n  constructor() {\n    // çª—å£æ ‡è¯†\n    this.windowId = generateWindowId()\n    this.clientId = generateUniqueClientId()\n\n    // è¿æ¥ç®¡ç†\n    this.connection = null\n    this.state = WS_STATE.DISCONNECTED\n    this.currentServer = null\n\n    // æœåŠ¡å™¨é”å®šæœºåˆ¶ï¼ˆçª—å£çº§åˆ«ï¼‰\n    this.lockedServer = null\n    this.lockTimestamp = null\n\n    // äº‹ä»¶ç®¡ç†\n    this.eventHandlers = new Map()\n    this.messageQueue = []\n\n    // é‡è¿ç®¡ç†\n    this.reconnectAttempts = 0\n    this.maxReconnectAttempts = 5\n    this.reconnectDelay = 2000\n    this.reconnectTimer = null\n\n    // å¥åº·æ£€æŸ¥\n    this.healthCheckInterval = null\n    this.lastHeartbeat = null\n    this.lastMessageTime = null\n\n    console.log(`ğŸ”Œ WebSocketManager åˆå§‹åŒ–å®Œæˆ`)\n    console.log(`ğŸªŸ çª—å£ID: ${this.windowId}`)\n    console.log(`ğŸ”‘ å®¢æˆ·ç«¯ID: ${this.clientId}`)\n\n    // è®¾ç½®çª—å£å…³é—­æ¸…ç†\n    this.setupWindowCleanup()\n  }\n\n  /**\n   * ğŸ”§ è®¾ç½®çª—å£å…³é—­æ—¶çš„æ¸…ç†æœºåˆ¶\n   */\n  setupWindowCleanup() {\n    window.addEventListener('beforeunload', () => {\n      console.log(`ğŸšª [${this.windowId}] çª—å£å³å°†å…³é—­ï¼Œæ‰§è¡ŒWebSocketæ¸…ç†...`)\n      this.disconnect()\n      this.unlockServer()\n    })\n\n    // é¡µé¢å¯è§æ€§å˜åŒ–å¤„ç†\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden) {\n        console.log(`ğŸ‘ï¸ [${this.windowId}] çª—å£éšè—`)\n      } else {\n        console.log(`ğŸ‘ï¸ [${this.windowId}] çª—å£é‡æ–°å¯è§`)\n        this.checkConnectionHealth()\n      }\n    })\n  }\n\n  /**\n   * ğŸ”§ è¿æ¥åˆ°æŒ‡å®šæœåŠ¡å™¨\n   */\n  async connect(serverUrl = null) {\n    if (this.state === WS_STATE.CONNECTING) {\n      console.log(`ğŸ”„ [${this.windowId}] WebSocketæ­£åœ¨è¿æ¥ä¸­ï¼Œè·³è¿‡é‡å¤è¿æ¥`)\n      return false\n    }\n\n    try {\n      this.state = WS_STATE.CONNECTING\n\n      // ç¡®å®šç›®æ ‡æœåŠ¡å™¨\n      const targetServer = serverUrl || await this.getTargetServer()\n      if (!targetServer) {\n        throw new Error('æ— æ³•è·å–å¯ç”¨çš„æœåŠ¡å™¨')\n      }\n\n      // é”å®šæœåŠ¡å™¨\n      this.lockServer(targetServer)\n\n      // å»ºç«‹WebSocketè¿æ¥\n      await this.establishConnection(targetServer)\n\n      this.state = WS_STATE.CONNECTED\n      this.reconnectAttempts = 0\n      this.startHealthCheck()\n\n      console.log(`âœ… [${this.windowId}] WebSocketè¿æ¥æˆåŠŸ: ${targetServer}`)\n      this.emit('connected', { server: targetServer, windowId: this.windowId })\n\n      return true\n\n    } catch (error) {\n      this.state = WS_STATE.FAILED\n      console.error(`âŒ [${this.windowId}] WebSocketè¿æ¥å¤±è´¥:`, error)\n      this.emit('error', { error, windowId: this.windowId })\n\n      // å¯åŠ¨é‡è¿\n      this.scheduleReconnect()\n      return false\n    }\n  }\n\n  /**\n   * ğŸ”§ å»ºç«‹WebSocketè¿æ¥\n   */\n  async establishConnection(serverUrl) {\n    return new Promise((resolve, reject) => {\n      const wsUrl = this.buildWebSocketUrl(serverUrl)\n      console.log(`ğŸ”— [${this.windowId}] å»ºç«‹WebSocketè¿æ¥: ${wsUrl}`)\n\n      // å…ˆè¿›è¡ŒHTTPè¿æ¥æµ‹è¯•\n      this.testHttpConnection(serverUrl)\n        .then(() => {\n          this.connection = new WebSocket(wsUrl)\n          this.currentServer = serverUrl\n\n          const timeout = setTimeout(() => {\n            reject(new Error('WebSocketè¿æ¥è¶…æ—¶'))\n          }, 10000)\n\n          this.connection.onopen = () => {\n            clearTimeout(timeout)\n            console.log(`ğŸ‰ [${this.windowId}] WebSocketè¿æ¥å·²å»ºç«‹`)\n            resolve()\n          }\n\n          this.connection.onclose = (event) => {\n            clearTimeout(timeout)\n            this.handleConnectionClose(event)\n          }\n\n          this.connection.onerror = (error) => {\n            clearTimeout(timeout)\n            console.error(`âŒ [${this.windowId}] WebSocketè¿æ¥é”™è¯¯:`, error)\n            reject(error)\n          }\n\n          this.connection.onmessage = (event) => {\n            this.handleMessage(event)\n          }\n        })\n        .catch(reject)\n    })\n  }\n\n  /**\n   * ğŸ”§ HTTPè¿æ¥æµ‹è¯•\n   */\n  async testHttpConnection(serverUrl) {\n    try {\n      const response = await fetch(`${serverUrl}/api/queue`, {\n        method: 'GET',\n        signal: AbortSignal.timeout(5000)\n      })\n      if (!response.ok) {\n        throw new Error(`æœåŠ¡å™¨å“åº”é”™è¯¯: ${response.status}`)\n      }\n      console.log(`âœ… [${this.windowId}] HTTPè¿æ¥æµ‹è¯•é€šè¿‡: ${serverUrl}`)\n    } catch (error) {\n      throw new Error(`ComfyUIæœåŠ¡å™¨ä¸å¯è¾¾: ${error.message}`)\n    }\n  }\n\n  /**\n   * ğŸ”§ æ„å»ºWebSocket URL\n   */\n  buildWebSocketUrl(serverUrl) {\n    let wsUrl\n    if (serverUrl.startsWith('https://')) {\n      wsUrl = serverUrl.replace('https://', 'wss://')\n    } else {\n      wsUrl = serverUrl.replace('http://', 'ws://')\n    }\n    return `${wsUrl}/ws?clientId=${this.clientId}`\n  }\n\n  /**\n   * ğŸ”§ æ¶ˆæ¯å¤„ç†\n   */\n  handleMessage(event) {\n    try {\n      this.lastMessageTime = Date.now()\n      const message = event.data\n\n      // å¤„ç†äºŒè¿›åˆ¶æ¶ˆæ¯\n      if (message instanceof ArrayBuffer || message instanceof Blob) {\n        this.emit('binary', { data: message, windowId: this.windowId })\n        return\n      }\n\n      // å¤„ç†æ–‡æœ¬æ¶ˆæ¯\n      if (typeof message === 'string') {\n        const parsedMessage = JSON.parse(message)\n\n        // æ·»åŠ çª—å£æ ‡è¯†\n        const enrichedMessage = {\n          ...parsedMessage,\n          windowId: this.windowId,\n          timestamp: Date.now()\n        }\n\n        this.emit('message', enrichedMessage)\n\n        // æ ¹æ®æ¶ˆæ¯ç±»å‹åˆ†å‘\n        if (parsedMessage.type) {\n          this.emit(`message:${parsedMessage.type}`, enrichedMessage)\n        }\n      }\n\n    } catch (error) {\n      console.error(`âŒ [${this.windowId}] WebSocketæ¶ˆæ¯å¤„ç†å¤±è´¥:`, error)\n      this.emit('error', { error, windowId: this.windowId })\n    }\n  }\n\n  /**\n   * ğŸ”§ è¿æ¥å…³é—­å¤„ç†\n   */\n  handleConnectionClose(event) {\n    console.log(`ğŸ”Œ [${this.windowId}] WebSocketè¿æ¥å…³é—­: ä»£ç =${event.code}`)\n    this.state = WS_STATE.DISCONNECTED\n    this.stopHealthCheck()\n\n    this.emit('disconnected', {\n      code: event.code,\n      reason: event.reason,\n      windowId: this.windowId\n    })\n\n    // æ ¹æ®å…³é—­åŸå› å†³å®šæ˜¯å¦é‡è¿\n    if (event.code !== 1000) { // éæ­£å¸¸å…³é—­\n      this.scheduleReconnect()\n    }\n  }\n\n  /**\n   * ğŸ”§ å‘é€æ¶ˆæ¯\n   */\n  send(data) {\n    if (this.state !== WS_STATE.CONNECTED || !this.connection) {\n      console.warn(`âš ï¸ [${this.windowId}] WebSocketæœªè¿æ¥ï¼Œæ¶ˆæ¯åŠ å…¥é˜Ÿåˆ—`)\n      this.messageQueue.push(data)\n      return false\n    }\n\n    try {\n      const message = typeof data === 'string' ? data : JSON.stringify(data)\n      this.connection.send(message)\n      return true\n    } catch (error) {\n      console.error(`âŒ [${this.windowId}] WebSocketå‘é€æ¶ˆæ¯å¤±è´¥:`, error)\n      return false\n    }\n  }\n\n  /**\n   * ğŸ”§ å¤„ç†æ¶ˆæ¯é˜Ÿåˆ—\n   */\n  processMessageQueue() {\n    if (this.messageQueue.length > 0 && this.state === WS_STATE.CONNECTED) {\n      console.log(`ğŸ“¤ [${this.windowId}] å¤„ç†æ¶ˆæ¯é˜Ÿåˆ—: ${this.messageQueue.length} æ¡æ¶ˆæ¯`)\n\n      while (this.messageQueue.length > 0) {\n        const message = this.messageQueue.shift()\n        if (!this.send(message)) {\n          // å‘é€å¤±è´¥ï¼Œé‡æ–°åŠ å…¥é˜Ÿåˆ—\n          this.messageQueue.unshift(message)\n          break\n        }\n      }\n    }\n  }\n\n  /**\n   * ğŸ”§ äº‹ä»¶ç›‘å¬\n   */\n  on(event, handler) {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, new Set())\n    }\n    this.eventHandlers.get(event).add(handler)\n    console.log(`ğŸ“¡ [${this.windowId}] æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨: ${event}`)\n  }\n\n  /**\n   * ğŸ”§ ç§»é™¤äº‹ä»¶ç›‘å¬\n   */\n  off(event, handler) {\n    if (this.eventHandlers.has(event)) {\n      this.eventHandlers.get(event).delete(handler)\n      console.log(`ğŸ“¡ [${this.windowId}] ç§»é™¤äº‹ä»¶ç›‘å¬å™¨: ${event}`)\n    }\n  }\n\n  /**\n   * ğŸ”§ è§¦å‘äº‹ä»¶\n   */\n  emit(event, data) {\n    if (this.eventHandlers.has(event)) {\n      this.eventHandlers.get(event).forEach(handler => {\n        try {\n          handler(data)\n        } catch (error) {\n          console.error(`âŒ [${this.windowId}] äº‹ä»¶å¤„ç†å™¨é”™è¯¯ [${event}]:`, error)\n        }\n      })\n    }\n  }\n\n  /**\n   * ğŸ”§ æœåŠ¡å™¨é”å®š\n   */\n  lockServer(serverUrl) {\n    this.lockedServer = serverUrl\n    this.lockTimestamp = Date.now()\n    console.log(`ğŸ”’ [${this.windowId}] é”å®šæœåŠ¡å™¨: ${serverUrl}`)\n    console.log(`ğŸ• [${this.windowId}] é”å®šæ—¶é—´: ${new Date(this.lockTimestamp).toLocaleTimeString()}`)\n\n    this.emit('server:locked', {\n      server: serverUrl,\n      timestamp: this.lockTimestamp,\n      windowId: this.windowId\n    })\n  }\n\n  /**\n   * ğŸ”§ è§£é”æœåŠ¡å™¨\n   */\n  unlockServer() {\n    if (this.lockedServer) {\n      console.log(`ğŸ”“ [${this.windowId}] è§£é”æœåŠ¡å™¨: ${this.lockedServer}`)\n      const unlockedServer = this.lockedServer\n      this.lockedServer = null\n      this.lockTimestamp = null\n\n      this.emit('server:unlocked', {\n        server: unlockedServer,\n        windowId: this.windowId\n      })\n    }\n  }\n\n  /**\n   * ğŸ”§ è·å–ç›®æ ‡æœåŠ¡å™¨\n   */\n  async getTargetServer() {\n    // å¦‚æœæœ‰é”å®šçš„æœåŠ¡å™¨ï¼Œä¼˜å…ˆä½¿ç”¨\n    if (this.lockedServer) {\n      console.log(`ğŸ”’ [${this.windowId}] ä½¿ç”¨é”å®šçš„æœåŠ¡å™¨: ${this.lockedServer}`)\n      return this.lockedServer\n    }\n\n    // ä»è´Ÿè½½å‡è¡¡å™¨è·å–æœ€ä¼˜æœåŠ¡å™¨\n    try {\n      const optimalServer = await loadBalancer.getOptimalServer()\n      console.log(`ğŸ¯ [${this.windowId}] è´Ÿè½½å‡è¡¡é€‰æ‹©æœåŠ¡å™¨: ${optimalServer}`)\n      return optimalServer\n    } catch (error) {\n      console.error(`âŒ [${this.windowId}] è·å–æœåŠ¡å™¨å¤±è´¥:`, error)\n      return null\n    }\n  }\n\n  /**\n   * ğŸ”§ å¯åŠ¨å¥åº·æ£€æŸ¥\n   */\n  startHealthCheck() {\n    this.stopHealthCheck() // æ¸…ç†ä¹‹å‰çš„æ£€æŸ¥\n\n    this.healthCheckInterval = setInterval(() => {\n      this.performHealthCheck()\n    }, 30000) // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡\n\n    console.log(`ğŸ’“ [${this.windowId}] å¯åŠ¨å¥åº·æ£€æŸ¥`)\n  }\n\n  /**\n   * ğŸ”§ åœæ­¢å¥åº·æ£€æŸ¥\n   */\n  stopHealthCheck() {\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval)\n      this.healthCheckInterval = null\n      console.log(`ğŸ’“ [${this.windowId}] åœæ­¢å¥åº·æ£€æŸ¥`)\n    }\n  }\n\n  /**\n   * ğŸ”§ æ‰§è¡Œå¥åº·æ£€æŸ¥\n   */\n  performHealthCheck() {\n    const now = Date.now()\n\n    // æ£€æŸ¥è¿æ¥çŠ¶æ€\n    if (this.connection && this.connection.readyState !== WebSocket.OPEN) {\n      console.warn(`âš ï¸ [${this.windowId}] å¥åº·æ£€æŸ¥: WebSocketè¿æ¥å¼‚å¸¸`)\n      this.scheduleReconnect()\n      return\n    }\n\n    // æ£€æŸ¥æ¶ˆæ¯æ´»è·ƒåº¦\n    if (this.lastMessageTime && (now - this.lastMessageTime) > 120000) { // 2åˆ†é’Ÿæ— æ¶ˆæ¯\n      console.warn(`âš ï¸ [${this.windowId}] å¥åº·æ£€æŸ¥: é•¿æ—¶é—´æ— æ¶ˆæ¯`)\n    }\n\n    console.log(`ğŸ’“ [${this.windowId}] å¥åº·æ£€æŸ¥é€šè¿‡`)\n  }\n\n  /**\n   * ğŸ”§ æ£€æŸ¥è¿æ¥å¥åº·çŠ¶æ€\n   */\n  checkConnectionHealth() {\n    if (this.state === WS_STATE.CONNECTED && this.connection) {\n      if (this.connection.readyState !== WebSocket.OPEN) {\n        console.warn(`âš ï¸ [${this.windowId}] è¿æ¥çŠ¶æ€å¼‚å¸¸ï¼Œå°è¯•é‡è¿`)\n        this.scheduleReconnect()\n      }\n    }\n  }\n\n  /**\n   * ğŸ”§ è°ƒåº¦é‡è¿\n   */\n  scheduleReconnect() {\n    if (this.reconnectTimer) {\n      return // å·²ç»åœ¨é‡è¿ä¸­\n    }\n\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error(`âŒ [${this.windowId}] é‡è¿æ¬¡æ•°è¶…é™ï¼Œåœæ­¢é‡è¿`)\n      this.state = WS_STATE.FAILED\n      this.emit('reconnect:failed', { windowId: this.windowId })\n      return\n    }\n\n    this.state = WS_STATE.RECONNECTING\n    this.reconnectAttempts++\n\n    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1) // æŒ‡æ•°é€€é¿\n\n    console.log(`ğŸ”„ [${this.windowId}] è°ƒåº¦é‡è¿ (ç¬¬${this.reconnectAttempts}æ¬¡ï¼Œ${delay}mså)`)\n\n    this.reconnectTimer = setTimeout(async () => {\n      this.reconnectTimer = null\n\n      try {\n        await this.connect(this.lockedServer)\n        console.log(`âœ… [${this.windowId}] é‡è¿æˆåŠŸ`)\n        this.emit('reconnect:success', { windowId: this.windowId })\n      } catch (error) {\n        console.error(`âŒ [${this.windowId}] é‡è¿å¤±è´¥:`, error)\n        this.scheduleReconnect() // ç»§ç»­å°è¯•é‡è¿\n      }\n    }, delay)\n  }\n\n  /**\n   * ğŸ”§ æ¸…é™¤é‡è¿å®šæ—¶å™¨\n   */\n  clearReconnectTimer() {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer)\n      this.reconnectTimer = null\n      console.log(`ğŸ§¹ [${this.windowId}] æ¸…é™¤é‡è¿å®šæ—¶å™¨`)\n    }\n  }\n"
        }
    ]
}