{
    "sourceFile": "client/src/services/webSocketMessageHandler.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1753506659483,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1753506659483,
            "name": "Commit-0",
            "content": "// WebSocket 消息处理器 - 独立模块\n// 负责所有 WebSocket 消息的解析、路由和处理逻辑\n\nimport webSocketManager, { WINDOW_ID, WINDOW_CLIENT_ID } from './webSocketManager.js'\n\n/**\n * WebSocket 消息处理器类\n * 处理所有类型的 WebSocket 消息\n */\nclass WebSocketMessageHandler {\n  constructor(manager) {\n    this.manager = manager\n  }\n\n  // 🔥 防抖机制：避免频繁的进度回调触发递归更新\n  safeProgressCallback(promptId, task, message, percent) {\n    if (!task.onProgress) return\n\n    // 防抖：同一任务的进度回调间隔至少100ms\n    const lastCallTime = this.manager.progressCallbackDebounce.get(promptId) || 0\n    const now = Date.now()\n\n    if (now - lastCallTime < 100) {\n      console.log(`🚫 [${WINDOW_ID}] 进度回调防抖: ${promptId} (${percent}%)`)\n      return\n    }\n\n    this.manager.progressCallbackDebounce.set(promptId, now)\n\n    try {\n      // 使用queueMicrotask避免递归更新\n      queueMicrotask(() => {\n        try {\n          task.onProgress(message, percent)\n        } catch (callbackError) {\n          console.error(`❌ [${WINDOW_ID}] 进度回调执行失败: ${promptId}`, callbackError)\n\n          // 如果是递归更新错误，停止后续回调\n          if (callbackError.message?.includes('Maximum recursive updates')) {\n            console.error(`🔥 [${WINDOW_ID}] 检测到递归更新，禁用进度回调: ${promptId}`)\n            task.onProgress = null\n          }\n        }\n      })\n    } catch (error) {\n      console.error(`❌ [${WINDOW_ID}] 安全进度回调失败: ${promptId}`, error)\n    }\n  }\n\n  // 🔥 跨服务器隔离的WebSocket消息处理 - 基于官方API文档重构\n  handleWebSocketMessage(message) {\n    try {\n      if (!message || typeof message !== 'object') {\n        return\n      }\n\n      const { type, data } = message\n\n      // 静默处理crystools.monitor消息，避免干扰正常消息处理\n      if (type === 'crystools.monitor') {\n        // 静默忽略crystools插件的监控消息\n        return\n      }\n\n      // 🔥 简化消息过滤：如果找到任务就处理，不严格限制窗口归属\n      if (data && data.prompt_id) {\n        const task = this.manager.getWindowTask(data.prompt_id)\n        if (!task) {\n          // 任务不存在，可能是其他窗口的消息，静默忽略\n          return\n        }\n\n        // 🔥 验证消息来源服务器一致性\n        const currentLock = this.manager.getWindowServerLock()\n        if (currentLock && task.executionServer && task.executionServer !== currentLock.server) {\n          console.warn(`⚠️ [${WINDOW_ID}] 跨服务器消息检测: 任务在 ${task.executionServer}, 当前锁定 ${currentLock.server}`)\n          // 仍然处理消息，但记录警告以便调试\n        }\n\n        // 🔥 记录消息处理日志（用于跨服务器调试）\n        console.log(`📨 [${WINDOW_ID}] 处理消息: ${type} (prompt_id: ${data.prompt_id}, 服务器: ${task.executionServer || '未知'})`)\n      }\n\n      // 🔥 新增：处理progress_state消息\n      if (type === 'progress_state' && data?.prompt_id) {\n        console.log(`📊 [${WINDOW_ID}] progress_state消息: ${data.prompt_id}`)\n        this.handleProgressStateMessage(data)\n        return\n      }\n\n      // 根据官方WebSocket API文档处理所有标准消息类型\n      switch (type) {\n        case 'status':\n          // 服务器状态和队列信息\n          this.handleStatusMessage(data)\n          break\n\n        case 'execution_start':\n          // 任务开始执行 - 官方标准状态检测\n          this.handleExecutionStartMessage(data)\n          break\n\n        case 'executing':\n          // 节点执行状态 - 官方标准完成检测\n          this.handleExecutingMessage(data)\n          break\n\n        case 'progress':\n          // 节点执行进度\n          this.handleProgressMessage(data)\n          break\n\n        case 'executed':\n          // 节点执行完成\n          this.handleExecutedMessage(data)\n          break\n\n        case 'execution_cached':\n          // 节点缓存命中\n          this.handleExecutionCachedMessage(data)\n          break\n\n        case 'execution_error':\n          // 执行错误\n          this.handleExecutionErrorMessage(data)\n          break\n\n        case 'execution_interrupted':\n          // 执行中断\n          this.handleExecutionInterruptedMessage(data)\n          break\n\n        default:\n          // 记录未知消息类型用于调试\n          console.log(`🔍 [OFFICIAL] 未知消息类型: ${type}`, data)\n      }\n\n    } catch (error) {\n      console.error('❌ [OFFICIAL] WebSocket消息处理失败:', error)\n    }\n  }\n\n  // 🔥 新增：处理progress_state消息\n  handleProgressStateMessage(data) {\n    const { prompt_id, nodes } = data\n    const task = this.manager.getWindowTask(prompt_id)\n\n    if (!task) {\n      console.log(`⚠️ [${WINDOW_ID}] progress_state: 未找到任务 ${prompt_id}`)\n      return\n    }\n\n    console.log(`📊 [${WINDOW_ID}] 处理progress_state: ${prompt_id}`)\n\n    // 分析节点状态，计算整体进度\n    let completedNodes = 0\n    let totalNodes = 0\n\n    for (const nodeId in nodes) {\n      totalNodes++\n      const nodeState = nodes[nodeId]\n\n      // 检查节点是否完成（根据实际状态字段调整）\n      if (nodeState.completed || nodeState.status === 'completed') {\n        completedNodes++\n      }\n    }\n\n    // 计算进度百分比\n    const progressPercent = totalNodes > 0 ? Math.round((completedNodes / totalNodes) * 100) : 0\n\n    console.log(`📊 [${WINDOW_ID}] 节点进度: ${completedNodes}/${totalNodes} (${progressPercent}%)`)\n\n    // 更新任务进度\n    if (progressPercent > 85) {\n      this.safeProgressCallback(prompt_id, task, `处理中... (${completedNodes}/${totalNodes} 节点)`, progressPercent)\n    }\n\n    // 如果所有节点都完成，触发任务完成\n    if (completedNodes === totalNodes && totalNodes > 0) {\n      console.log(`✅ [${WINDOW_ID}] progress_state检测到任务完成: ${prompt_id}`)\n      queueMicrotask(() => {\n        this.handleTaskCompletion(prompt_id)\n      })\n    }\n  }\n\n  // 🔥 处理服务器状态消息 - 官方标准队列检测（窗口隔离版本）\n  handleStatusMessage(data) {\n    if (!data || !data.status) {\n      return\n    }\n\n    const execInfo = data.status.exec_info\n    if (!execInfo) {\n      return\n    }\n\n    const queueRemaining = execInfo.queue_remaining || 0\n    console.log(`📊 [${WINDOW_ID}] 服务器队列状态: ${queueRemaining} 个任务等待`)\n\n    // 🔧 只更新属于当前窗口的等待中任务状态\n    this.manager.windowTasks.forEach((task, promptId) => {\n      // 确保任务属于当前窗口\n      if (task.windowId === WINDOW_ID && task.status === this.manager.TASK_STATUS.WAITING) {\n        if (queueRemaining > 1) {\n          // 多个任务等待时显示具体数量\n          this.safeProgressCallback(promptId, task, `队列中还有 ${queueRemaining} 个任务等待`, 8)\n        } else if (queueRemaining === 1) {\n          // 只有一个任务等待时的提示\n          this.safeProgressCallback(promptId, task, '队列中还有 1 个任务等待', 10)\n        } else {\n          // 队列为空，即将开始处理\n          this.safeProgressCallback(promptId, task, '即将开始处理...', 12)\n        }\n      }\n    })\n  }\n\n  // 🔥 处理任务开始执行消息 - 官方标准状态检测（窗口隔离版本）\n  handleExecutionStartMessage(data) {\n    if (!data || !data.prompt_id) {\n      return\n    }\n\n    const promptId = data.prompt_id\n\n    // 🔧 只处理属于当前窗口的任务\n    const task = this.manager.getWindowTask(promptId)\n    if (!task) {\n      console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的执行开始消息: ${promptId}`)\n      return\n    }\n\n    console.log(`🚀 [${WINDOW_ID}] 任务开始执行: ${promptId}`)\n\n    // 原子性状态更新：waiting → executing\n    const updated = this.manager.updateTaskStatus(promptId, this.manager.TASK_STATUS.EXECUTING, {\n      executionStartTime: Date.now(),\n      currentNode: null,\n      completedNodes: []\n    })\n\n    if (updated) {\n      // 🔧 使用安全进度回调\n      this.safeProgressCallback(promptId, task, '任务开始执行...', 15)\n    }\n  }\n\n  // 🔥 处理节点缓存命中消息（窗口隔离版本）\n  handleExecutionCachedMessage(data) {\n    if (!data || !data.prompt_id || !data.nodes) {\n      return\n    }\n\n    const promptId = data.prompt_id\n\n    // 🔧 只处理属于当前窗口的任务\n    const task = this.manager.getWindowTask(promptId)\n    if (!task) {\n      console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的缓存命中消息: ${promptId}`)\n      return\n    }\n\n    console.log(`⚡ [${WINDOW_ID}] 缓存命中: ${promptId}, 节点: [${data.nodes.join(', ')}]`)\n\n    // 🔧 使用安全进度回调\n    this.safeProgressCallback(promptId, task, `缓存命中 ${data.nodes.length} 个节点`, 25)\n  }\n\n  // 🔥 处理执行错误消息（窗口隔离版本）\n  handleExecutionErrorMessage(data) {\n    if (!data || !data.prompt_id) {\n      return\n    }\n\n    const promptId = data.prompt_id\n\n    // 🔧 只处理属于当前窗口的任务\n    const task = this.manager.getWindowTask(promptId)\n    if (!task) {\n      console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的执行错误消息: ${promptId}`)\n      return\n    }\n\n    console.error(`❌ [${WINDOW_ID}] 任务执行错误: ${promptId}`, data)\n\n    // 原子性状态更新：* → error\n    const updated = this.manager.updateTaskStatus(promptId, this.manager.TASK_STATUS.ERROR, {\n      errorTime: Date.now(),\n      errorData: data\n    })\n\n    if (updated) {\n      // 清理任务\n      this.manager.removeWindowTask(promptId)\n\n      if (task.onError) {\n        const error = new Error(`执行错误: ${data.exception_message || '未知错误'}`)\n        error.details = data\n        task.onError(error)\n      }\n    }\n  }\n\n  // 🔥 处理执行中断消息（窗口隔离版本）\n  handleExecutionInterruptedMessage(data) {\n    if (!data || !data.prompt_id) {\n      return\n    }\n\n    const promptId = data.prompt_id\n\n    // 🔧 只处理属于当前窗口的任务\n    const task = this.manager.getWindowTask(promptId)\n    if (!task) {\n      console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的执行中断消息: ${promptId}`)\n      return\n    }\n\n    console.warn(`⚠️ [${WINDOW_ID}] 任务被中断: ${promptId}`)\n\n    // 原子性状态更新：* → interrupted\n    const updated = this.manager.updateTaskStatus(promptId, this.manager.TASK_STATUS.INTERRUPTED, {\n      interruptTime: Date.now()\n    })\n\n    if (updated) {\n      // 清理任务\n      this.manager.removeWindowTask(promptId)\n\n      if (task.onError) {\n        task.onError(new Error('任务执行被中断'))\n      }\n    }\n  }\n\n  // 🔥 处理节点执行完成消息 - 重构版本（窗口隔离版本）\n  handleExecutedMessage(data) {\n    if (!data || !data.prompt_id || !data.node) {\n      return\n    }\n\n    const promptId = data.prompt_id\n\n    // 🔧 只处理属于当前窗口的任务\n    const task = this.manager.getWindowTask(promptId)\n    if (!task || task.status !== this.manager.TASK_STATUS.EXECUTING) {\n      if (!task) {\n        console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的节点完成消息: ${promptId}`)\n      }\n      return\n    }\n\n    console.log(`✅ [${WINDOW_ID}] 节点完成: ${data.node} (任务: ${promptId})`)\n\n    // 记录完成的节点\n    if (!task.completedNodes) {\n      task.completedNodes = []\n    }\n    task.completedNodes.push(data.node)\n\n    // 🔧 使用安全进度回调\n    this.safeProgressCallback(promptId, task, `节点 ${data.node} 完成`, 60)\n  }\n\n  // 🔥 处理节点执行进度消息 - 重构版本（窗口隔离版本）\n  handleProgressMessage(data) {\n    if (!data || !data.prompt_id) {\n      return\n    }\n\n    const promptId = data.prompt_id\n\n    // 🔧 只处理属于当前窗口的任务\n    const task = this.manager.getWindowTask(promptId)\n    if (!task || task.status !== this.manager.TASK_STATUS.EXECUTING) {\n      if (!task) {\n        console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的进度消息: ${promptId}`)\n      }\n      return\n    }\n\n    if (data.value !== undefined && data.max !== undefined) {\n      const progress = Math.round((data.value / data.max) * 100)\n      const overallProgress = 40 + (progress * 0.5) // 40-90%区间\n\n      console.log(`📈 [${WINDOW_ID}] 进度更新: ${promptId} - ${data.value}/${data.max} (${progress}%)`)\n\n      // 🔧 使用安全进度回调\n      this.safeProgressCallback(promptId, task, `处理进度: ${data.value}/${data.max}`, overallProgress)\n    }\n  }\n\n  // 🔥 处理节点执行状态消息 - 官方标准完成检测（窗口隔离版本）\n  handleExecutingMessage(data) {\n    if (!data || !data.prompt_id) {\n      return\n    }\n\n    const promptId = data.prompt_id\n\n    // 🔧 只处理属于当前窗口的任务\n    const task = this.manager.getWindowTask(promptId)\n    if (!task) {\n      console.log(`🔍 [${WINDOW_ID}] 忽略其他窗口的执行状态消息: ${promptId}`)\n      return\n    }\n\n    // 官方标准双重条件检测：data.node === null && data.prompt_id === promptId\n    if (data.node === null && data.prompt_id === promptId) {\n      console.log(`🎯 [${WINDOW_ID}] 任务执行完成: ${promptId}`)\n\n      // 原子性状态更新：executing → completed\n      this.manager.updateTaskStatus(promptId, this.manager.TASK_STATUS.COMPLETED, {\n        completionTime: Date.now()\n      })\n\n      // 立即处理任务完成\n      this.handleTaskCompletion(promptId)\n\n    } else if (data.node !== null) {\n      // 正在执行某个节点\n      console.log(`⚙️ [${WINDOW_ID}] 执行节点: ${data.node} (任务: ${promptId})`)\n\n      // 更新当前执行节点\n      if (task.status === this.manager.TASK_STATUS.EXECUTING) {\n        task.currentNode = data.node\n\n        if (task.onProgress) {\n          task.onProgress(`正在执行: ${data.node}`, 40)\n        }\n      }\n    }\n  }\n\n  // 🔥 跨服务器任务完成处理 - 立即响应版本（消除延迟）\n  async handleTaskCompletion(promptId) {\n    // 🔧 只处理属于当前窗口的任务\n    const task = this.manager.getWindowTask(promptId)\n    if (!task) {\n      console.warn(`⚠️ [${WINDOW_ID}] 任务未找到或不属于当前窗口: ${promptId}`)\n      return\n    }\n\n    console.log(`🚀 [${WINDOW_ID}] 开始立即处理任务完成: ${promptId} (服务器: ${task.executionServer || '未知'})`)\n\n    try {\n      // 🔧 立即更新进度到98%，表示正在获取结果\n      if (task.onProgress) {\n        task.onProgress('正在获取处理结果...', 98)\n      }\n\n      console.log(`🔍 [${WINDOW_ID}] 立即获取任务历史记录: ${promptId} (服务器: ${task.executionServer || '未知'})`)\n\n      // 这里需要调用外部的历史记录获取函数\n      // 由于这是独立模块，我们需要通过回调或事件来处理\n      if (task.onComplete) {\n        // 🔧 立即更新进度到100%\n        if (task.onProgress) {\n          task.onProgress('处理完成', 100)\n        }\n\n        // 🔧 立即清理任务并调用完成回调\n        this.manager.removeWindowTask(promptId)\n        console.log(`🧹 [${WINDOW_ID}] 任务清理完成: ${promptId}`)\n\n        // 🔧 检查是否可以解锁服务器\n        this.manager.checkServerUnlockCondition()\n\n        console.log(`🎉 [${WINDOW_ID}] 立即调用完成回调: ${promptId}`)\n        // 🔧 使用setTimeout(0)确保回调立即执行（浏览器兼容）\n        setTimeout(() => {\n          // 这里需要传递一个基本的结果对象，实际的结果获取由外部处理\n          task.onComplete({ promptId, executionServer: task.executionServer })\n        }, 0)\n      }\n\n    } catch (error) {\n      console.error(`❌ [${WINDOW_ID}] 任务完成处理失败: ${promptId}`, error.message)\n\n      // 立即清理任务并调用错误回调\n      this.manager.removeWindowTask(promptId)\n\n      // 🔧 检查是否可以解锁服务器\n      this.manager.checkServerUnlockCondition()\n\n      if (task.onError) {\n        // 🔧 使用setTimeout(0)确保错误回调立即执行（浏览器兼容）\n        setTimeout(() => {\n          task.onError(error.message)\n        }, 0)\n      }\n    }\n  }\n}\n\n// 创建消息处理器实例\nconst messageHandler = new WebSocketMessageHandler(webSocketManager)\n\n// 将消息处理方法添加到主管理器\nwebSocketManager.handleWebSocketMessage = messageHandler.handleWebSocketMessage.bind(messageHandler)\nwebSocketManager.safeProgressCallback = messageHandler.safeProgressCallback.bind(messageHandler)\n\nexport default messageHandler\nexport { messageHandler }\n"
        }
    ]
}