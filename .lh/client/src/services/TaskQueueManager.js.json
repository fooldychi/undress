{
    "sourceFile": "client/src/services/TaskQueueManager.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1753203379058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753328893606,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -180,32 +180,46 @@\n     }\n   }\n \n   /**\n-   * ğŸ”§ æ‰§è¡ŒComfyUIä»»åŠ¡\n+   * ğŸ”§ æ‰§è¡ŒComfyUIä»»åŠ¡ - è·¨æœåŠ¡å™¨éš”ç¦»ç‰ˆæœ¬\n    * @param {Object} task - ä»»åŠ¡å¯¹è±¡\n    * @returns {Promise} ä»»åŠ¡ç»“æœ\n    */\n   async runComfyUITask(task) {\n     return new Promise((resolve, reject) => {\n       const { workflow, onProgress, onComplete, onError } = task\n \n-      // åŒ…è£…è¿›åº¦å›è°ƒ\n+      // ğŸ”¥ è·å–ä»»åŠ¡ç»‘å®šçš„æœåŠ¡å™¨ä¿¡æ¯\n+      let taskServer = null\n+\n+      // åŒ…è£…è¿›åº¦å›è°ƒ - å¢åŠ æœåŠ¡å™¨éš”ç¦»æ£€æŸ¥\n       const progressWrapper = (message, percent) => {\n         // æ›´æ–°ä»»åŠ¡è¿›åº¦çŠ¶æ€\n         const processingTask = this.processingTasks.get(task.id)\n         if (processingTask) {\n           processingTask.lastProgressUpdate = Date.now()\n           processingTask.progressHistory.push({\n             message,\n             percent,\n-            timestamp: Date.now()\n+            timestamp: Date.now(),\n+            server: taskServer // è®°å½•æœåŠ¡å™¨ä¿¡æ¯\n           })\n \n           // é™åˆ¶è¿›åº¦å†å²è®°å½•æ•°é‡\n           if (processingTask.progressHistory.length > 50) {\n             processingTask.progressHistory = processingTask.progressHistory.slice(-25)\n           }\n+\n+          // ğŸ”¥ æ£€æŸ¥52.25%å¡ä½é—®é¢˜ - è·¨æœåŠ¡å™¨ç‰ˆæœ¬\n+          if (percent === 52.25) {\n+            console.warn(`ğŸš¨ [QUEUE] æ£€æµ‹åˆ°52.25%å¡ä½é—®é¢˜: ${task.id} (æœåŠ¡å™¨: ${taskServer})`)\n+\n+            // å»¶è¿Ÿæ£€æŸ¥ä»»åŠ¡æ˜¯å¦çœŸçš„å¡ä½\n+            setTimeout(() => {\n+              this.checkTaskStuckAt5225(task.id, taskServer)\n+            }, 30000) // 30ç§’åæ£€æŸ¥\n+          }\n         }\n \n         // è°ƒç”¨åŸå§‹è¿›åº¦å›è°ƒ\n         if (onProgress) {\n@@ -216,26 +230,43 @@\n           }\n         }\n       }\n \n-      // åŒ…è£…å®Œæˆå›è°ƒ\n+      // åŒ…è£…å®Œæˆå›è°ƒ - å¢åŠ æœåŠ¡å™¨éªŒè¯\n       const completeWrapper = (results) => {\n+        // ğŸ”¥ éªŒè¯ç»“æœæ¥æºæœåŠ¡å™¨\n+        if (taskServer && results.executionServer && results.executionServer !== taskServer) {\n+          console.warn(`âš ï¸ [QUEUE] ä»»åŠ¡ ${task.id} æœåŠ¡å™¨ä¸ä¸€è‡´: é¢„æœŸ ${taskServer}, å®é™… ${results.executionServer}`)\n+        }\n+\n+        // ç¡®ä¿ç»“æœåŒ…å«æ­£ç¡®çš„æœåŠ¡å™¨ä¿¡æ¯\n+        results.queueTaskId = task.id\n+        results.queueServer = taskServer\n+\n         resolve(results)\n       }\n \n       // åŒ…è£…é”™è¯¯å›è°ƒ\n       const errorWrapper = (error) => {\n+        console.error(`âŒ [QUEUE] ä»»åŠ¡ ${task.id} å¤±è´¥ (æœåŠ¡å™¨: ${taskServer}):`, error)\n         reject(error)\n       }\n \n       // ç”ŸæˆpromptIdå¹¶æäº¤å·¥ä½œæµ\n       const promptId = generatePromptId()\n       console.log(`ğŸ†” [QUEUE] ç”ŸæˆpromptId: ${promptId} for task: ${task.id}`)\n \n+      // ğŸ”¥ ä¿å­˜promptIdåˆ°ä»»åŠ¡å¯¹è±¡ï¼Œç”¨äºè·¨æœåŠ¡å™¨æ¢å¤\n+      const processingTask = this.processingTasks.get(task.id)\n+      if (processingTask) {\n+        processingTask.promptId = promptId\n+      }\n+\n       // åˆ›å»ºä¸´æ—¶ä»»åŠ¡å¯¹è±¡\n       const tempTask = {\n         workflowType: task.workflowType || 'default',\n         createdAt: new Date().toISOString(),\n+        queueTaskId: task.id, // ğŸ”¥ å…³è”é˜Ÿåˆ—ä»»åŠ¡ID\n         onProgress: progressWrapper,\n         onComplete: null,\n         onError: null\n       }\n@@ -244,8 +275,21 @@\n       submitWorkflow(workflow, promptId, tempTask)\n         .then(submittedPromptId => {\n           console.log(`âœ… [QUEUE] å·¥ä½œæµæäº¤æˆåŠŸ: ${submittedPromptId} for task: ${task.id}`)\n \n+          // ğŸ”¥ è·å–ä»»åŠ¡ç»‘å®šçš„æœåŠ¡å™¨\n+          const { getWindowTask } = require('./comfyui.js')\n+          const comfyTask = getWindowTask(submittedPromptId)\n+          if (comfyTask && comfyTask.executionServer) {\n+            taskServer = comfyTask.executionServer\n+            console.log(`ğŸ”’ [QUEUE] ä»»åŠ¡ ${task.id} ç»‘å®šæœåŠ¡å™¨: ${taskServer}`)\n+\n+            // æ›´æ–°å¤„ç†ä¸­ä»»åŠ¡çš„æœåŠ¡å™¨ä¿¡æ¯\n+            if (processingTask) {\n+              processingTask.executionServer = taskServer\n+            }\n+          }\n+\n           // ç­‰å¾…ä»»åŠ¡å®Œæˆ\n           return waitForTaskCompletion(submittedPromptId, progressWrapper, task.workflowType)\n         })\n         .then(result => {\n"
                },
                {
                    "date": 1753328937168,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -446,27 +446,45 @@\n     })\n   }\n \n   /**\n-   * ğŸ”§ å°è¯•ä»»åŠ¡æ¢å¤\n+   * ğŸ”§ å°è¯•ä»»åŠ¡æ¢å¤ - è·¨æœåŠ¡å™¨ç‰ˆæœ¬\n    * @param {string} taskId - ä»»åŠ¡ID\n    */\n   async attemptTaskRecovery(taskId) {\n     const task = this.processingTasks.get(taskId)\n     if (!task) return\n \n-    console.log(`ğŸ”§ å°è¯•æ¢å¤å¡ä½çš„ä»»åŠ¡: ${taskId}`)\n+    console.log(`ğŸ”§ å°è¯•æ¢å¤å¡ä½çš„ä»»åŠ¡: ${taskId} (æœåŠ¡å™¨: ${task.executionServer})`)\n \n     try {\n-      // æ–¹æ³•1: æ£€æŸ¥æœåŠ¡å™¨ç«¯ä»»åŠ¡çŠ¶æ€\n-      const { getTaskHistory, handleTaskCompletion } = await import('./comfyui.js')\n+      // ğŸ”¥ æ–¹æ³•1: æ£€æŸ¥ç‰¹å®šæœåŠ¡å™¨ä¸Šçš„ä»»åŠ¡çŠ¶æ€\n+      const { getTaskHistory, handleTaskCompletion, getApiBaseUrl } = await import('./comfyui.js')\n \n-      // å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªæ–¹æ³•æ¥è·å–ä¸ä»»åŠ¡å…³è”çš„promptId\n+      // è·å–ä¸ä»»åŠ¡å…³è”çš„promptId\n       const promptId = task.promptId || taskId\n \n-      const history = await getTaskHistory(promptId)\n+      // ğŸ”¥ ç¡®ä¿ä½¿ç”¨ä»»åŠ¡ç»‘å®šçš„æœåŠ¡å™¨è·å–å†å²è®°å½•\n+      let history\n+      if (task.executionServer) {\n+        // ç›´æ¥ä»ä»»åŠ¡ç»‘å®šçš„æœåŠ¡å™¨è·å–å†å²è®°å½•\n+        const url = `${task.executionServer}/history/${promptId}`\n+        console.log(`ğŸ” [QUEUE] ä»ç»‘å®šæœåŠ¡å™¨è·å–å†å²è®°å½•: ${url}`)\n+\n+        const response = await fetch(url)\n+        if (response.ok) {\n+          const fullHistory = await response.json()\n+          history = { [promptId]: fullHistory[promptId] }\n+        } else {\n+          throw new Error(`æœåŠ¡å™¨ ${task.executionServer} å†å²è®°å½•è·å–å¤±è´¥: ${response.status}`)\n+        }\n+      } else {\n+        // å›é€€åˆ°é»˜è®¤æ–¹æ³•\n+        history = await getTaskHistory(promptId)\n+      }\n+\n       if (history[promptId] && history[promptId].outputs) {\n-        console.log(`âœ… å‘ç°ä»»åŠ¡å®é™…å·²å®Œæˆï¼Œè§¦å‘å®Œæˆå¤„ç†: ${taskId}`)\n+        console.log(`âœ… å‘ç°ä»»åŠ¡å®é™…å·²å®Œæˆï¼Œè§¦å‘å®Œæˆå¤„ç†: ${taskId} (æœåŠ¡å™¨: ${task.executionServer})`)\n \n         // æ‰‹åŠ¨è§¦å‘å®Œæˆ\n         await handleTaskCompletion(promptId)\n \n@@ -474,16 +492,105 @@\n         this.handleTaskSuccess(taskId, history[promptId])\n         return\n       }\n     } catch (error) {\n-      console.warn(`âš ï¸ ä»»åŠ¡æ¢å¤å¤±è´¥: ${taskId}`, error)\n+      console.warn(`âš ï¸ ä»»åŠ¡æ¢å¤å¤±è´¥: ${taskId} (æœåŠ¡å™¨: ${task.executionServer})`, error)\n     }\n \n     // æ–¹æ³•2: å¦‚æœæ¢å¤å¤±è´¥ï¼Œæ ‡è®°ä¸ºè¶…æ—¶å¹¶é‡è¯•\n-    this.handleTaskFailure(taskId, new Error('ä»»åŠ¡è¿›åº¦è¶…æ—¶ï¼Œè‡ªåŠ¨é‡è¯•'))\n+    this.handleTaskFailure(taskId, new Error(`ä»»åŠ¡è¿›åº¦è¶…æ—¶ï¼Œè‡ªåŠ¨é‡è¯• (æœåŠ¡å™¨: ${task.executionServer})`))\n   }\n \n   /**\n+   * ğŸ”¥ æ£€æŸ¥52.25%å¡ä½é—®é¢˜ - è·¨æœåŠ¡å™¨ç‰ˆæœ¬\n+   * @param {string} taskId - ä»»åŠ¡ID\n+   * @param {string} server - æœåŠ¡å™¨åœ°å€\n+   */\n+  async checkTaskStuckAt5225(taskId, server) {\n+    const task = this.processingTasks.get(taskId)\n+    if (!task) return\n+\n+    // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦ä»ç„¶å¡åœ¨52.25%\n+    const latestProgress = task.progressHistory[task.progressHistory.length - 1]\n+    if (latestProgress && latestProgress.percent === 52.25) {\n+      const stuckTime = Date.now() - latestProgress.timestamp\n+\n+      if (stuckTime > 30000) { // å¡ä½è¶…è¿‡30ç§’\n+        console.error(`ğŸš¨ [QUEUE] ä»»åŠ¡ ${taskId} ç¡®è®¤å¡åœ¨52.25% (æœåŠ¡å™¨: ${server}, å¡ä½æ—¶é—´: ${Math.round(stuckTime/1000)}ç§’)`)\n+\n+        // å°è¯•è·¨æœåŠ¡å™¨æ¢å¤\n+        await this.attemptCrossServerRecovery(taskId, server)\n+      }\n+    }\n+  }\n+\n+  /**\n+   * ğŸ”¥ è·¨æœåŠ¡å™¨æ¢å¤æœºåˆ¶\n+   * @param {string} taskId - ä»»åŠ¡ID\n+   * @param {string} server - æœåŠ¡å™¨åœ°å€\n+   */\n+  async attemptCrossServerRecovery(taskId, server) {\n+    const task = this.processingTasks.get(taskId)\n+    if (!task || !task.promptId) return\n+\n+    console.log(`ğŸ”§ [QUEUE] å¼€å§‹è·¨æœåŠ¡å™¨æ¢å¤: ${taskId} (æœåŠ¡å™¨: ${server})`)\n+\n+    try {\n+      // 1. ç›´æ¥æ£€æŸ¥ç»‘å®šæœåŠ¡å™¨çš„ä»»åŠ¡çŠ¶æ€\n+      const url = `${server}/history/${task.promptId}`\n+      console.log(`ğŸ” [QUEUE] æ£€æŸ¥æœåŠ¡å™¨ä»»åŠ¡çŠ¶æ€: ${url}`)\n+\n+      const response = await fetch(url)\n+      if (response.ok) {\n+        const history = await response.json()\n+\n+        if (history[task.promptId] && history[task.promptId].outputs) {\n+          console.log(`âœ… [QUEUE] å‘ç°ä»»åŠ¡åœ¨æœåŠ¡å™¨ ${server} ä¸Šå·²å®Œæˆ: ${taskId}`)\n+\n+          // æ„é€ ç»“æœå¯¹è±¡\n+          const results = {\n+            promptId: task.promptId,\n+            history: history[task.promptId],\n+            executionServer: server,\n+            queueTaskId: taskId,\n+            recoveredFromStuck: true\n+          }\n+\n+          // æå–å›¾ç‰‡URLç­‰ç»“æœ\n+          if (history[task.promptId].outputs) {\n+            const outputs = history[task.promptId].outputs\n+            const imageUrls = []\n+\n+            Object.values(outputs).forEach(output => {\n+              if (output.images) {\n+                output.images.forEach(img => {\n+                  const imageUrl = `${server}/view?filename=${img.filename}&subfolder=${img.subfolder}&type=${img.type}`\n+                  imageUrls.push(imageUrl)\n+                })\n+              }\n+            })\n+\n+            results.imageUrls = imageUrls\n+            results.images = imageUrls // å…¼å®¹æ€§\n+          }\n+\n+          // æ ‡è®°ä»»åŠ¡å®Œæˆ\n+          this.handleTaskSuccess(taskId, results)\n+          return\n+        }\n+      }\n+\n+      // 2. å¦‚æœä»»åŠ¡ç¡®å®æœªå®Œæˆï¼Œå°è¯•é‡æ–°æäº¤\n+      console.warn(`âš ï¸ [QUEUE] ä»»åŠ¡ ${taskId} åœ¨æœåŠ¡å™¨ ${server} ä¸Šç¡®å®æœªå®Œæˆï¼Œæ ‡è®°ä¸ºå¤±è´¥`)\n+      this.handleTaskFailure(taskId, new Error(`ä»»åŠ¡åœ¨æœåŠ¡å™¨ ${server} ä¸Šå¡ä½åœ¨52.25%`))\n+\n+    } catch (error) {\n+      console.error(`âŒ [QUEUE] è·¨æœåŠ¡å™¨æ¢å¤å¤±è´¥: ${taskId}`, error)\n+      this.handleTaskFailure(taskId, error)\n+    }\n+  }\n+\n+  /**\n    * ğŸ”§ è·å–ä¸‹ä¸€ä¸ªä»»åŠ¡ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰\n    * @returns {Object|null} ä¸‹ä¸€ä¸ªä»»åŠ¡\n    */\n   getNextTask() {\n"
                }
            ],
            "date": 1753203379058,
            "name": "Commit-0",
            "content": "/**\n * ğŸ”¥ ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†å™¨ - å½»åº•è§£å†³ComfyUIå®¢æˆ·ç«¯å¡ä½é—®é¢˜\n *\n * æ ¸å¿ƒåŠŸèƒ½ï¼š\n * 1. ä»»åŠ¡éš”ç¦»ï¼šæ¯ä¸ªä»»åŠ¡ç‹¬ç«‹å¤„ç†ï¼Œé¿å…ç›¸äº’å½±å“\n * 2. è¿›åº¦ç›‘æ§ï¼šå®æ—¶è·Ÿè¸ªä»»åŠ¡è¿›åº¦ï¼Œæ£€æµ‹é•¿æ—¶é—´æ— æ›´æ–°çš„ä»»åŠ¡\n * 3. è‡ªåŠ¨æ¢å¤ï¼šæ£€æµ‹åˆ°å¡ä½ä»»åŠ¡æ—¶è‡ªåŠ¨é‡è¯•æˆ–å¼ºåˆ¶å®Œæˆ\n * 4. WebSocketæ¶ˆæ¯å®Œæ•´å¤„ç†ï¼šç¡®ä¿handling executingã€executedã€progressç­‰æ‰€æœ‰å…³é”®æ¶ˆæ¯\n */\n\nimport {\n  submitWorkflow,\n  waitForTaskCompletion,\n  generatePromptId,\n  TASK_STATUS,\n  WINDOW_ID\n} from './comfyui.js'\n\n// ä»»åŠ¡çŠ¶æ€æšä¸¾\nexport const QUEUE_TASK_STATUS = {\n  QUEUED: 'queued',           // æ’é˜Ÿä¸­\n  PROCESSING: 'processing',   // å¤„ç†ä¸­\n  COMPLETED: 'completed',     // å·²å®Œæˆ\n  FAILED: 'failed',          // å¤±è´¥\n  CANCELLED: 'cancelled',     // å·²å–æ¶ˆ\n  TIMEOUT: 'timeout'         // è¶…æ—¶\n}\n\n// ä»»åŠ¡ä¼˜å…ˆçº§æšä¸¾\nexport const TASK_PRIORITY = {\n  LOW: 1,\n  NORMAL: 2,\n  HIGH: 3,\n  URGENT: 4\n}\n\nclass TaskQueueManager {\n  constructor() {\n    // ä»»åŠ¡é˜Ÿåˆ—å­˜å‚¨\n    this.taskQueue = new Map()           // ç­‰å¾…é˜Ÿåˆ—\n    this.processingTasks = new Map()     // å¤„ç†ä¸­é˜Ÿåˆ—\n    this.completedTasks = new Map()      // å·²å®Œæˆé˜Ÿåˆ—\n    this.failedTasks = new Map()         // å¤±è´¥é˜Ÿåˆ—\n\n    // é…ç½®å‚æ•°\n    this.maxConcurrent = 3               // æœ€å¤§å¹¶å‘æ•°\n    this.taskTimeout = 300000            // 5åˆ†é’Ÿè¶…æ—¶\n    this.retryAttempts = 2               // é‡è¯•æ¬¡æ•°\n    this.progressTimeout = 60000         // è¿›åº¦è¶…æ—¶ï¼ˆ1åˆ†é’Ÿæ— è¿›åº¦æ›´æ–°ï¼‰\n    this.cleanupInterval = 300000        // æ¸…ç†é—´éš”ï¼ˆ5åˆ†é’Ÿï¼‰\n\n    // è¿è¡ŒçŠ¶æ€\n    this.isProcessing = false\n    this.isPaused = false\n    this.processingInterval = null\n    this.monitoringInterval = null\n    this.cleanupInterval = null\n\n    // ç»Ÿè®¡ä¿¡æ¯\n    this.stats = {\n      totalProcessed: 0,\n      totalSucceeded: 0,\n      totalFailed: 0,\n      totalRetried: 0,\n      averageProcessingTime: 0\n    }\n\n    // å¯åŠ¨é˜Ÿåˆ—å¤„ç†å™¨\n    this.startQueueProcessor()\n    this.startProgressMonitor()\n    this.startCleanupScheduler()\n\n    console.log('ğŸš€ TaskQueueManager åˆå§‹åŒ–å®Œæˆ')\n  }\n\n  /**\n   * ğŸ”§ æ·»åŠ ä»»åŠ¡åˆ°é˜Ÿåˆ—\n   * @param {Object} taskConfig - ä»»åŠ¡é…ç½®\n   * @param {Object} taskConfig.workflow - ComfyUIå·¥ä½œæµ\n   * @param {Function} taskConfig.onProgress - è¿›åº¦å›è°ƒ\n   * @param {Function} taskConfig.onComplete - å®Œæˆå›è°ƒ\n   * @param {Function} taskConfig.onError - é”™è¯¯å›è°ƒ\n   * @param {string} taskConfig.workflowType - å·¥ä½œæµç±»å‹\n   * @param {number} taskConfig.priority - ä»»åŠ¡ä¼˜å…ˆçº§\n   * @returns {string} ä»»åŠ¡ID\n   */\n  enqueueTask(taskConfig) {\n    const taskId = this.generateTaskId()\n    const task = {\n      id: taskId,\n      ...taskConfig,\n      status: QUEUE_TASK_STATUS.QUEUED,\n      priority: taskConfig.priority || TASK_PRIORITY.NORMAL,\n      queuedAt: Date.now(),\n      attempts: 0,\n      maxAttempts: this.retryAttempts,\n      lastProgressUpdate: Date.now(),\n      progressHistory: [],\n      errors: []\n    }\n\n    this.taskQueue.set(taskId, task)\n    console.log(`ğŸ“¥ ä»»åŠ¡å…¥é˜Ÿ: ${taskId} (é˜Ÿåˆ—é•¿åº¦: ${this.taskQueue.size})`)\n\n    // è§¦å‘é˜Ÿåˆ—å¤„ç†\n    this.processQueue()\n\n    return taskId\n  }\n\n  /**\n   * ğŸ”§ å¯åŠ¨é˜Ÿåˆ—å¤„ç†å™¨\n   */\n  startQueueProcessor() {\n    if (this.processingInterval) return\n\n    this.processingInterval = setInterval(() => {\n      if (!this.isPaused) {\n        this.processQueue()\n      }\n    }, 1000) // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡\n\n    this.isProcessing = true\n    console.log('ğŸš€ ä»»åŠ¡é˜Ÿåˆ—å¤„ç†å™¨å·²å¯åŠ¨')\n  }\n\n  /**\n   * ğŸ”§ å¤„ç†é˜Ÿåˆ—\n   */\n  async processQueue() {\n    // æ£€æŸ¥æ˜¯å¦å¯ä»¥å¤„ç†æ–°ä»»åŠ¡\n    if (this.processingTasks.size >= this.maxConcurrent || this.isPaused) {\n      return\n    }\n\n    // è·å–ä¸‹ä¸€ä¸ªå¾…å¤„ç†ä»»åŠ¡ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰\n    const nextTask = this.getNextTask()\n    if (!nextTask) return\n\n    // ç§»åŠ¨åˆ°å¤„ç†é˜Ÿåˆ—\n    this.taskQueue.delete(nextTask.id)\n    this.processingTasks.set(nextTask.id, {\n      ...nextTask,\n      status: QUEUE_TASK_STATUS.PROCESSING,\n      startedAt: Date.now(),\n      lastProgressUpdate: Date.now()\n    })\n\n    console.log(`ğŸ”„ å¼€å§‹å¤„ç†ä»»åŠ¡: ${nextTask.id} (ä¼˜å…ˆçº§: ${nextTask.priority})`)\n\n    // å¼‚æ­¥å¤„ç†ä»»åŠ¡\n    this.executeTask(nextTask.id)\n  }\n\n  /**\n   * ğŸ”§ æ‰§è¡Œå•ä¸ªä»»åŠ¡\n   * @param {string} taskId - ä»»åŠ¡ID\n   */\n  async executeTask(taskId) {\n    const task = this.processingTasks.get(taskId)\n    if (!task) return\n\n    try {\n      // è®¾ç½®è¶…æ—¶æ£€æŸ¥\n      const timeoutId = setTimeout(() => {\n        this.handleTaskTimeout(taskId)\n      }, this.taskTimeout)\n\n      // æ‰§è¡ŒComfyUIä»»åŠ¡\n      const result = await this.runComfyUITask(task)\n\n      clearTimeout(timeoutId)\n\n      // ä»»åŠ¡æˆåŠŸå®Œæˆ\n      this.handleTaskSuccess(taskId, result)\n\n    } catch (error) {\n      console.error(`âŒ ä»»åŠ¡æ‰§è¡Œå¤±è´¥: ${taskId}`, error)\n      this.handleTaskFailure(taskId, error)\n    }\n  }\n\n  /**\n   * ğŸ”§ æ‰§è¡ŒComfyUIä»»åŠ¡\n   * @param {Object} task - ä»»åŠ¡å¯¹è±¡\n   * @returns {Promise} ä»»åŠ¡ç»“æœ\n   */\n  async runComfyUITask(task) {\n    return new Promise((resolve, reject) => {\n      const { workflow, onProgress, onComplete, onError } = task\n\n      // åŒ…è£…è¿›åº¦å›è°ƒ\n      const progressWrapper = (message, percent) => {\n        // æ›´æ–°ä»»åŠ¡è¿›åº¦çŠ¶æ€\n        const processingTask = this.processingTasks.get(task.id)\n        if (processingTask) {\n          processingTask.lastProgressUpdate = Date.now()\n          processingTask.progressHistory.push({\n            message,\n            percent,\n            timestamp: Date.now()\n          })\n\n          // é™åˆ¶è¿›åº¦å†å²è®°å½•æ•°é‡\n          if (processingTask.progressHistory.length > 50) {\n            processingTask.progressHistory = processingTask.progressHistory.slice(-25)\n          }\n        }\n\n        // è°ƒç”¨åŸå§‹è¿›åº¦å›è°ƒ\n        if (onProgress) {\n          try {\n            onProgress(message, percent)\n          } catch (error) {\n            console.warn(`âš ï¸ è¿›åº¦å›è°ƒæ‰§è¡Œå¤±è´¥: ${task.id}`, error)\n          }\n        }\n      }\n\n      // åŒ…è£…å®Œæˆå›è°ƒ\n      const completeWrapper = (results) => {\n        resolve(results)\n      }\n\n      // åŒ…è£…é”™è¯¯å›è°ƒ\n      const errorWrapper = (error) => {\n        reject(error)\n      }\n\n      // ç”ŸæˆpromptIdå¹¶æäº¤å·¥ä½œæµ\n      const promptId = generatePromptId()\n      console.log(`ğŸ†” [QUEUE] ç”ŸæˆpromptId: ${promptId} for task: ${task.id}`)\n\n      // åˆ›å»ºä¸´æ—¶ä»»åŠ¡å¯¹è±¡\n      const tempTask = {\n        workflowType: task.workflowType || 'default',\n        createdAt: new Date().toISOString(),\n        onProgress: progressWrapper,\n        onComplete: null,\n        onError: null\n      }\n\n      // æäº¤å·¥ä½œæµå¹¶ç­‰å¾…å®Œæˆ\n      submitWorkflow(workflow, promptId, tempTask)\n        .then(submittedPromptId => {\n          console.log(`âœ… [QUEUE] å·¥ä½œæµæäº¤æˆåŠŸ: ${submittedPromptId} for task: ${task.id}`)\n\n          // ç­‰å¾…ä»»åŠ¡å®Œæˆ\n          return waitForTaskCompletion(submittedPromptId, progressWrapper, task.workflowType)\n        })\n        .then(result => {\n          completeWrapper(result)\n        })\n        .catch(error => {\n          errorWrapper(error)\n        })\n    })\n  }\n\n  /**\n   * ğŸ”§ å¤„ç†ä»»åŠ¡æˆåŠŸ\n   * @param {string} taskId - ä»»åŠ¡ID\n   * @param {Object} result - ä»»åŠ¡ç»“æœ\n   */\n  handleTaskSuccess(taskId, result) {\n    const task = this.processingTasks.get(taskId)\n    if (!task) return\n\n    const processingTime = Date.now() - task.startedAt\n    console.log(`âœ… ä»»åŠ¡å®Œæˆ: ${taskId} (è€—æ—¶: ${Math.round(processingTime / 1000)}ç§’)`)\n\n    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯\n    this.updateStats('success', processingTime)\n\n    // ç§»åŠ¨åˆ°å®Œæˆé˜Ÿåˆ—\n    this.processingTasks.delete(taskId)\n    this.completedTasks.set(taskId, {\n      ...task,\n      status: QUEUE_TASK_STATUS.COMPLETED,\n      completedAt: Date.now(),\n      processingTime,\n      result\n    })\n\n    // è°ƒç”¨åŸå§‹å®Œæˆå›è°ƒ\n    if (task.onComplete) {\n      try {\n        task.onComplete(result)\n      } catch (error) {\n        console.warn(`âš ï¸ å®Œæˆå›è°ƒæ‰§è¡Œå¤±è´¥: ${taskId}`, error)\n      }\n    }\n\n    // æ¸…ç†æ—§çš„å®Œæˆä»»åŠ¡\n    this.cleanupCompletedTasks()\n\n    // ç»§ç»­å¤„ç†é˜Ÿåˆ—\n    this.processQueue()\n  }\n\n  /**\n   * ğŸ”§ å¤„ç†ä»»åŠ¡å¤±è´¥\n   * @param {string} taskId - ä»»åŠ¡ID\n   * @param {Error} error - é”™è¯¯å¯¹è±¡\n   */\n  handleTaskFailure(taskId, error) {\n    const task = this.processingTasks.get(taskId)\n    if (!task) return\n\n    task.attempts++\n    task.errors.push({\n      error: error.message,\n      timestamp: Date.now(),\n      attempt: task.attempts\n    })\n\n    // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡è¯•\n    if (task.attempts < task.maxAttempts) {\n      console.log(`ğŸ”„ ä»»åŠ¡é‡è¯• (${task.attempts}/${task.maxAttempts}): ${taskId}`)\n\n      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯\n      this.updateStats('retry')\n\n      // é‡æ–°å…¥é˜Ÿï¼ˆé™ä½ä¼˜å…ˆçº§ï¼‰\n      this.processingTasks.delete(taskId)\n      this.taskQueue.set(taskId, {\n        ...task,\n        status: QUEUE_TASK_STATUS.QUEUED,\n        priority: Math.max(1, task.priority - 1), // é™ä½ä¼˜å…ˆçº§\n        lastError: error\n      })\n\n      // å»¶è¿Ÿé‡è¯•\n      setTimeout(() => {\n        this.processQueue()\n      }, 5000 * task.attempts) // é€’å¢å»¶è¿Ÿ\n\n    } else {\n      console.error(`âŒ ä»»åŠ¡æœ€ç»ˆå¤±è´¥: ${taskId}`)\n\n      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯\n      this.updateStats('failure')\n\n      // ç§»åŠ¨åˆ°å¤±è´¥é˜Ÿåˆ—\n      this.processingTasks.delete(taskId)\n      this.failedTasks.set(taskId, {\n        ...task,\n        status: QUEUE_TASK_STATUS.FAILED,\n        failedAt: Date.now(),\n        finalError: error\n      })\n\n      // è°ƒç”¨é”™è¯¯å›è°ƒ\n      if (task.onError) {\n        try {\n          task.onError(error)\n        } catch (callbackError) {\n          console.warn(`âš ï¸ é”™è¯¯å›è°ƒæ‰§è¡Œå¤±è´¥: ${taskId}`, callbackError)\n        }\n      }\n    }\n  }\n\n  /**\n   * ğŸ”§ å¤„ç†ä»»åŠ¡è¶…æ—¶\n   * @param {string} taskId - ä»»åŠ¡ID\n   */\n  handleTaskTimeout(taskId) {\n    console.warn(`â° ä»»åŠ¡è¶…æ—¶: ${taskId}`)\n    this.handleTaskFailure(taskId, new Error('ä»»åŠ¡æ‰§è¡Œè¶…æ—¶'))\n  }\n\n  /**\n   * ğŸ”§ å¯åŠ¨è¿›åº¦ç›‘æ§å™¨\n   */\n  startProgressMonitor() {\n    if (this.monitoringInterval) return\n\n    this.monitoringInterval = setInterval(() => {\n      this.checkStuckTasks()\n    }, 30000) // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡\n\n    console.log('ğŸ“Š è¿›åº¦ç›‘æ§å™¨å·²å¯åŠ¨')\n  }\n\n  /**\n   * ğŸ”§ æ£€æŸ¥å¡ä½çš„ä»»åŠ¡\n   */\n  checkStuckTasks() {\n    const now = Date.now()\n\n    this.processingTasks.forEach((task, taskId) => {\n      const timeSinceLastProgress = now - task.lastProgressUpdate\n\n      // æ£€æŸ¥è¿›åº¦è¶…æ—¶\n      if (timeSinceLastProgress > this.progressTimeout) {\n        console.warn(`ğŸš¨ æ£€æµ‹åˆ°å¡ä½çš„ä»»åŠ¡: ${taskId} (${Math.round(timeSinceLastProgress / 1000)}ç§’æ— è¿›åº¦æ›´æ–°)`)\n\n        // å°è¯•æ¢å¤ä»»åŠ¡\n        this.attemptTaskRecovery(taskId)\n      }\n    })\n  }\n\n  /**\n   * ğŸ”§ å°è¯•ä»»åŠ¡æ¢å¤\n   * @param {string} taskId - ä»»åŠ¡ID\n   */\n  async attemptTaskRecovery(taskId) {\n    const task = this.processingTasks.get(taskId)\n    if (!task) return\n\n    console.log(`ğŸ”§ å°è¯•æ¢å¤å¡ä½çš„ä»»åŠ¡: ${taskId}`)\n\n    try {\n      // æ–¹æ³•1: æ£€æŸ¥æœåŠ¡å™¨ç«¯ä»»åŠ¡çŠ¶æ€\n      const { getTaskHistory, handleTaskCompletion } = await import('./comfyui.js')\n\n      // å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªæ–¹æ³•æ¥è·å–ä¸ä»»åŠ¡å…³è”çš„promptId\n      const promptId = task.promptId || taskId\n\n      const history = await getTaskHistory(promptId)\n      if (history[promptId] && history[promptId].outputs) {\n        console.log(`âœ… å‘ç°ä»»åŠ¡å®é™…å·²å®Œæˆï¼Œè§¦å‘å®Œæˆå¤„ç†: ${taskId}`)\n\n        // æ‰‹åŠ¨è§¦å‘å®Œæˆ\n        await handleTaskCompletion(promptId)\n\n        // å¦‚æœæˆåŠŸï¼Œæ›´æ–°ä»»åŠ¡çŠ¶æ€\n        this.handleTaskSuccess(taskId, history[promptId])\n        return\n      }\n    } catch (error) {\n      console.warn(`âš ï¸ ä»»åŠ¡æ¢å¤å¤±è´¥: ${taskId}`, error)\n    }\n\n    // æ–¹æ³•2: å¦‚æœæ¢å¤å¤±è´¥ï¼Œæ ‡è®°ä¸ºè¶…æ—¶å¹¶é‡è¯•\n    this.handleTaskFailure(taskId, new Error('ä»»åŠ¡è¿›åº¦è¶…æ—¶ï¼Œè‡ªåŠ¨é‡è¯•'))\n  }\n\n  /**\n   * ğŸ”§ è·å–ä¸‹ä¸€ä¸ªä»»åŠ¡ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰\n   * @returns {Object|null} ä¸‹ä¸€ä¸ªä»»åŠ¡\n   */\n  getNextTask() {\n    const queuedTasks = Array.from(this.taskQueue.values())\n      .filter(task => task.status === QUEUE_TASK_STATUS.QUEUED)\n      .sort((a, b) => {\n        // é¦–å…ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼ˆé«˜ä¼˜å…ˆçº§ä¼˜å…ˆï¼‰\n        if (a.priority !== b.priority) {\n          return b.priority - a.priority\n        }\n        // ç„¶åæŒ‰å…¥é˜Ÿæ—¶é—´æ’åºï¼ˆå…ˆå…¥å…ˆå‡ºï¼‰\n        return a.queuedAt - b.queuedAt\n      })\n\n    return queuedTasks[0] || null\n  }\n\n  /**\n   * ğŸ”§ ç”Ÿæˆä»»åŠ¡ID\n   * @returns {string} ä»»åŠ¡ID\n   */\n  generateTaskId() {\n    return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n  }\n\n  /**\n   * ğŸ”§ å¯åŠ¨æ¸…ç†è°ƒåº¦å™¨\n   */\n  startCleanupScheduler() {\n    if (this.cleanupTimer) return\n\n    this.cleanupTimer = setInterval(() => {\n      this.cleanupCompletedTasks()\n      this.cleanupFailedTasks()\n    }, this.cleanupInterval)\n\n    console.log('ğŸ§¹ æ¸…ç†è°ƒåº¦å™¨å·²å¯åŠ¨')\n  }\n\n  /**\n   * ğŸ”§ æ¸…ç†å·²å®Œæˆä»»åŠ¡\n   */\n  cleanupCompletedTasks() {\n    const maxCompleted = 50\n    if (this.completedTasks.size > maxCompleted) {\n      const completed = Array.from(this.completedTasks.entries())\n        .sort((a, b) => a[1].completedAt - b[1].completedAt)\n\n      // åˆ é™¤æœ€æ—§çš„ä»»åŠ¡\n      const toDelete = completed.slice(0, completed.length - maxCompleted)\n      toDelete.forEach(([taskId]) => {\n        this.completedTasks.delete(taskId)\n      })\n\n      console.log(`ğŸ§¹ æ¸…ç†äº† ${toDelete.length} ä¸ªå·²å®Œæˆä»»åŠ¡`)\n    }\n  }\n\n  /**\n   * ğŸ”§ æ¸…ç†å¤±è´¥ä»»åŠ¡\n   */\n  cleanupFailedTasks() {\n    const maxFailed = 20\n    if (this.failedTasks.size > maxFailed) {\n      const failed = Array.from(this.failedTasks.entries())\n        .sort((a, b) => a[1].failedAt - b[1].failedAt)\n\n      // åˆ é™¤æœ€æ—§çš„ä»»åŠ¡\n      const toDelete = failed.slice(0, failed.length - maxFailed)\n      toDelete.forEach(([taskId]) => {\n        this.failedTasks.delete(taskId)\n      })\n\n      console.log(`ğŸ§¹ æ¸…ç†äº† ${toDelete.length} ä¸ªå¤±è´¥ä»»åŠ¡`)\n    }\n  }\n\n  /**\n   * ğŸ”§ æ›´æ–°ç»Ÿè®¡ä¿¡æ¯\n   * @param {string} type - ç»Ÿè®¡ç±»å‹\n   * @param {number} processingTime - å¤„ç†æ—¶é—´ï¼ˆå¯é€‰ï¼‰\n   */\n  updateStats(type, processingTime = 0) {\n    this.stats.totalProcessed++\n\n    switch (type) {\n      case 'success':\n        this.stats.totalSucceeded++\n        if (processingTime > 0) {\n          // è®¡ç®—å¹³å‡å¤„ç†æ—¶é—´\n          const totalTime = this.stats.averageProcessingTime * (this.stats.totalSucceeded - 1) + processingTime\n          this.stats.averageProcessingTime = totalTime / this.stats.totalSucceeded\n        }\n        break\n      case 'failure':\n        this.stats.totalFailed++\n        break\n      case 'retry':\n        this.stats.totalRetried++\n        break\n    }\n  }\n\n  /**\n   * ğŸ”§ è·å–é˜Ÿåˆ—çŠ¶æ€\n   * @returns {Object} é˜Ÿåˆ—çŠ¶æ€\n   */\n  getQueueStatus() {\n    return {\n      queued: this.taskQueue.size,\n      processing: this.processingTasks.size,\n      completed: this.completedTasks.size,\n      failed: this.failedTasks.size,\n      maxConcurrent: this.maxConcurrent,\n      isPaused: this.isPaused,\n      stats: { ...this.stats }\n    }\n  }\n\n  /**\n   * ğŸ”§ è·å–ä»»åŠ¡çŠ¶æ€\n   * @param {string} taskId - ä»»åŠ¡ID\n   * @returns {Object|null} ä»»åŠ¡çŠ¶æ€\n   */\n  getTaskStatus(taskId) {\n    // æ£€æŸ¥å„ä¸ªé˜Ÿåˆ—\n    if (this.taskQueue.has(taskId)) {\n      return { ...this.taskQueue.get(taskId), queue: 'waiting' }\n    }\n    if (this.processingTasks.has(taskId)) {\n      return { ...this.processingTasks.get(taskId), queue: 'processing' }\n    }\n    if (this.completedTasks.has(taskId)) {\n      return { ...this.completedTasks.get(taskId), queue: 'completed' }\n    }\n    if (this.failedTasks.has(taskId)) {\n      return { ...this.failedTasks.get(taskId), queue: 'failed' }\n    }\n\n    return null\n  }\n\n  /**\n   * ğŸ”§ å–æ¶ˆä»»åŠ¡\n   * @param {string} taskId - ä»»åŠ¡ID\n   * @returns {boolean} æ˜¯å¦æˆåŠŸå–æ¶ˆ\n   */\n  cancelTask(taskId) {\n    // åªèƒ½å–æ¶ˆæ’é˜Ÿä¸­çš„ä»»åŠ¡\n    if (this.taskQueue.has(taskId)) {\n      const task = this.taskQueue.get(taskId)\n      this.taskQueue.delete(taskId)\n\n      // ç§»åŠ¨åˆ°å¤±è´¥é˜Ÿåˆ—ï¼ˆæ ‡è®°ä¸ºå–æ¶ˆï¼‰\n      this.failedTasks.set(taskId, {\n        ...task,\n        status: QUEUE_TASK_STATUS.CANCELLED,\n        cancelledAt: Date.now()\n      })\n\n      console.log(`ğŸš« ä»»åŠ¡å·²å–æ¶ˆ: ${taskId}`)\n      return true\n    }\n\n    console.warn(`âš ï¸ æ— æ³•å–æ¶ˆä»»åŠ¡: ${taskId} (ä»»åŠ¡å¯èƒ½å·²åœ¨å¤„ç†ä¸­)`)\n    return false\n  }\n\n  /**\n   * ğŸ”§ æš‚åœé˜Ÿåˆ—\n   */\n  pause() {\n    this.isPaused = true\n    console.log('â¸ï¸ é˜Ÿåˆ—å·²æš‚åœ')\n  }\n\n  /**\n   * ğŸ”§ æ¢å¤é˜Ÿåˆ—\n   */\n  resume() {\n    this.isPaused = false\n    console.log('â–¶ï¸ é˜Ÿåˆ—å·²æ¢å¤')\n    this.processQueue()\n  }\n\n  /**\n   * ğŸ”§ æ¸…ç©ºé˜Ÿåˆ—\n   */\n  clearQueue() {\n    const queuedCount = this.taskQueue.size\n\n    // å°†æ‰€æœ‰æ’é˜Ÿä»»åŠ¡ç§»åŠ¨åˆ°å¤±è´¥é˜Ÿåˆ—\n    this.taskQueue.forEach((task, taskId) => {\n      this.failedTasks.set(taskId, {\n        ...task,\n        status: QUEUE_TASK_STATUS.CANCELLED,\n        cancelledAt: Date.now()\n      })\n    })\n\n    this.taskQueue.clear()\n    console.log(`ğŸ§¹ å·²æ¸…ç©ºé˜Ÿåˆ—ï¼Œå–æ¶ˆäº† ${queuedCount} ä¸ªä»»åŠ¡`)\n  }\n\n  /**\n   * ğŸ”§ åœæ­¢é˜Ÿåˆ—ç®¡ç†å™¨\n   */\n  stop() {\n    // åœæ­¢æ‰€æœ‰å®šæ—¶å™¨\n    if (this.processingInterval) {\n      clearInterval(this.processingInterval)\n      this.processingInterval = null\n    }\n\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval)\n      this.monitoringInterval = null\n    }\n\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer)\n      this.cleanupTimer = null\n    }\n\n    this.isProcessing = false\n    console.log('â¹ï¸ ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†å™¨å·²åœæ­¢')\n  }\n\n  /**\n   * ğŸ”§ è·å–è¯¦ç»†çŠ¶æ€æŠ¥å‘Š\n   * @returns {Object} è¯¦ç»†çŠ¶æ€\n   */\n  getDetailedStatus() {\n    const now = Date.now()\n\n    return {\n      overview: this.getQueueStatus(),\n      queuedTasks: Array.from(this.taskQueue.values()).map(task => ({\n        id: task.id,\n        workflowType: task.workflowType,\n        priority: task.priority,\n        queuedAt: task.queuedAt,\n        waitingTime: now - task.queuedAt\n      })),\n      processingTasks: Array.from(this.processingTasks.values()).map(task => ({\n        id: task.id,\n        workflowType: task.workflowType,\n        startedAt: task.startedAt,\n        processingTime: now - task.startedAt,\n        lastProgressUpdate: task.lastProgressUpdate,\n        timeSinceLastProgress: now - task.lastProgressUpdate,\n        progressHistory: task.progressHistory.slice(-5) // æœ€è¿‘5ä¸ªè¿›åº¦è®°å½•\n      })),\n      recentCompleted: Array.from(this.completedTasks.values())\n        .sort((a, b) => b.completedAt - a.completedAt)\n        .slice(0, 10)\n        .map(task => ({\n          id: task.id,\n          workflowType: task.workflowType,\n          processingTime: task.processingTime,\n          completedAt: task.completedAt\n        })),\n      recentFailed: Array.from(this.failedTasks.values())\n        .sort((a, b) => b.failedAt - a.failedAt)\n        .slice(0, 10)\n        .map(task => ({\n          id: task.id,\n          workflowType: task.workflowType,\n          attempts: task.attempts,\n          errors: task.errors,\n          failedAt: task.failedAt\n        }))\n    }\n  }\n}\n\nexport default TaskQueueManager\n"
        }
    ]
}