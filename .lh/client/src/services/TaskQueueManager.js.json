{
    "sourceFile": "client/src/services/TaskQueueManager.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1753203379058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753328893606,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -180,32 +180,46 @@\n     }\n   }\n \n   /**\n-   * 🔧 执行ComfyUI任务\n+   * 🔧 执行ComfyUI任务 - 跨服务器隔离版本\n    * @param {Object} task - 任务对象\n    * @returns {Promise} 任务结果\n    */\n   async runComfyUITask(task) {\n     return new Promise((resolve, reject) => {\n       const { workflow, onProgress, onComplete, onError } = task\n \n-      // 包装进度回调\n+      // 🔥 获取任务绑定的服务器信息\n+      let taskServer = null\n+\n+      // 包装进度回调 - 增加服务器隔离检查\n       const progressWrapper = (message, percent) => {\n         // 更新任务进度状态\n         const processingTask = this.processingTasks.get(task.id)\n         if (processingTask) {\n           processingTask.lastProgressUpdate = Date.now()\n           processingTask.progressHistory.push({\n             message,\n             percent,\n-            timestamp: Date.now()\n+            timestamp: Date.now(),\n+            server: taskServer // 记录服务器信息\n           })\n \n           // 限制进度历史记录数量\n           if (processingTask.progressHistory.length > 50) {\n             processingTask.progressHistory = processingTask.progressHistory.slice(-25)\n           }\n+\n+          // 🔥 检查52.25%卡住问题 - 跨服务器版本\n+          if (percent === 52.25) {\n+            console.warn(`🚨 [QUEUE] 检测到52.25%卡住问题: ${task.id} (服务器: ${taskServer})`)\n+\n+            // 延迟检查任务是否真的卡住\n+            setTimeout(() => {\n+              this.checkTaskStuckAt5225(task.id, taskServer)\n+            }, 30000) // 30秒后检查\n+          }\n         }\n \n         // 调用原始进度回调\n         if (onProgress) {\n@@ -216,26 +230,43 @@\n           }\n         }\n       }\n \n-      // 包装完成回调\n+      // 包装完成回调 - 增加服务器验证\n       const completeWrapper = (results) => {\n+        // 🔥 验证结果来源服务器\n+        if (taskServer && results.executionServer && results.executionServer !== taskServer) {\n+          console.warn(`⚠️ [QUEUE] 任务 ${task.id} 服务器不一致: 预期 ${taskServer}, 实际 ${results.executionServer}`)\n+        }\n+\n+        // 确保结果包含正确的服务器信息\n+        results.queueTaskId = task.id\n+        results.queueServer = taskServer\n+\n         resolve(results)\n       }\n \n       // 包装错误回调\n       const errorWrapper = (error) => {\n+        console.error(`❌ [QUEUE] 任务 ${task.id} 失败 (服务器: ${taskServer}):`, error)\n         reject(error)\n       }\n \n       // 生成promptId并提交工作流\n       const promptId = generatePromptId()\n       console.log(`🆔 [QUEUE] 生成promptId: ${promptId} for task: ${task.id}`)\n \n+      // 🔥 保存promptId到任务对象，用于跨服务器恢复\n+      const processingTask = this.processingTasks.get(task.id)\n+      if (processingTask) {\n+        processingTask.promptId = promptId\n+      }\n+\n       // 创建临时任务对象\n       const tempTask = {\n         workflowType: task.workflowType || 'default',\n         createdAt: new Date().toISOString(),\n+        queueTaskId: task.id, // 🔥 关联队列任务ID\n         onProgress: progressWrapper,\n         onComplete: null,\n         onError: null\n       }\n@@ -244,8 +275,21 @@\n       submitWorkflow(workflow, promptId, tempTask)\n         .then(submittedPromptId => {\n           console.log(`✅ [QUEUE] 工作流提交成功: ${submittedPromptId} for task: ${task.id}`)\n \n+          // 🔥 获取任务绑定的服务器\n+          const { getWindowTask } = require('./comfyui.js')\n+          const comfyTask = getWindowTask(submittedPromptId)\n+          if (comfyTask && comfyTask.executionServer) {\n+            taskServer = comfyTask.executionServer\n+            console.log(`🔒 [QUEUE] 任务 ${task.id} 绑定服务器: ${taskServer}`)\n+\n+            // 更新处理中任务的服务器信息\n+            if (processingTask) {\n+              processingTask.executionServer = taskServer\n+            }\n+          }\n+\n           // 等待任务完成\n           return waitForTaskCompletion(submittedPromptId, progressWrapper, task.workflowType)\n         })\n         .then(result => {\n"
                },
                {
                    "date": 1753328937168,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -446,27 +446,45 @@\n     })\n   }\n \n   /**\n-   * 🔧 尝试任务恢复\n+   * 🔧 尝试任务恢复 - 跨服务器版本\n    * @param {string} taskId - 任务ID\n    */\n   async attemptTaskRecovery(taskId) {\n     const task = this.processingTasks.get(taskId)\n     if (!task) return\n \n-    console.log(`🔧 尝试恢复卡住的任务: ${taskId}`)\n+    console.log(`🔧 尝试恢复卡住的任务: ${taskId} (服务器: ${task.executionServer})`)\n \n     try {\n-      // 方法1: 检查服务器端任务状态\n-      const { getTaskHistory, handleTaskCompletion } = await import('./comfyui.js')\n+      // 🔥 方法1: 检查特定服务器上的任务状态\n+      const { getTaskHistory, handleTaskCompletion, getApiBaseUrl } = await import('./comfyui.js')\n \n-      // 假设我们有一个方法来获取与任务关联的promptId\n+      // 获取与任务关联的promptId\n       const promptId = task.promptId || taskId\n \n-      const history = await getTaskHistory(promptId)\n+      // 🔥 确保使用任务绑定的服务器获取历史记录\n+      let history\n+      if (task.executionServer) {\n+        // 直接从任务绑定的服务器获取历史记录\n+        const url = `${task.executionServer}/history/${promptId}`\n+        console.log(`🔍 [QUEUE] 从绑定服务器获取历史记录: ${url}`)\n+\n+        const response = await fetch(url)\n+        if (response.ok) {\n+          const fullHistory = await response.json()\n+          history = { [promptId]: fullHistory[promptId] }\n+        } else {\n+          throw new Error(`服务器 ${task.executionServer} 历史记录获取失败: ${response.status}`)\n+        }\n+      } else {\n+        // 回退到默认方法\n+        history = await getTaskHistory(promptId)\n+      }\n+\n       if (history[promptId] && history[promptId].outputs) {\n-        console.log(`✅ 发现任务实际已完成，触发完成处理: ${taskId}`)\n+        console.log(`✅ 发现任务实际已完成，触发完成处理: ${taskId} (服务器: ${task.executionServer})`)\n \n         // 手动触发完成\n         await handleTaskCompletion(promptId)\n \n@@ -474,16 +492,105 @@\n         this.handleTaskSuccess(taskId, history[promptId])\n         return\n       }\n     } catch (error) {\n-      console.warn(`⚠️ 任务恢复失败: ${taskId}`, error)\n+      console.warn(`⚠️ 任务恢复失败: ${taskId} (服务器: ${task.executionServer})`, error)\n     }\n \n     // 方法2: 如果恢复失败，标记为超时并重试\n-    this.handleTaskFailure(taskId, new Error('任务进度超时，自动重试'))\n+    this.handleTaskFailure(taskId, new Error(`任务进度超时，自动重试 (服务器: ${task.executionServer})`))\n   }\n \n   /**\n+   * 🔥 检查52.25%卡住问题 - 跨服务器版本\n+   * @param {string} taskId - 任务ID\n+   * @param {string} server - 服务器地址\n+   */\n+  async checkTaskStuckAt5225(taskId, server) {\n+    const task = this.processingTasks.get(taskId)\n+    if (!task) return\n+\n+    // 检查任务是否仍然卡在52.25%\n+    const latestProgress = task.progressHistory[task.progressHistory.length - 1]\n+    if (latestProgress && latestProgress.percent === 52.25) {\n+      const stuckTime = Date.now() - latestProgress.timestamp\n+\n+      if (stuckTime > 30000) { // 卡住超过30秒\n+        console.error(`🚨 [QUEUE] 任务 ${taskId} 确认卡在52.25% (服务器: ${server}, 卡住时间: ${Math.round(stuckTime/1000)}秒)`)\n+\n+        // 尝试跨服务器恢复\n+        await this.attemptCrossServerRecovery(taskId, server)\n+      }\n+    }\n+  }\n+\n+  /**\n+   * 🔥 跨服务器恢复机制\n+   * @param {string} taskId - 任务ID\n+   * @param {string} server - 服务器地址\n+   */\n+  async attemptCrossServerRecovery(taskId, server) {\n+    const task = this.processingTasks.get(taskId)\n+    if (!task || !task.promptId) return\n+\n+    console.log(`🔧 [QUEUE] 开始跨服务器恢复: ${taskId} (服务器: ${server})`)\n+\n+    try {\n+      // 1. 直接检查绑定服务器的任务状态\n+      const url = `${server}/history/${task.promptId}`\n+      console.log(`🔍 [QUEUE] 检查服务器任务状态: ${url}`)\n+\n+      const response = await fetch(url)\n+      if (response.ok) {\n+        const history = await response.json()\n+\n+        if (history[task.promptId] && history[task.promptId].outputs) {\n+          console.log(`✅ [QUEUE] 发现任务在服务器 ${server} 上已完成: ${taskId}`)\n+\n+          // 构造结果对象\n+          const results = {\n+            promptId: task.promptId,\n+            history: history[task.promptId],\n+            executionServer: server,\n+            queueTaskId: taskId,\n+            recoveredFromStuck: true\n+          }\n+\n+          // 提取图片URL等结果\n+          if (history[task.promptId].outputs) {\n+            const outputs = history[task.promptId].outputs\n+            const imageUrls = []\n+\n+            Object.values(outputs).forEach(output => {\n+              if (output.images) {\n+                output.images.forEach(img => {\n+                  const imageUrl = `${server}/view?filename=${img.filename}&subfolder=${img.subfolder}&type=${img.type}`\n+                  imageUrls.push(imageUrl)\n+                })\n+              }\n+            })\n+\n+            results.imageUrls = imageUrls\n+            results.images = imageUrls // 兼容性\n+          }\n+\n+          // 标记任务完成\n+          this.handleTaskSuccess(taskId, results)\n+          return\n+        }\n+      }\n+\n+      // 2. 如果任务确实未完成，尝试重新提交\n+      console.warn(`⚠️ [QUEUE] 任务 ${taskId} 在服务器 ${server} 上确实未完成，标记为失败`)\n+      this.handleTaskFailure(taskId, new Error(`任务在服务器 ${server} 上卡住在52.25%`))\n+\n+    } catch (error) {\n+      console.error(`❌ [QUEUE] 跨服务器恢复失败: ${taskId}`, error)\n+      this.handleTaskFailure(taskId, error)\n+    }\n+  }\n+\n+  /**\n    * 🔧 获取下一个任务（按优先级排序）\n    * @returns {Object|null} 下一个任务\n    */\n   getNextTask() {\n"
                }
            ],
            "date": 1753203379058,
            "name": "Commit-0",
            "content": "/**\n * 🔥 任务队列管理器 - 彻底解决ComfyUI客户端卡住问题\n *\n * 核心功能：\n * 1. 任务隔离：每个任务独立处理，避免相互影响\n * 2. 进度监控：实时跟踪任务进度，检测长时间无更新的任务\n * 3. 自动恢复：检测到卡住任务时自动重试或强制完成\n * 4. WebSocket消息完整处理：确保handling executing、executed、progress等所有关键消息\n */\n\nimport {\n  submitWorkflow,\n  waitForTaskCompletion,\n  generatePromptId,\n  TASK_STATUS,\n  WINDOW_ID\n} from './comfyui.js'\n\n// 任务状态枚举\nexport const QUEUE_TASK_STATUS = {\n  QUEUED: 'queued',           // 排队中\n  PROCESSING: 'processing',   // 处理中\n  COMPLETED: 'completed',     // 已完成\n  FAILED: 'failed',          // 失败\n  CANCELLED: 'cancelled',     // 已取消\n  TIMEOUT: 'timeout'         // 超时\n}\n\n// 任务优先级枚举\nexport const TASK_PRIORITY = {\n  LOW: 1,\n  NORMAL: 2,\n  HIGH: 3,\n  URGENT: 4\n}\n\nclass TaskQueueManager {\n  constructor() {\n    // 任务队列存储\n    this.taskQueue = new Map()           // 等待队列\n    this.processingTasks = new Map()     // 处理中队列\n    this.completedTasks = new Map()      // 已完成队列\n    this.failedTasks = new Map()         // 失败队列\n\n    // 配置参数\n    this.maxConcurrent = 3               // 最大并发数\n    this.taskTimeout = 300000            // 5分钟超时\n    this.retryAttempts = 2               // 重试次数\n    this.progressTimeout = 60000         // 进度超时（1分钟无进度更新）\n    this.cleanupInterval = 300000        // 清理间隔（5分钟）\n\n    // 运行状态\n    this.isProcessing = false\n    this.isPaused = false\n    this.processingInterval = null\n    this.monitoringInterval = null\n    this.cleanupInterval = null\n\n    // 统计信息\n    this.stats = {\n      totalProcessed: 0,\n      totalSucceeded: 0,\n      totalFailed: 0,\n      totalRetried: 0,\n      averageProcessingTime: 0\n    }\n\n    // 启动队列处理器\n    this.startQueueProcessor()\n    this.startProgressMonitor()\n    this.startCleanupScheduler()\n\n    console.log('🚀 TaskQueueManager 初始化完成')\n  }\n\n  /**\n   * 🔧 添加任务到队列\n   * @param {Object} taskConfig - 任务配置\n   * @param {Object} taskConfig.workflow - ComfyUI工作流\n   * @param {Function} taskConfig.onProgress - 进度回调\n   * @param {Function} taskConfig.onComplete - 完成回调\n   * @param {Function} taskConfig.onError - 错误回调\n   * @param {string} taskConfig.workflowType - 工作流类型\n   * @param {number} taskConfig.priority - 任务优先级\n   * @returns {string} 任务ID\n   */\n  enqueueTask(taskConfig) {\n    const taskId = this.generateTaskId()\n    const task = {\n      id: taskId,\n      ...taskConfig,\n      status: QUEUE_TASK_STATUS.QUEUED,\n      priority: taskConfig.priority || TASK_PRIORITY.NORMAL,\n      queuedAt: Date.now(),\n      attempts: 0,\n      maxAttempts: this.retryAttempts,\n      lastProgressUpdate: Date.now(),\n      progressHistory: [],\n      errors: []\n    }\n\n    this.taskQueue.set(taskId, task)\n    console.log(`📥 任务入队: ${taskId} (队列长度: ${this.taskQueue.size})`)\n\n    // 触发队列处理\n    this.processQueue()\n\n    return taskId\n  }\n\n  /**\n   * 🔧 启动队列处理器\n   */\n  startQueueProcessor() {\n    if (this.processingInterval) return\n\n    this.processingInterval = setInterval(() => {\n      if (!this.isPaused) {\n        this.processQueue()\n      }\n    }, 1000) // 每秒检查一次\n\n    this.isProcessing = true\n    console.log('🚀 任务队列处理器已启动')\n  }\n\n  /**\n   * 🔧 处理队列\n   */\n  async processQueue() {\n    // 检查是否可以处理新任务\n    if (this.processingTasks.size >= this.maxConcurrent || this.isPaused) {\n      return\n    }\n\n    // 获取下一个待处理任务（按优先级排序）\n    const nextTask = this.getNextTask()\n    if (!nextTask) return\n\n    // 移动到处理队列\n    this.taskQueue.delete(nextTask.id)\n    this.processingTasks.set(nextTask.id, {\n      ...nextTask,\n      status: QUEUE_TASK_STATUS.PROCESSING,\n      startedAt: Date.now(),\n      lastProgressUpdate: Date.now()\n    })\n\n    console.log(`🔄 开始处理任务: ${nextTask.id} (优先级: ${nextTask.priority})`)\n\n    // 异步处理任务\n    this.executeTask(nextTask.id)\n  }\n\n  /**\n   * 🔧 执行单个任务\n   * @param {string} taskId - 任务ID\n   */\n  async executeTask(taskId) {\n    const task = this.processingTasks.get(taskId)\n    if (!task) return\n\n    try {\n      // 设置超时检查\n      const timeoutId = setTimeout(() => {\n        this.handleTaskTimeout(taskId)\n      }, this.taskTimeout)\n\n      // 执行ComfyUI任务\n      const result = await this.runComfyUITask(task)\n\n      clearTimeout(timeoutId)\n\n      // 任务成功完成\n      this.handleTaskSuccess(taskId, result)\n\n    } catch (error) {\n      console.error(`❌ 任务执行失败: ${taskId}`, error)\n      this.handleTaskFailure(taskId, error)\n    }\n  }\n\n  /**\n   * 🔧 执行ComfyUI任务\n   * @param {Object} task - 任务对象\n   * @returns {Promise} 任务结果\n   */\n  async runComfyUITask(task) {\n    return new Promise((resolve, reject) => {\n      const { workflow, onProgress, onComplete, onError } = task\n\n      // 包装进度回调\n      const progressWrapper = (message, percent) => {\n        // 更新任务进度状态\n        const processingTask = this.processingTasks.get(task.id)\n        if (processingTask) {\n          processingTask.lastProgressUpdate = Date.now()\n          processingTask.progressHistory.push({\n            message,\n            percent,\n            timestamp: Date.now()\n          })\n\n          // 限制进度历史记录数量\n          if (processingTask.progressHistory.length > 50) {\n            processingTask.progressHistory = processingTask.progressHistory.slice(-25)\n          }\n        }\n\n        // 调用原始进度回调\n        if (onProgress) {\n          try {\n            onProgress(message, percent)\n          } catch (error) {\n            console.warn(`⚠️ 进度回调执行失败: ${task.id}`, error)\n          }\n        }\n      }\n\n      // 包装完成回调\n      const completeWrapper = (results) => {\n        resolve(results)\n      }\n\n      // 包装错误回调\n      const errorWrapper = (error) => {\n        reject(error)\n      }\n\n      // 生成promptId并提交工作流\n      const promptId = generatePromptId()\n      console.log(`🆔 [QUEUE] 生成promptId: ${promptId} for task: ${task.id}`)\n\n      // 创建临时任务对象\n      const tempTask = {\n        workflowType: task.workflowType || 'default',\n        createdAt: new Date().toISOString(),\n        onProgress: progressWrapper,\n        onComplete: null,\n        onError: null\n      }\n\n      // 提交工作流并等待完成\n      submitWorkflow(workflow, promptId, tempTask)\n        .then(submittedPromptId => {\n          console.log(`✅ [QUEUE] 工作流提交成功: ${submittedPromptId} for task: ${task.id}`)\n\n          // 等待任务完成\n          return waitForTaskCompletion(submittedPromptId, progressWrapper, task.workflowType)\n        })\n        .then(result => {\n          completeWrapper(result)\n        })\n        .catch(error => {\n          errorWrapper(error)\n        })\n    })\n  }\n\n  /**\n   * 🔧 处理任务成功\n   * @param {string} taskId - 任务ID\n   * @param {Object} result - 任务结果\n   */\n  handleTaskSuccess(taskId, result) {\n    const task = this.processingTasks.get(taskId)\n    if (!task) return\n\n    const processingTime = Date.now() - task.startedAt\n    console.log(`✅ 任务完成: ${taskId} (耗时: ${Math.round(processingTime / 1000)}秒)`)\n\n    // 更新统计信息\n    this.updateStats('success', processingTime)\n\n    // 移动到完成队列\n    this.processingTasks.delete(taskId)\n    this.completedTasks.set(taskId, {\n      ...task,\n      status: QUEUE_TASK_STATUS.COMPLETED,\n      completedAt: Date.now(),\n      processingTime,\n      result\n    })\n\n    // 调用原始完成回调\n    if (task.onComplete) {\n      try {\n        task.onComplete(result)\n      } catch (error) {\n        console.warn(`⚠️ 完成回调执行失败: ${taskId}`, error)\n      }\n    }\n\n    // 清理旧的完成任务\n    this.cleanupCompletedTasks()\n\n    // 继续处理队列\n    this.processQueue()\n  }\n\n  /**\n   * 🔧 处理任务失败\n   * @param {string} taskId - 任务ID\n   * @param {Error} error - 错误对象\n   */\n  handleTaskFailure(taskId, error) {\n    const task = this.processingTasks.get(taskId)\n    if (!task) return\n\n    task.attempts++\n    task.errors.push({\n      error: error.message,\n      timestamp: Date.now(),\n      attempt: task.attempts\n    })\n\n    // 检查是否需要重试\n    if (task.attempts < task.maxAttempts) {\n      console.log(`🔄 任务重试 (${task.attempts}/${task.maxAttempts}): ${taskId}`)\n\n      // 更新统计信息\n      this.updateStats('retry')\n\n      // 重新入队（降低优先级）\n      this.processingTasks.delete(taskId)\n      this.taskQueue.set(taskId, {\n        ...task,\n        status: QUEUE_TASK_STATUS.QUEUED,\n        priority: Math.max(1, task.priority - 1), // 降低优先级\n        lastError: error\n      })\n\n      // 延迟重试\n      setTimeout(() => {\n        this.processQueue()\n      }, 5000 * task.attempts) // 递增延迟\n\n    } else {\n      console.error(`❌ 任务最终失败: ${taskId}`)\n\n      // 更新统计信息\n      this.updateStats('failure')\n\n      // 移动到失败队列\n      this.processingTasks.delete(taskId)\n      this.failedTasks.set(taskId, {\n        ...task,\n        status: QUEUE_TASK_STATUS.FAILED,\n        failedAt: Date.now(),\n        finalError: error\n      })\n\n      // 调用错误回调\n      if (task.onError) {\n        try {\n          task.onError(error)\n        } catch (callbackError) {\n          console.warn(`⚠️ 错误回调执行失败: ${taskId}`, callbackError)\n        }\n      }\n    }\n  }\n\n  /**\n   * 🔧 处理任务超时\n   * @param {string} taskId - 任务ID\n   */\n  handleTaskTimeout(taskId) {\n    console.warn(`⏰ 任务超时: ${taskId}`)\n    this.handleTaskFailure(taskId, new Error('任务执行超时'))\n  }\n\n  /**\n   * 🔧 启动进度监控器\n   */\n  startProgressMonitor() {\n    if (this.monitoringInterval) return\n\n    this.monitoringInterval = setInterval(() => {\n      this.checkStuckTasks()\n    }, 30000) // 每30秒检查一次\n\n    console.log('📊 进度监控器已启动')\n  }\n\n  /**\n   * 🔧 检查卡住的任务\n   */\n  checkStuckTasks() {\n    const now = Date.now()\n\n    this.processingTasks.forEach((task, taskId) => {\n      const timeSinceLastProgress = now - task.lastProgressUpdate\n\n      // 检查进度超时\n      if (timeSinceLastProgress > this.progressTimeout) {\n        console.warn(`🚨 检测到卡住的任务: ${taskId} (${Math.round(timeSinceLastProgress / 1000)}秒无进度更新)`)\n\n        // 尝试恢复任务\n        this.attemptTaskRecovery(taskId)\n      }\n    })\n  }\n\n  /**\n   * 🔧 尝试任务恢复\n   * @param {string} taskId - 任务ID\n   */\n  async attemptTaskRecovery(taskId) {\n    const task = this.processingTasks.get(taskId)\n    if (!task) return\n\n    console.log(`🔧 尝试恢复卡住的任务: ${taskId}`)\n\n    try {\n      // 方法1: 检查服务器端任务状态\n      const { getTaskHistory, handleTaskCompletion } = await import('./comfyui.js')\n\n      // 假设我们有一个方法来获取与任务关联的promptId\n      const promptId = task.promptId || taskId\n\n      const history = await getTaskHistory(promptId)\n      if (history[promptId] && history[promptId].outputs) {\n        console.log(`✅ 发现任务实际已完成，触发完成处理: ${taskId}`)\n\n        // 手动触发完成\n        await handleTaskCompletion(promptId)\n\n        // 如果成功，更新任务状态\n        this.handleTaskSuccess(taskId, history[promptId])\n        return\n      }\n    } catch (error) {\n      console.warn(`⚠️ 任务恢复失败: ${taskId}`, error)\n    }\n\n    // 方法2: 如果恢复失败，标记为超时并重试\n    this.handleTaskFailure(taskId, new Error('任务进度超时，自动重试'))\n  }\n\n  /**\n   * 🔧 获取下一个任务（按优先级排序）\n   * @returns {Object|null} 下一个任务\n   */\n  getNextTask() {\n    const queuedTasks = Array.from(this.taskQueue.values())\n      .filter(task => task.status === QUEUE_TASK_STATUS.QUEUED)\n      .sort((a, b) => {\n        // 首先按优先级排序（高优先级优先）\n        if (a.priority !== b.priority) {\n          return b.priority - a.priority\n        }\n        // 然后按入队时间排序（先入先出）\n        return a.queuedAt - b.queuedAt\n      })\n\n    return queuedTasks[0] || null\n  }\n\n  /**\n   * 🔧 生成任务ID\n   * @returns {string} 任务ID\n   */\n  generateTaskId() {\n    return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n  }\n\n  /**\n   * 🔧 启动清理调度器\n   */\n  startCleanupScheduler() {\n    if (this.cleanupTimer) return\n\n    this.cleanupTimer = setInterval(() => {\n      this.cleanupCompletedTasks()\n      this.cleanupFailedTasks()\n    }, this.cleanupInterval)\n\n    console.log('🧹 清理调度器已启动')\n  }\n\n  /**\n   * 🔧 清理已完成任务\n   */\n  cleanupCompletedTasks() {\n    const maxCompleted = 50\n    if (this.completedTasks.size > maxCompleted) {\n      const completed = Array.from(this.completedTasks.entries())\n        .sort((a, b) => a[1].completedAt - b[1].completedAt)\n\n      // 删除最旧的任务\n      const toDelete = completed.slice(0, completed.length - maxCompleted)\n      toDelete.forEach(([taskId]) => {\n        this.completedTasks.delete(taskId)\n      })\n\n      console.log(`🧹 清理了 ${toDelete.length} 个已完成任务`)\n    }\n  }\n\n  /**\n   * 🔧 清理失败任务\n   */\n  cleanupFailedTasks() {\n    const maxFailed = 20\n    if (this.failedTasks.size > maxFailed) {\n      const failed = Array.from(this.failedTasks.entries())\n        .sort((a, b) => a[1].failedAt - b[1].failedAt)\n\n      // 删除最旧的任务\n      const toDelete = failed.slice(0, failed.length - maxFailed)\n      toDelete.forEach(([taskId]) => {\n        this.failedTasks.delete(taskId)\n      })\n\n      console.log(`🧹 清理了 ${toDelete.length} 个失败任务`)\n    }\n  }\n\n  /**\n   * 🔧 更新统计信息\n   * @param {string} type - 统计类型\n   * @param {number} processingTime - 处理时间（可选）\n   */\n  updateStats(type, processingTime = 0) {\n    this.stats.totalProcessed++\n\n    switch (type) {\n      case 'success':\n        this.stats.totalSucceeded++\n        if (processingTime > 0) {\n          // 计算平均处理时间\n          const totalTime = this.stats.averageProcessingTime * (this.stats.totalSucceeded - 1) + processingTime\n          this.stats.averageProcessingTime = totalTime / this.stats.totalSucceeded\n        }\n        break\n      case 'failure':\n        this.stats.totalFailed++\n        break\n      case 'retry':\n        this.stats.totalRetried++\n        break\n    }\n  }\n\n  /**\n   * 🔧 获取队列状态\n   * @returns {Object} 队列状态\n   */\n  getQueueStatus() {\n    return {\n      queued: this.taskQueue.size,\n      processing: this.processingTasks.size,\n      completed: this.completedTasks.size,\n      failed: this.failedTasks.size,\n      maxConcurrent: this.maxConcurrent,\n      isPaused: this.isPaused,\n      stats: { ...this.stats }\n    }\n  }\n\n  /**\n   * 🔧 获取任务状态\n   * @param {string} taskId - 任务ID\n   * @returns {Object|null} 任务状态\n   */\n  getTaskStatus(taskId) {\n    // 检查各个队列\n    if (this.taskQueue.has(taskId)) {\n      return { ...this.taskQueue.get(taskId), queue: 'waiting' }\n    }\n    if (this.processingTasks.has(taskId)) {\n      return { ...this.processingTasks.get(taskId), queue: 'processing' }\n    }\n    if (this.completedTasks.has(taskId)) {\n      return { ...this.completedTasks.get(taskId), queue: 'completed' }\n    }\n    if (this.failedTasks.has(taskId)) {\n      return { ...this.failedTasks.get(taskId), queue: 'failed' }\n    }\n\n    return null\n  }\n\n  /**\n   * 🔧 取消任务\n   * @param {string} taskId - 任务ID\n   * @returns {boolean} 是否成功取消\n   */\n  cancelTask(taskId) {\n    // 只能取消排队中的任务\n    if (this.taskQueue.has(taskId)) {\n      const task = this.taskQueue.get(taskId)\n      this.taskQueue.delete(taskId)\n\n      // 移动到失败队列（标记为取消）\n      this.failedTasks.set(taskId, {\n        ...task,\n        status: QUEUE_TASK_STATUS.CANCELLED,\n        cancelledAt: Date.now()\n      })\n\n      console.log(`🚫 任务已取消: ${taskId}`)\n      return true\n    }\n\n    console.warn(`⚠️ 无法取消任务: ${taskId} (任务可能已在处理中)`)\n    return false\n  }\n\n  /**\n   * 🔧 暂停队列\n   */\n  pause() {\n    this.isPaused = true\n    console.log('⏸️ 队列已暂停')\n  }\n\n  /**\n   * 🔧 恢复队列\n   */\n  resume() {\n    this.isPaused = false\n    console.log('▶️ 队列已恢复')\n    this.processQueue()\n  }\n\n  /**\n   * 🔧 清空队列\n   */\n  clearQueue() {\n    const queuedCount = this.taskQueue.size\n\n    // 将所有排队任务移动到失败队列\n    this.taskQueue.forEach((task, taskId) => {\n      this.failedTasks.set(taskId, {\n        ...task,\n        status: QUEUE_TASK_STATUS.CANCELLED,\n        cancelledAt: Date.now()\n      })\n    })\n\n    this.taskQueue.clear()\n    console.log(`🧹 已清空队列，取消了 ${queuedCount} 个任务`)\n  }\n\n  /**\n   * 🔧 停止队列管理器\n   */\n  stop() {\n    // 停止所有定时器\n    if (this.processingInterval) {\n      clearInterval(this.processingInterval)\n      this.processingInterval = null\n    }\n\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval)\n      this.monitoringInterval = null\n    }\n\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer)\n      this.cleanupTimer = null\n    }\n\n    this.isProcessing = false\n    console.log('⏹️ 任务队列管理器已停止')\n  }\n\n  /**\n   * 🔧 获取详细状态报告\n   * @returns {Object} 详细状态\n   */\n  getDetailedStatus() {\n    const now = Date.now()\n\n    return {\n      overview: this.getQueueStatus(),\n      queuedTasks: Array.from(this.taskQueue.values()).map(task => ({\n        id: task.id,\n        workflowType: task.workflowType,\n        priority: task.priority,\n        queuedAt: task.queuedAt,\n        waitingTime: now - task.queuedAt\n      })),\n      processingTasks: Array.from(this.processingTasks.values()).map(task => ({\n        id: task.id,\n        workflowType: task.workflowType,\n        startedAt: task.startedAt,\n        processingTime: now - task.startedAt,\n        lastProgressUpdate: task.lastProgressUpdate,\n        timeSinceLastProgress: now - task.lastProgressUpdate,\n        progressHistory: task.progressHistory.slice(-5) // 最近5个进度记录\n      })),\n      recentCompleted: Array.from(this.completedTasks.values())\n        .sort((a, b) => b.completedAt - a.completedAt)\n        .slice(0, 10)\n        .map(task => ({\n          id: task.id,\n          workflowType: task.workflowType,\n          processingTime: task.processingTime,\n          completedAt: task.completedAt\n        })),\n      recentFailed: Array.from(this.failedTasks.values())\n        .sort((a, b) => b.failedAt - a.failedAt)\n        .slice(0, 10)\n        .map(task => ({\n          id: task.id,\n          workflowType: task.workflowType,\n          attempts: task.attempts,\n          errors: task.errors,\n          failedAt: task.failedAt\n        }))\n    }\n  }\n}\n\nexport default TaskQueueManager\n"
        }
    ]
}