{
    "sourceFile": "client/src/utils/testSimpleLoadBalancer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1752518951792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752518971386,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -152,9 +152,9 @@\n     const normalServer = await loadBalancer.getOptimalServer()\n     console.log(`✅ 正常情况下选择: ${normalServer}`)\n \n     // 2. 获取服务器列表\n-    const servers = await loadBalancer.getLatestServerList()\n+    const servers = await loadBalancer.getServerList()\n     console.log(`📋 当前有 ${servers.length} 个配置的服务器`)\n \n     // 3. 模拟第一个服务器故障（通过使用错误的URL）\n     if (servers.length > 1) {\n"
                },
                {
                    "date": 1752549420444,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,31 +15,30 @@\n     console.log('\\n📋 测试1: 初始化负载均衡器')\n     await loadBalancer.initialize()\n     console.log('✅ 初始化成功')\n \n-    // 2. 测试获取服务器列表\n-    console.log('\\n📋 测试2: 获取服务器列表')\n-    const servers = await loadBalancer.getServerList()\n-    console.log(`✅ 获取到 ${servers.length} 个服务器:`)\n-    servers.forEach((server, index) => {\n-      console.log(`   ${index + 1}. ${server.url} (${server.type}, 优先级: ${server.priority})`)\n+    // 2. 测试加载服务器列表\n+    console.log('\\n📋 测试2: 加载服务器列表')\n+    await loadBalancer.loadServerList()\n+    console.log(`✅ 服务器列表加载完成，共 ${loadBalancer.serverList.length} 个服务器:`)\n+    loadBalancer.serverList.forEach((server, index) => {\n+      console.log(`   ${index + 1}. ${server.url} (${server.type})`)\n     })\n \n-    // 3. 测试直接连接\n-    console.log('\\n📋 测试3: 测试直接连接')\n-    if (servers.length > 0) {\n-      const server = servers[0]\n-      const health = await loadBalancer.testDirectConnection(server.url)\n-      console.log(`✅ 服务器 ${server.url} 连接状态:`, health)\n-    }\n+    // 3. 测试健康检查\n+    console.log('\\n📋 测试3: 执行健康检查')\n+    await loadBalancer.refreshHealthStatus()\n+    console.log('✅ 健康检查完成')\n+    loadBalancer.serverList.forEach((server, index) => {\n+      const status = server.healthy === true ? '✅ 健康' :\n+                    server.healthy === false ? '❌ 异常' : '⏳ 未知'\n+      console.log(`   ${index + 1}. ${server.url}: ${status}`)\n+    })\n \n-    // 4. 测试队列信息获取\n-    console.log('\\n📋 测试4: 获取服务器队列信息')\n-    if (servers.length > 0) {\n-      const server = servers[0]\n-      const queue = await loadBalancer.getQueueInfo(server.url)\n-      console.log(`✅ 服务器 ${server.url} 队列信息:`, queue)\n-    }\n+    // 4. 测试获取最优服务器\n+    console.log('\\n📋 测试4: 获取最优服务器')\n+    const optimalServer = await loadBalancer.getOptimalServer()\n+    console.log(`✅ 最优服务器: ${optimalServer}`)\n \n     // 5. 测试服务器选择\n     console.log('\\n📋 测试5: 选择最优服务器')\n     for (let i = 0; i < 3; i++) {\n"
                },
                {
                    "date": 1752549462080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -151,28 +151,28 @@\n     const normalServer = await loadBalancer.getOptimalServer()\n     console.log(`✅ 正常情况下选择: ${normalServer}`)\n \n     // 2. 获取服务器列表\n-    const servers = await loadBalancer.getServerList()\n+    await loadBalancer.loadServerList()\n+    const servers = loadBalancer.serverList\n     console.log(`📋 当前有 ${servers.length} 个配置的服务器`)\n \n-    // 3. 模拟第一个服务器故障（通过使用错误的URL）\n+    // 3. 模拟第一个服务器故障\n     if (servers.length > 1) {\n       console.log('\\n📋 步骤2: 模拟服务器故障')\n \n-      // 临时修改第一个服务器的URL为无效地址\n-      const originalUrl = servers[0].url\n-      servers[0].url = 'http://invalid-server.com'\n+      // 记录第一个服务器故障\n+      const firstServer = servers[0]\n+      await loadBalancer.recordFailure(firstServer.url, 'simulated')\n+      console.log(`⚠️ 模拟服务器故障: ${firstServer.url}`)\n \n-      console.log(`⚠️ 模拟服务器故障: ${originalUrl} -> ${servers[0].url}`)\n-\n       // 重新选择服务器\n       const fallbackServer = await loadBalancer.getOptimalServer()\n       console.log(`✅ 故障转移后选择: ${fallbackServer}`)\n \n-      // 恢复原始URL\n-      servers[0].url = originalUrl\n-      console.log(`🔄 恢复服务器: ${originalUrl}`)\n+      // 刷新健康状态以恢复\n+      console.log('🔄 刷新健康状态...')\n+      await loadBalancer.refreshHealthStatus()\n     } else {\n       console.log('⚠️ 只有一个服务器，无法测试故障转移')\n     }\n \n"
                },
                {
                    "date": 1752551477832,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,14 +25,21 @@\n     })\n \n     // 3. 测试健康检查\n     console.log('\\n📋 测试3: 执行健康检查')\n+    loadBalancer.setVerboseLogging(true) // 启用详细日志\n     await loadBalancer.refreshHealthStatus()\n+    loadBalancer.setVerboseLogging(false) // 关闭详细日志\n     console.log('✅ 健康检查完成')\n+\n+    // 显示服务器状态和队列信息\n     loadBalancer.serverList.forEach((server, index) => {\n       const status = server.healthy === true ? '✅ 健康' :\n                     server.healthy === false ? '❌ 异常' : '⏳ 未知'\n-      console.log(`   ${index + 1}. ${server.url}: ${status}`)\n+      const queueText = server.queueInfo.total > 0\n+        ? `队列: ${server.queueInfo.running}运行/${server.queueInfo.pending}等待`\n+        : '队列: 空闲'\n+      console.log(`   ${index + 1}. ${server.url}: ${status} | ${queueText}`)\n     })\n \n     // 4. 测试获取最优服务器\n     console.log('\\n📋 测试4: 获取最优服务器')\n"
                },
                {
                    "date": 1752551498115,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,8 +45,19 @@\n     console.log('\\n📋 测试4: 获取最优服务器')\n     const optimalServer = await loadBalancer.getOptimalServer()\n     console.log(`✅ 最优服务器: ${optimalServer}`)\n \n+    // 显示选择原因\n+    const healthyServers = loadBalancer.serverList.filter(s => s.healthy === true)\n+    if (healthyServers.length > 1) {\n+      console.log('📊 负载均衡选择依据:')\n+      healthyServers.forEach(server => {\n+        const isSelected = server.url === optimalServer\n+        const marker = isSelected ? '👉' : '  '\n+        console.log(`${marker} ${server.type}: 队列${server.queueInfo.total}`)\n+      })\n+    }\n+\n     // 5. 测试服务器选择\n     console.log('\\n📋 测试5: 选择最优服务器')\n     for (let i = 0; i < 3; i++) {\n       const selectedServer = await loadBalancer.getOptimalServer()\n"
                }
            ],
            "date": 1752518951792,
            "name": "Commit-0",
            "content": "/**\n * 极简负载均衡器测试工具\n */\n\nimport loadBalancer from '../services/loadBalancer.js'\n\n/**\n * 测试负载均衡器的基本功能\n */\nexport async function testSimpleLoadBalancer() {\n  console.log('🧪 开始测试极简负载均衡器...')\n\n  try {\n    // 1. 测试初始化\n    console.log('\\n📋 测试1: 初始化负载均衡器')\n    await loadBalancer.initialize()\n    console.log('✅ 初始化成功')\n\n    // 2. 测试获取服务器列表\n    console.log('\\n📋 测试2: 获取服务器列表')\n    const servers = await loadBalancer.getServerList()\n    console.log(`✅ 获取到 ${servers.length} 个服务器:`)\n    servers.forEach((server, index) => {\n      console.log(`   ${index + 1}. ${server.url} (${server.type}, 优先级: ${server.priority})`)\n    })\n\n    // 3. 测试直接连接\n    console.log('\\n📋 测试3: 测试直接连接')\n    if (servers.length > 0) {\n      const server = servers[0]\n      const health = await loadBalancer.testDirectConnection(server.url)\n      console.log(`✅ 服务器 ${server.url} 连接状态:`, health)\n    }\n\n    // 4. 测试队列信息获取\n    console.log('\\n📋 测试4: 获取服务器队列信息')\n    if (servers.length > 0) {\n      const server = servers[0]\n      const queue = await loadBalancer.getQueueInfo(server.url)\n      console.log(`✅ 服务器 ${server.url} 队列信息:`, queue)\n    }\n\n    // 5. 测试服务器选择\n    console.log('\\n📋 测试5: 选择最优服务器')\n    for (let i = 0; i < 3; i++) {\n      const selectedServer = await loadBalancer.getOptimalServer()\n      console.log(`   第${i + 1}次选择: ${selectedServer}`)\n\n      // 等待1秒\n      await new Promise(resolve => setTimeout(resolve, 1000))\n    }\n\n    console.log('\\n✅ 所有测试完成！')\n\n  } catch (error) {\n    console.error('❌ 测试失败:', error)\n  }\n}\n\n/**\n * 测试多次服务器选择，验证负载均衡效果\n */\nexport async function testLoadBalancing(times = 10) {\n  console.log(`🧪 开始测试负载均衡效果 (${times}次选择)...`)\n\n  const selections = new Map()\n\n  try {\n    for (let i = 0; i < times; i++) {\n      const server = await loadBalancer.getOptimalServer()\n      const count = selections.get(server) || 0\n      selections.set(server, count + 1)\n\n      console.log(`第${i + 1}次选择: ${server}`)\n\n      // 短暂延迟\n      await new Promise(resolve => setTimeout(resolve, 500))\n    }\n\n    console.log('\\n📊 负载均衡结果统计:')\n    for (const [server, count] of selections.entries()) {\n      const percentage = ((count / times) * 100).toFixed(1)\n      console.log(`   ${server}: ${count}次 (${percentage}%)`)\n    }\n\n  } catch (error) {\n    console.error('❌ 负载均衡测试失败:', error)\n  }\n}\n\n/**\n * 模拟用户生图请求的服务器选择\n */\nexport async function simulateUserRequests(userCount = 5) {\n  console.log(`🧪 模拟 ${userCount} 个用户同时发起生图请求...`)\n\n  const promises = []\n\n  for (let i = 0; i < userCount; i++) {\n    const promise = (async () => {\n      const userId = `用户${i + 1}`\n      console.log(`👤 ${userId} 开始选择服务器...`)\n\n      try {\n        const server = await loadBalancer.getOptimalServer()\n        console.log(`👤 ${userId} 选择了服务器: ${server}`)\n        return { userId, server, success: true }\n      } catch (error) {\n        console.error(`👤 ${userId} 选择服务器失败:`, error)\n        return { userId, error: error.message, success: false }\n      }\n    })()\n\n    promises.push(promise)\n  }\n\n  try {\n    const results = await Promise.all(promises)\n\n    console.log('\\n📊 用户请求结果统计:')\n    const serverCounts = new Map()\n    let successCount = 0\n\n    results.forEach(result => {\n      if (result.success) {\n        successCount++\n        const count = serverCounts.get(result.server) || 0\n        serverCounts.set(result.server, count + 1)\n      }\n    })\n\n    console.log(`✅ 成功: ${successCount}/${userCount}`)\n    console.log('📊 服务器分配:')\n    for (const [server, count] of serverCounts.entries()) {\n      console.log(`   ${server}: ${count}个用户`)\n    }\n\n  } catch (error) {\n    console.error('❌ 用户请求模拟失败:', error)\n  }\n}\n\n/**\n * 测试服务器故障恢复\n */\nexport async function testServerFailover() {\n  console.log('🧪 测试服务器故障恢复...')\n\n  try {\n    // 1. 正常选择服务器\n    console.log('\\n📋 步骤1: 正常选择服务器')\n    const normalServer = await loadBalancer.getOptimalServer()\n    console.log(`✅ 正常情况下选择: ${normalServer}`)\n\n    // 2. 获取服务器列表\n    const servers = await loadBalancer.getLatestServerList()\n    console.log(`📋 当前有 ${servers.length} 个配置的服务器`)\n\n    // 3. 模拟第一个服务器故障（通过使用错误的URL）\n    if (servers.length > 1) {\n      console.log('\\n📋 步骤2: 模拟服务器故障')\n\n      // 临时修改第一个服务器的URL为无效地址\n      const originalUrl = servers[0].url\n      servers[0].url = 'http://invalid-server.com'\n\n      console.log(`⚠️ 模拟服务器故障: ${originalUrl} -> ${servers[0].url}`)\n\n      // 重新选择服务器\n      const fallbackServer = await loadBalancer.getOptimalServer()\n      console.log(`✅ 故障转移后选择: ${fallbackServer}`)\n\n      // 恢复原始URL\n      servers[0].url = originalUrl\n      console.log(`🔄 恢复服务器: ${originalUrl}`)\n    } else {\n      console.log('⚠️ 只有一个服务器，无法测试故障转移')\n    }\n\n  } catch (error) {\n    console.error('❌ 服务器故障恢复测试失败:', error)\n  }\n}\n\n// 添加全局测试方法\nif (typeof window !== 'undefined') {\n  window.testSimpleLoadBalancer = testSimpleLoadBalancer\n  window.testLoadBalancing = testLoadBalancing\n  window.simulateUserRequests = simulateUserRequests\n  window.testServerFailover = testServerFailover\n\n  console.log('🔧 极简负载均衡器测试工具已加载')\n  console.log('可用的测试方法:')\n  console.log('  - window.testSimpleLoadBalancer() - 基本功能测试')\n  console.log('  - window.testLoadBalancing(10) - 负载均衡效果测试')\n  console.log('  - window.simulateUserRequests(5) - 模拟用户请求')\n  console.log('  - window.testServerFailover() - 服务器故障恢复测试')\n}\n\nexport default {\n  testSimpleLoadBalancer,\n  testLoadBalancing,\n  simulateUserRequests,\n  testServerFailover\n}\n"
        }
    ]
}