#!/usr/bin/env node

/**
 * AIMagic È°πÁõÆÁ´ØÂè£ÈÖçÁΩÆÁÆ°ÁêÜÂô®
 * Áªü‰∏ÄÁÆ°ÁêÜÂíåÈ™åËØÅÊâÄÊúâÊúçÂä°ÁöÑÁ´ØÂè£ÈÖçÁΩÆ
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class PortConfigManager {
  constructor() {
    this.configPath = path.join(__dirname, '..', 'port-config.json');
    this.config = this.loadConfig();
    this.logPath = path.join(__dirname, '..', 'PORT_CONFIG_CHANGELOG.md');
  }

  loadConfig() {
    try {
      const configContent = fs.readFileSync(this.configPath, 'utf8');
      return JSON.parse(configContent);
    } catch (error) {
      console.error('‚ùå Êó†Ê≥ïÂä†ËΩΩÁ´ØÂè£ÈÖçÁΩÆÊñá‰ª∂:', error.message);
      process.exit(1);
    }
  }

  // Ê£ÄÊü•ÊâÄÊúâÈÖçÁΩÆÊñá‰ª∂‰∏≠ÁöÑÁ´ØÂè£ËÆæÁΩÆ
  async checkPortConsistency() {
    console.log('üîç Ê£ÄÊü•Á´ØÂè£ÈÖçÁΩÆ‰∏ÄËá¥ÊÄß...\n');

    const issues = [];
    const standardPorts = this.config.ports;

    // Ê£ÄÊü•ÈÖçÁΩÆÊñá‰ª∂ÂàóË°®
    const configFiles = [
      {
        path: 'client/vite.config.js',
        service: 'client',
        patterns: [
          { regex: /port:\s*(\d+)/, description: 'Vite dev server port' }
        ]
      },
      {
        path: 'admin/vite.config.js',
        service: 'admin',
        patterns: [
          { regex: /port:\s*(\d+)/, description: 'Vite dev server port' }
        ]
      },
      {
        path: 'server/.env',
        service: 'server',
        patterns: [
          { regex: /PORT=(\d+)/, description: 'Server port' },
          { regex: /SERVER_PORT=(\d+)/, description: 'Server port variable' }
        ]
      },
      {
        path: 'server/src/app.js',
        service: 'server',
        patterns: [
          { regex: /PORT.*?(\d+)/, description: 'App.js port fallback' }
        ]
      }
    ];

    for (const configFile of configFiles) {
      const filePath = path.join(__dirname, '..', configFile.path);

      if (!fs.existsSync(filePath)) {
        issues.push({
          file: configFile.path,
          issue: 'Êñá‰ª∂‰∏çÂ≠òÂú®',
          severity: 'warning'
        });
        continue;
      }

      const content = fs.readFileSync(filePath, 'utf8');
      const expectedPort = standardPorts[configFile.service];

      for (const pattern of configFile.patterns) {
        const matches = content.match(pattern.regex);
        if (matches) {
          const foundPort = parseInt(matches[1]);
          if (foundPort !== expectedPort) {
            issues.push({
              file: configFile.path,
              issue: `${pattern.description}: ÂèëÁé∞Á´ØÂè£ ${foundPort}, ÊúüÊúõ ${expectedPort}`,
              severity: 'error',
              foundPort,
              expectedPort,
              service: configFile.service
            });
          }
        }
      }
    }

    return issues;
  }

  // ‰øÆÂ§çÁ´ØÂè£ÈÖçÁΩÆ
  async fixPortConfiguration() {
    console.log('üîß ÂºÄÂßã‰øÆÂ§çÁ´ØÂè£ÈÖçÁΩÆ...\n');

    const fixes = [];
    const standardPorts = this.config.ports;

    // ‰øÆÂ§ç client/vite.config.js
    await this.fixViteConfig('client', standardPorts.client, fixes);

    // ‰øÆÂ§ç admin/vite.config.js
    await this.fixViteConfig('admin', standardPorts.admin, fixes);

    // ‰øÆÂ§ç server/.env
    await this.fixServerEnv(standardPorts.server, fixes);

    // ‰øÆÂ§ç server/src/app.js Êàñ server/app.js
    await this.fixServerApp(standardPorts.server, fixes);

    // ËÆ∞ÂΩï‰øÆÂ§çÊó•Âøó
    if (fixes.length > 0) {
      this.logChanges(fixes);
    }

    return fixes;
  }

  async fixViteConfig(service, port, fixes) {
    const configPath = path.join(__dirname, '..', service, 'vite.config.js');

    if (!fs.existsSync(configPath)) {
      console.log(`‚ö†Ô∏è ${service}/vite.config.js ‰∏çÂ≠òÂú®ÔºåË∑≥Ëøá‰øÆÂ§ç`);
      return;
    }

    let content = fs.readFileSync(configPath, 'utf8');
    const originalContent = content;

    // ‰øÆÂ§çÁ´ØÂè£ÈÖçÁΩÆ
    content = content.replace(
      /port:\s*\d+/g,
      `port: ${port}`
    );

    // Â¶ÇÊûúÊòØ adminÔºåËøòÈúÄË¶Å‰øÆÂ§ç‰ª£ÁêÜÈÖçÁΩÆ‰∏≠ÁöÑÊúçÂä°Âô®Á´ØÂè£
    if (service === 'admin') {
      content = content.replace(
        /target:\s*['"`]http:\/\/localhost:\d+['"`]/g,
        `target: 'http://localhost:${this.config.ports.server}'`
      );
    }

    if (content !== originalContent) {
      fs.writeFileSync(configPath, content);
      fixes.push({
        file: `${service}/vite.config.js`,
        action: `Á´ØÂè£‰øÆÂ§ç‰∏∫ ${port}`,
        timestamp: new Date().toISOString()
      });
      console.log(`‚úÖ ‰øÆÂ§ç ${service}/vite.config.js Á´ØÂè£‰∏∫ ${port}`);
    }
  }

  async fixServerEnv(port, fixes) {
    const envPath = path.join(__dirname, '..', 'server', '.env');

    if (!fs.existsSync(envPath)) {
      // ÂàõÂª∫ .env Êñá‰ª∂
      const envContent = `PORT=${port}\nSERVER_PORT=${port}\n`;
      fs.writeFileSync(envPath, envContent);
      fixes.push({
        file: 'server/.env',
        action: `ÂàõÂª∫ .env Êñá‰ª∂ÔºåËÆæÁΩÆÁ´ØÂè£‰∏∫ ${port}`,
        timestamp: new Date().toISOString()
      });
      console.log(`‚úÖ ÂàõÂª∫ server/.envÔºåÁ´ØÂè£ËÆæÁΩÆ‰∏∫ ${port}`);
      return;
    }

    let content = fs.readFileSync(envPath, 'utf8');
    const originalContent = content;

    // ‰øÆÂ§çÊàñÊ∑ªÂä† PORT ÈÖçÁΩÆ
    if (content.includes('PORT=')) {
      content = content.replace(/PORT=\d+/g, `PORT=${port}`);
    } else {
      content += `\nPORT=${port}`;
    }

    // ‰øÆÂ§çÊàñÊ∑ªÂä† SERVER_PORT ÈÖçÁΩÆ
    if (content.includes('SERVER_PORT=')) {
      content = content.replace(/SERVER_PORT=\d+/g, `SERVER_PORT=${port}`);
    } else {
      content += `\nSERVER_PORT=${port}`;
    }

    if (content !== originalContent) {
      fs.writeFileSync(envPath, content);
      fixes.push({
        file: 'server/.env',
        action: `Á´ØÂè£‰øÆÂ§ç‰∏∫ ${port}`,
        timestamp: new Date().toISOString()
      });
      console.log(`‚úÖ ‰øÆÂ§ç server/.env Á´ØÂè£‰∏∫ ${port}`);
    }
  }

  async fixServerApp(port, fixes) {
    // Â∞ùËØï‰∏§‰∏™ÂèØËÉΩÁöÑË∑ØÂæÑ
    const appPaths = [
      path.join(__dirname, '..', 'server', 'src', 'app.js'),
      path.join(__dirname, '..', 'server', 'app.js')
    ];

    let appPath = null;
    for (const p of appPaths) {
      if (fs.existsSync(p)) {
        appPath = p;
        break;
      }
    }

    if (!appPath) {
      console.log(`‚ö†Ô∏è server/app.js Êàñ server/src/app.js ‰∏çÂ≠òÂú®ÔºåË∑≥Ëøá‰øÆÂ§ç`);
      return;
    }

    let content = fs.readFileSync(appPath, 'utf8');
    const originalContent = content;

    // ‰øÆÂ§çÁ´ØÂè£ÈÖçÁΩÆÁöÑÈªòËÆ§ÂÄº
    content = content.replace(
      /process\.env\.PORT\s*\|\|\s*\d+/g,
      `process.env.PORT || ${port}`
    );

    if (content !== originalContent) {
      fs.writeFileSync(appPath, content);
      fixes.push({
        file: 'server/src/app.js',
        action: `Á´ØÂè£ÈªòËÆ§ÂÄº‰øÆÂ§ç‰∏∫ ${port}`,
        timestamp: new Date().toISOString()
      });
      console.log(`‚úÖ ‰øÆÂ§ç server/src/app.js Á´ØÂè£ÈªòËÆ§ÂÄº‰∏∫ ${port}`);
    }
  }

  // ËÆ∞ÂΩïÂèòÊõ¥Êó•Âøó
  logChanges(fixes) {
    if (fixes.length === 0) return;

    const logEntry = `
## Á´ØÂè£ÈÖçÁΩÆ‰øÆÂ§ç - ${new Date().toISOString()}

### ‰øÆÂ§çÂÜÖÂÆπ:
${fixes.map(fix => `- **${fix.file}**: ${fix.action}`).join('\n')}

### Ê†áÂáÜÁ´ØÂè£ÈÖçÁΩÆ:
- ÂÆ¢Êà∑Á´ØÂâçÁ´Ø: ${this.config.ports.client}
- ÂêéÂè∞ÁÆ°ÁêÜÁ≥ªÁªü: ${this.config.ports.admin}
- ÂêéÁ´ØAPIÊúçÂä°: ${this.config.ports.server}

---
`;

    if (fs.existsSync(this.logPath)) {
      const existingLog = fs.readFileSync(this.logPath, 'utf8');
      fs.writeFileSync(this.logPath, logEntry + existingLog);
    } else {
      const header = `# AIMagic Á´ØÂè£ÈÖçÁΩÆÂèòÊõ¥Êó•Âøó

Ê≠§Êñá‰ª∂ËÆ∞ÂΩïÊâÄÊúâÁ´ØÂè£ÈÖçÁΩÆÁöÑÂèòÊõ¥ÂéÜÂè≤„ÄÇ

`;
      fs.writeFileSync(this.logPath, header + logEntry);
    }
  }

  // È™åËØÅÁ´ØÂè£ÊòØÂê¶Ë¢´Âç†Áî®
  async checkPortAvailability() {
    console.log('üîç Ê£ÄÊü•Á´ØÂè£ÂèØÁî®ÊÄß...\n');

    const ports = Object.values(this.config.ports);
    const results = [];

    for (const port of ports) {
      try {
        // Âú® Windows ‰∏äÊ£ÄÊü•Á´ØÂè£Âç†Áî®
        const command = process.platform === 'win32'
          ? `netstat -ano | findstr :${port}`
          : `lsof -i :${port}`;

        const output = execSync(command, { encoding: 'utf8', stdio: 'pipe' });

        if (output.trim()) {
          results.push({
            port,
            status: 'occupied',
            details: output.trim()
          });
        } else {
          results.push({
            port,
            status: 'available'
          });
        }
      } catch (error) {
        // ÂëΩ‰ª§ÊâßË°åÂ§±Ë¥•ÈÄöÂ∏∏ÊÑèÂë≥ÁùÄÁ´ØÂè£Êú™Ë¢´Âç†Áî®
        results.push({
          port,
          status: 'available'
        });
      }
    }

    return results;
  }

  // ÁîüÊàêÁ´ØÂè£ÈÖçÁΩÆÊä•Âëä
  async generateReport() {
    console.log('üìä ÁîüÊàêÁ´ØÂè£ÈÖçÁΩÆÊä•Âëä...\n');

    const issues = await this.checkPortConsistency();
    const availability = await this.checkPortAvailability();

    const report = {
      timestamp: new Date().toISOString(),
      standardPorts: this.config.ports,
      issues,
      portAvailability: availability,
      summary: {
        totalIssues: issues.length,
        errorCount: issues.filter(i => i.severity === 'error').length,
        warningCount: issues.filter(i => i.severity === 'warning').length,
        portsOccupied: availability.filter(p => p.status === 'occupied').length
      }
    };

    return report;
  }
}

// CLI Êé•Âè£
async function main() {
  const manager = new PortConfigManager();
  const command = process.argv[2];

  switch (command) {
    case 'check':
      const issues = await manager.checkPortConsistency();
      if (issues.length === 0) {
        console.log('‚úÖ ÊâÄÊúâÁ´ØÂè£ÈÖçÁΩÆ‰∏ÄËá¥ÔºÅ');
      } else {
        console.log('‚ùå ÂèëÁé∞Á´ØÂè£ÈÖçÁΩÆÈóÆÈ¢ò:');
        issues.forEach(issue => {
          const icon = issue.severity === 'error' ? '‚ùå' : '‚ö†Ô∏è';
          console.log(`${icon} ${issue.file}: ${issue.issue}`);
        });
        process.exit(1);
      }
      break;

    case 'fix':
      const fixes = await manager.fixPortConfiguration();
      if (fixes.length === 0) {
        console.log('‚úÖ Á´ØÂè£ÈÖçÁΩÆÂ∑≤ÁªèÊ≠£Á°ÆÔºåÊó†ÈúÄ‰øÆÂ§ç');
      } else {
        console.log(`‚úÖ ÂÆåÊàê ${fixes.length} È°πÁ´ØÂè£ÈÖçÁΩÆ‰øÆÂ§ç`);
      }
      break;

    case 'report':
      const report = await manager.generateReport();
      console.log(JSON.stringify(report, null, 2));
      break;

    case 'availability':
      const availability = await manager.checkPortAvailability();
      availability.forEach(result => {
        const icon = result.status === 'available' ? '‚úÖ' : '‚ùå';
        console.log(`${icon} Á´ØÂè£ ${result.port}: ${result.status}`);
        if (result.details) {
          console.log(`   ${result.details}`);
        }
      });
      break;

    default:
      console.log(`
AIMagic Á´ØÂè£ÈÖçÁΩÆÁÆ°ÁêÜÂô®

Áî®Ê≥ï:
  node scripts/port-config-manager.js <command>

ÂëΩ‰ª§:
  check        Ê£ÄÊü•Á´ØÂè£ÈÖçÁΩÆ‰∏ÄËá¥ÊÄß
  fix          ‰øÆÂ§çÁ´ØÂè£ÈÖçÁΩÆÈóÆÈ¢ò
  report       ÁîüÊàêËØ¶ÁªÜÊä•Âëä
  availability Ê£ÄÊü•Á´ØÂè£ÂèØÁî®ÊÄß

Á§∫‰æã:
  node scripts/port-config-manager.js check
  node scripts/port-config-manager.js fix
      `);
  }
}

if (require.main === module) {
  main().catch(console.error);
}

module.exports = PortConfigManager;
